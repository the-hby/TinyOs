
E:/CppProject/TinyOs/src/build/source/kernel/kernel.elf:     file format elf32-i386
E:/CppProject/TinyOs/src/build/source/kernel/kernel.elf
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00010000

Program Header:
    LOAD off    0x00001000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x00005f98 memsz 0x00005f98 flags r-x
    LOAD off    0x00007000 vaddr 0x00016000 paddr 0x00016000 align 2**12
         filesz 0x0000009c memsz 0x00055300 flags rw-
    LOAD off    0x00008000 vaddr 0x80000000 paddr 0x0006b300 align 2**12
         filesz 0x000003c4 memsz 0x000003c4 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005338  00010000  00010000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00000c58  00015340  00015340  00006340  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         0000009c  00016000  00016000  00007000  2**5
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00054300  00017000  00017000  0000709c  2**12
                  ALLOC
  4 .first_task   000003c4  80000000  0006b300  00008000  2**0
                  CONTENTS, ALLOC, LOAD, CODE
  5 .debug_line   0000302c  00000000  00000000  000083c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000b822  00000000  00000000  0000b3f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002664  00000000  00000000  00016c12  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 000002e0  00000000  00000000  00019278  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_ranges 000000a8  00000000  00000000  00019558  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002122  00000000  00000000  00019600  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      00000011  00000000  00000000  0001b722  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00002108  00000000  00000000  0001b734  2**2
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
00015340 l    d  .rodata	00000000 .rodata
00016000 l    d  .data	00000000 .data
00017000 l    d  .bss	00000000 .bss
80000000 l    d  .first_task	00000000 .first_task
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 CMakeFiles/kernel.dir/init/start.S.obj
00010013 l       .text	00000000 gdt_reload
00000000 l    df *ABS*	00000000 memory.c
000102e5 l     F .text	00000011 read_cr0
000102f6 l     F .text	0000000c write_cr0
00010302 l     F .text	0000000c write_cr3
0001030e l     F .text	0000000c write_cr4
0001031a l     F .text	00000011 read_cr4
0001032b l     F .text	0000000d down2
00010338 l     F .text	00000017 up2
0001034f l     F .text	0000003e mmu_set_page_dir
0001038d l     F .text	0000000b pde_index
00010398 l     F .text	00000010 pte_index
000103a8 l     F .text	00000010 pde_paddr
000103b8 l     F .text	00000010 pte_paddr
000103c8 l     F .text	0000000f get_pte_perm
00017000 l     O .bss	00000028 paddr_alloc
00018000 l     O .bss	00001000 kernel_page_dir
000103d7 l     F .text	00000058 addr_alloc_init
0001042f l     F .text	00000067 addr_alloc_page
00010496 l     F .text	00000062 addr_free_page
000104f8 l     F .text	00000037 total_mem_size
0001546c l     O .rodata	00000012 __func__.2514
00016000 l     O .data	00000050 kernel_map.2525
00015480 l     O .rodata	0000000c __func__.2545
00010946 l     F .text	00000013 curr_page_dir
0001548c l     O .rodata	00000011 __func__.2586
000154a0 l     O .rodata	00000009 __func__.2646
00000000 l    df *ABS*	00000000 syscall.c
000154c0 l     O .rodata	00000194 sys_table
00000000 l    df *ABS*	00000000 task.c
00010ec1 l     F .text	00000011 read_cr0
00010ed2 l     F .text	0000000c write_cr0
00010ede l     F .text	00000007 hlt
00010ee5 l     F .text	00000017 write_tr
00010efc l     F .text	0000000c write_cr3
00010f08 l     F .text	0000000c write_cr4
00010f14 l     F .text	00000011 read_cr4
00010f25 l     F .text	0000001b list_node_init
00010f40 l     F .text	0000000b list_node_next
00010f4b l     F .text	0000000b list_count
00010f56 l     F .text	0000000a list_first
00010f60 l     F .text	0000003e mmu_set_page_dir
00019000 l     O .bss	000005b8 task_manager
000195c0 l     O .bss	00001000 idle_task_stack
0001a5c0 l     O .bss	00016200 task_table
000307c0 l     O .bss	00000014 table_mutex
00010f9e l     F .text	0000019b tss_init
00015798 l     O .rodata	0000000a __func__.2844
00011356 l     F .text	0000000a idle_task_entry
000157a4 l     O .rodata	00000010 __func__.2875
0001186f l     F .text	00000068 alloc_task
000118d7 l     F .text	00000033 free_task
00011a7b l     F .text	000000fe load_phdr
00011b79 l     F .text	000001be load_elf_file
00011d37 l     F .text	000000f3 copy_args
000157b4 l     O .rodata	0000000a __func__.2997
00000000 l    df *ABS*	00000000 cpu.c
0001207c l     F .text	00000028 lgdt
000120a4 l     F .text	0000001a far_jump
000307e0 l     O .bss	00000800 gdt_table
00030fe0 l     O .bss	00000014 mutex
00000000 l    df *ABS*	00000000 irq.c
000122f3 l     F .text	00000007 cli
000122fa l     F .text	00000007 sti
00012301 l     F .text	0000001d inb
0001231e l     F .text	0000001f outb
0001233d l     F .text	00000028 lidt
00012365 l     F .text	00000007 hlt
0001236c l     F .text	00000010 read_eflags
0001237c l     F .text	0000000b write_eflags
00012387 l     F .text	00000011 read_cr2
00012398 l     F .text	00000093 init_pic
00031000 l     O .bss	00000400 idt_table
0001273b l     F .text	000000f8 dump_core_regs
00012833 l     F .text	0000003f do_default_handler
00000000 l    df *ABS*	00000000 console.c
00012c47 l     F .text	0000001d inb
00012c64 l     F .text	0000001f outb
00031400 l     O .bss	000002a0 console_buf
00012c83 l     F .text	00000052 read_cursor_pos
00012cd5 l     F .text	00000075 update_cursor_pos
00012d4a l     F .text	00000093 erase_rows
00012ddd l     F .text	00000089 scroll_up
00012e66 l     F .text	00000086 clear_display
00012eec l     F .text	00000010 move_to_col0
00012efc l     F .text	00000038 move_next_line
00012f34 l     F .text	00000076 move_forward
00012faa l     F .text	00000078 move_backword
000130fb l     F .text	00000095 show_char
00013190 l     F .text	0000003a erase_backword
000131ca l     F .text	0000001e save_cursor
000131e8 l     F .text	0000001e restore_cursor
00013206 l     F .text	00000029 clear_esc_param
0001322f l     F .text	00000071 write_esc
000132a0 l     F .text	00000099 set_font_style
00015d80 l     O .rodata	00000020 color_table.2421
00013339 l     F .text	00000051 erase_in_display
0001338a l     F .text	0000001e move_cursor
000133a8 l     F .text	00000037 move_left
000133df l     F .text	00000049 move_right
00013428 l     F .text	000000f4 write_esc_square
0001351c l     F .text	000000a2 write_normal
00000000 l    df *ABS*	00000000 dev.c
00016050 l     O .data	00000004 dev_desc_tbl
000316a0 l     O .bss	00000a00 dev_tb
00013696 l     F .text	0000003c is_devid_bad
00000000 l    df *ABS*	00000000 kbd.c
0001398a l     F .text	0000001d inb
000320a0 l     O .bss	00000004 kbd_stat
00015da0 l     O .rodata	00000074 map_table
000320a4 l     O .bss	00000004 inited.2036
000139f6 l     F .text	0000001a is_make_code
00013a10 l     F .text	00000015 get_key
00013a25 l     F .text	000001c6 do_normal_key
000320a8 l     O .bss	00000004 recv_state.2072
00000000 l    df *ABS*	00000000 time.c
00013d0f l     F .text	0000001f outb
000320ac l     O .bss	00000004 sys_tick
00013d56 l     F .text	00000060 init_pit
00000000 l    df *ABS*	00000000 tty.c
000320c0 l     O .bss	00002200 tty_devs
00013dce l     F .text	0000004f get_tty
00000000 l    df *ABS*	00000000 file.c
000342c0 l     O .bss	0001c000 file_table
000502c0 l     O .bss	00000014 file_alloc_mutex
00000000 l    df *ABS*	00000000 fs.c
00014215 l     F .text	0000001d inb
00014232 l     F .text	0000001f inw
00014251 l     F .text	0000001f outb
000502e0 l     O .bss	00019000 TEMP_ADDR
000692e0 l     O .bss	00000004 temp_pos
00014270 l     F .text	0000012f read_disk
00000000 l    df *ABS*	00000000 init.c
00015f34 l     O .rodata	00000013 __func__.2905
00000000 l    df *ABS*	00000000 mutex.c
0001455c l     F .text	0000000b list_count
00000000 l    df *ABS*	00000000 sem.c
000146e3 l     F .text	0000000b list_count
00000000 l    df *ABS*	00000000 bitmap.c
00000000 l    df *ABS*	00000000 kilb.c
00014a9d l     F .text	00000007 hlt
00016098 l     O .data	00000004 num2ch.2085
00000000 l    df *ABS*	00000000 list.c
0001505b l     F .text	00000013 list_is_empty
00000000 l    df *ABS*	00000000 log.c
000692e4 l     O .bss	00000014 mutex
000692f8 l     O .bss	00000004 log_dev_id
00000000 l    df *ABS*	00000000 first_task.c
00000000 l    df *ABS*	00000000 lib_syscall.c
8000016f l     F .first_task	0000004c sys_call
00014895 g     F .text	0000004f bitmap_get_bit
00014c10 g     F .text	0000004f kernel_memcpy
0001446b g     F .text	0000000a sys_close
000115e5 g     F .text	0000000a task_current
80000271 g     F .first_task	0000001b yield
00012436 g     F .text	0000000b irq_enable_global
000150f2 g     F .text	00000064 list_insert_last
00011fd9 g     F .text	0000002c task_file
000102a8 g       .text	00000000 exception_handler_kbd
00010cf6 g     F .text	00000122 sys_sbrk
000117f5 g     F .text	00000064 sys_msleep
000129a6 g     F .text	0000001c do_handler_segment_not_present
0001153d g     F .text	00000036 task_set_ready
000149cf g     F .text	0000001b bitmap_is_set
00014c5f g     F .text	00000041 kernel_memset
0001386e g     F .text	0000004c dev_write
00014447 g     F .text	00000024 sys_lseek
000139a7 g     F .text	0000004f kbd_init
0001026a g       .text	00000000 exception_handler_virtual_exception
00010e32 g     F .text	0000008f do_handler_syscall
00012216 g     F .text	0000001e cpu_init
00015253 g     F .text	0000002f log_init
0001190a g     F .text	00000171 sys_fork
00014532 g     F .text	0000002a init_main
0001020f g       .text	00000000 exception_handler_alignment_check
000122bd g     F .text	00000036 gdt_free_sel
00010e18 g     F .text	0000001a sys_print_msg
00014aa4 g     F .text	00000047 kernel_strcpy
00013beb g     F .text	00000064 do_e0_key
00016000 g       .data	00000000 s_data
80000243 g     F .first_task	0000002e execve
800001e5 g     F .first_task	0000001b getpid
00012441 g     F .text	0000008b irq_enable
0001002b g       .text	00000000 exception_handler_unknown
000100a7 g       .text	00000000 exception_handler_breakpoint
000128fe g     F .text	0000001c do_handler_overflow
00012b83 g     F .text	0000001c do_handler_alignment_check
000105df g     F .text	0000009d memory_create_map
000143d8 g     F .text	00000040 sys_read
000101b6 g       .text	00000000 exception_handler_general_protection
000129de g     F .text	000000b5 do_handler_general_protection
00014803 g     F .text	00000029 sem_count
80000012 g     F .first_task	000000e0 first_task_main
0001288e g     F .text	0000001c do_handler_divider
000148e4 g     F .text	000000eb bitmap_set_bit
0001296e g     F .text	0000001c do_handler_double_fault
00012a93 g     F .text	000000d4 do_handler_page_fault
8000035b g     F .first_task	00000021 isatty
00010142 g       .text	00000000 exception_handler_double_fault
00012bf3 g     F .text	0000002b pic_send_eoi
00011533 g     F .text	0000000a task_first_task
00010000 g       .text	00000000 s_text
000107c8 g     F .text	00000085 memory_create_uvm
00014711 g     F .text	0000006e sem_wait
00010901 g     F .text	00000025 memory_alloc_page_for
00010199 g       .text	00000000 exception_handler_stack_segment_fault
80000000 g       .first_task	00000000 first_task_entry
0001447f g     F .text	0000000a sys_fstat
00013822 g     F .text	0000004c dev_read
00012bd7 g     F .text	0000001c do_handler_virtual_exception
000100c6 g       .text	00000000 exception_handler_overflow
8000032e g     F .first_task	0000002d lseek
00010289 g       .text	00000000 exception_handler_time
00069300 g     O .bss	00002000 stack
00014489 g     F .text	0000000e fs_init
00010959 g     F .text	00000099 memory_free_page
0006b300 g       *ABS*	00000000 s_first_task
00012056 g     F .text	00000026 task_remove_fd
0001410f g     F .text	0000000a tty_control
00013022 g     F .text	000000d9 console_init
0001400a g     F .text	00000008 tty_read
000112b2 g     F .text	00000086 task_uninit
0001084d g     F .text	000000b4 memory_alloc_for_page_dir
00013ec9 g     F .text	00000064 tty_fifo_get
000100e5 g       .text	00000000 exception_handler_bound_range
0001477f g     F .text	00000084 sem_notify
00010c74 g     F .text	00000082 memory_copy_uvm_data
000138ba g     F .text	0000004c dev_control
00013c4f g     F .text	000000c0 do_handler_kbd
00012936 g     F .text	0000001c do_handler_invalid_opcode
0001015f g       .text	00000000 exception_handler_invalid_tss
00012b67 g     F .text	0000001c do_handler_fpu_error
00011447 g     F .text	000000ec task_first_init
00012b9f g     F .text	0000001c do_handler_machine_check
800002e0 g     F .first_task	0000002d write
0001439f g     F .text	00000039 sys_open
000128aa g     F .text	0000001c do_handler_Debug
8000037c g     F .first_task	00000027 fstat
00014475 g     F .text	0000000a sys_isatty
00015093 g     F .text	0000005f list_insert_first
000136d2 g     F .text	00000150 dev_open
000117d3 g     F .text	00000022 task_set_wakeup
000128c6 g     F .text	0000001c do_handler_NMI
0001004a g       .text	00000000 exception_handler_divider
00013e1d g     F .text	00000037 tty_fifo_init
00014aeb g     F .text	00000070 kernel_strncpy
0001242b g     F .text	0000000b irq_disable_global
000115ef g     F .text	00000061 sys_sched_yield
00014418 g     F .text	0000002f sys_write
0006b6c4 g       *ABS*	00000000 mem_free_start
00014497 g     F .text	00000035 kernel_init
000146ee g     F .text	00000023 sem_init
00010000 g       .text	00000000 _start
00014e67 g     F .text	0000014b kernel_vsprintf
00015015 g     F .text	00000046 get_file_name
00010123 g       .text	00000000 exception_handler_device_unavailable
00010104 g       .text	00000000 exception_handler_invalid_opcode
00013906 g     F .text	00000084 dev_close
0006b300 g       .bss	00000000 e_data
800002b3 g     F .first_task	0000002d read
00014595 g     F .text	0000008f mutex_lock
00012005 g     F .text	00000051 task_alloc_fd
00014fe8 g     F .text	0000002d string_count
0001022c g       .text	00000000 exception_handler_machine_check
00014012 g     F .text	000000fd tty_write
0001298a g     F .text	0000001c do_handler_invalid_tss
00000000 g       .text	00000000 kernel_base
00013e54 g     F .text	00000075 tty_fifo_put
0006b6c4 g       *ABS*	00000000 e_first_task
00011797 g     F .text	0000003c task_set_sleep
00014fb2 g     F .text	00000036 panic
00012701 g     F .text	0000003a irq_install
00012144 g     F .text	0000008b init_gdt
00013f2d g     F .text	000000dd tty_open
80000228 g     F .first_task	0000001b fork
00012c1e g     F .text	00000018 irq_enter_protection
00014567 g     F .text	0000002e mutex_init
000124cc g     F .text	00000087 irq_disable
800003a3 g     F .first_task	00000021 sbrk
0001024b g       .text	00000000 exception_handler_smd_exception
000109f2 g     F .text	000000e7 memory_destroy_uvm
0001482c g     F .text	00000016 bitmap_byte_count
00012952 g     F .text	0000001c do_handler_device_unavailable
00011650 g     F .text	0000005b task_dispatch
00010ad9 g     F .text	00000155 memory_copy_uvm
00014119 g     F .text	00000006 tty_close
000144cc g     F .text	00000066 move_to_first_task
000122a9 g     F .text	00000014 switch_to_tss
000135be g     F .text	000000d2 console_write
000115a0 g     F .text	00000045 task_next_run
00014ca0 g     F .text	00000064 kernel_memcmp
0001067c g     F .text	000000a7 create_kernel_table
0001506e g     F .text	00000025 list_init
00012bbb g     F .text	0000001c do_handler_smd_exception
000101d3 g       .text	00000000 exception_handler_page_fault
00011573 g     F .text	0000002d task_set_block
00012872 g     F .text	0000001c do_handler_unknown
00010926 g     F .text	00000020 memory_alloc_page
000101f0 g       .text	00000000 exception_handler_fpu_error
00011338 g     F .text	0000001e task_switch_from_to
00012553 g     F .text	000001ae irq_init
00014624 g     F .text	000000bf mutex_unlock
000141e5 g     F .text	00000030 file_table_init
00012c36 g     F .text	00000011 irq_leave_protection
000141a3 g     F .text	00000042 file_free
80000200 g     F .first_task	00000028 print_msg
00014bd5 g     F .text	0000003b kernel_strlen
000120be g     F .text	00000086 segment_desc_set
0001291a g     F .text	0000001c do_handler_bound_range
000102c7 g       .text	00000000 exception_handler_syscall
00015156 g     F .text	00000078 list_remove_first
00015f98 g       .rodata	00000000 e_text
00014b5b g     F .text	0000007a kernel_strncmp
00014842 g     F .text	00000053 bitmap_init
0001017c g       .text	00000000 exception_handler_segment_not_present
00010088 g       .text	00000000 exception_handler_NMI
000149ea g     F .text	000000b3 bitmap_alloc_nbits
0001411f g     F .text	00000084 file_alloc
00011360 g     F .text	000000e7 task_manager_init
00011285 g     F .text	0000002d task_start
00010069 g       .text	00000000 exception_handler_Debug
000116ab g     F .text	000000ec task_time_tick
00010723 g     F .text	000000a5 memory_init
00011e2a g     F .text	000001af sys_execve
00013690 g     F .text	00000006 console_close
00010c2e g     F .text	00000046 memory_get_paddr
000129c2 g     F .text	0000001c do_handler_stack_segment_fault
000128e2 g     F .text	0000001c do_handler_breakpoint
00015282 g     F .text	000000b6 log_printf
00011139 g     F .text	0000014c task_init
8000028c g     F .first_task	00000027 open
00014d04 g     F .text	00000024 kernel_sprintf
00011859 g     F .text	00000016 sys_getpid
00012234 g     F .text	00000075 gdt_alloc_desc
00014d28 g     F .text	0000013f kernel_itoa
000151ce g     F .text	00000085 list_remove
000121cf g     F .text	00000047 gate_desc_set
800001bb g     F .first_task	0000002a msleep
8000030d g     F .first_task	00000021 close
0001052f g     F .text	000000b0 find_pte
00013d2e g     F .text	00000028 do_handler_time
00013db6 g     F .text	00000018 time_init
00016060 g     O .data	00000038 dev_tty_desc



Disassembly of section .text:

00010000 <_start>:
_start:
    // 从栈中取出参数,参数保存在%eax中,最终传递给kernel_init函数
    // 参数位于load_32.c中
    // 以下三步可以简写为: mov 4(%esp),%eax
    // 传递的是boot_info
    push %ebp
   10000:	55                   	push   %ebp
    mov %esp,%ebp
   10001:	89 e5                	mov    %esp,%ebp
    mov 0x8(%ebp),%eax
   10003:	8b 45 08             	mov    0x8(%ebp),%eax
    
    push %eax
   10006:	50                   	push   %eax

    // kernel_init 位于init.c中
    call kernel_init
   10007:	e8 8b 44 00 00       	call   14497 <kernel_init>

    // 加载到对应选择子以及偏移量
    jmp $KERNEL_SELECTOR_CS,$gdt_reload
   1000c:	ea 13 00 01 00 08 00 	ljmp   $0x8,$0x10013

00010013 <gdt_reload>:
gdt_reload:
    // 初始化寄存器
    mov $KERNEL_SELECTOR_DS,%ax
   10013:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
   10017:	8e d8                	mov    %eax,%ds
	mov %ax, %ss
   10019:	8e d0                	mov    %eax,%ss
	mov %ax, %es
   1001b:	8e c0                	mov    %eax,%es
	mov %ax, %fs
   1001d:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
   1001f:	8e e8                	mov    %eax,%gs
    mov $(stack+KERNEL_STACK_SIZE),%esp
   10021:	bc 00 b3 06 00       	mov    $0x6b300,%esp
    jmp init_main
   10026:	e9 07 45 00 00       	jmp    14532 <init_main>

0001002b <exception_handler_unknown>:
    iret

// 宏的结束
.endm

exception_handler unknown,-1,0
   1002b:	6a 00                	push   $0x0
   1002d:	6a ff                	push   $0xffffffff
   1002f:	60                   	pusha  
   10030:	1e                   	push   %ds
   10031:	06                   	push   %es
   10032:	0f a0                	push   %fs
   10034:	0f a8                	push   %gs
   10036:	54                   	push   %esp
   10037:	e8 36 28 00 00       	call   12872 <do_handler_unknown>
   1003c:	83 c4 04             	add    $0x4,%esp
   1003f:	0f a9                	pop    %gs
   10041:	0f a1                	pop    %fs
   10043:	07                   	pop    %es
   10044:	1f                   	pop    %ds
   10045:	61                   	popa   
   10046:	83 c4 08             	add    $0x8,%esp
   10049:	cf                   	iret   

0001004a <exception_handler_divider>:
exception_handler divider,0,0
   1004a:	6a 00                	push   $0x0
   1004c:	6a 00                	push   $0x0
   1004e:	60                   	pusha  
   1004f:	1e                   	push   %ds
   10050:	06                   	push   %es
   10051:	0f a0                	push   %fs
   10053:	0f a8                	push   %gs
   10055:	54                   	push   %esp
   10056:	e8 33 28 00 00       	call   1288e <do_handler_divider>
   1005b:	83 c4 04             	add    $0x4,%esp
   1005e:	0f a9                	pop    %gs
   10060:	0f a1                	pop    %fs
   10062:	07                   	pop    %es
   10063:	1f                   	pop    %ds
   10064:	61                   	popa   
   10065:	83 c4 08             	add    $0x8,%esp
   10068:	cf                   	iret   

00010069 <exception_handler_Debug>:
exception_handler Debug, 1, 0
   10069:	6a 00                	push   $0x0
   1006b:	6a 01                	push   $0x1
   1006d:	60                   	pusha  
   1006e:	1e                   	push   %ds
   1006f:	06                   	push   %es
   10070:	0f a0                	push   %fs
   10072:	0f a8                	push   %gs
   10074:	54                   	push   %esp
   10075:	e8 30 28 00 00       	call   128aa <do_handler_Debug>
   1007a:	83 c4 04             	add    $0x4,%esp
   1007d:	0f a9                	pop    %gs
   1007f:	0f a1                	pop    %fs
   10081:	07                   	pop    %es
   10082:	1f                   	pop    %ds
   10083:	61                   	popa   
   10084:	83 c4 08             	add    $0x8,%esp
   10087:	cf                   	iret   

00010088 <exception_handler_NMI>:
exception_handler NMI, 2, 0
   10088:	6a 00                	push   $0x0
   1008a:	6a 02                	push   $0x2
   1008c:	60                   	pusha  
   1008d:	1e                   	push   %ds
   1008e:	06                   	push   %es
   1008f:	0f a0                	push   %fs
   10091:	0f a8                	push   %gs
   10093:	54                   	push   %esp
   10094:	e8 2d 28 00 00       	call   128c6 <do_handler_NMI>
   10099:	83 c4 04             	add    $0x4,%esp
   1009c:	0f a9                	pop    %gs
   1009e:	0f a1                	pop    %fs
   100a0:	07                   	pop    %es
   100a1:	1f                   	pop    %ds
   100a2:	61                   	popa   
   100a3:	83 c4 08             	add    $0x8,%esp
   100a6:	cf                   	iret   

000100a7 <exception_handler_breakpoint>:
exception_handler breakpoint, 3, 0
   100a7:	6a 00                	push   $0x0
   100a9:	6a 03                	push   $0x3
   100ab:	60                   	pusha  
   100ac:	1e                   	push   %ds
   100ad:	06                   	push   %es
   100ae:	0f a0                	push   %fs
   100b0:	0f a8                	push   %gs
   100b2:	54                   	push   %esp
   100b3:	e8 2a 28 00 00       	call   128e2 <do_handler_breakpoint>
   100b8:	83 c4 04             	add    $0x4,%esp
   100bb:	0f a9                	pop    %gs
   100bd:	0f a1                	pop    %fs
   100bf:	07                   	pop    %es
   100c0:	1f                   	pop    %ds
   100c1:	61                   	popa   
   100c2:	83 c4 08             	add    $0x8,%esp
   100c5:	cf                   	iret   

000100c6 <exception_handler_overflow>:
exception_handler overflow, 4, 0
   100c6:	6a 00                	push   $0x0
   100c8:	6a 04                	push   $0x4
   100ca:	60                   	pusha  
   100cb:	1e                   	push   %ds
   100cc:	06                   	push   %es
   100cd:	0f a0                	push   %fs
   100cf:	0f a8                	push   %gs
   100d1:	54                   	push   %esp
   100d2:	e8 27 28 00 00       	call   128fe <do_handler_overflow>
   100d7:	83 c4 04             	add    $0x4,%esp
   100da:	0f a9                	pop    %gs
   100dc:	0f a1                	pop    %fs
   100de:	07                   	pop    %es
   100df:	1f                   	pop    %ds
   100e0:	61                   	popa   
   100e1:	83 c4 08             	add    $0x8,%esp
   100e4:	cf                   	iret   

000100e5 <exception_handler_bound_range>:
exception_handler bound_range, 5, 0
   100e5:	6a 00                	push   $0x0
   100e7:	6a 05                	push   $0x5
   100e9:	60                   	pusha  
   100ea:	1e                   	push   %ds
   100eb:	06                   	push   %es
   100ec:	0f a0                	push   %fs
   100ee:	0f a8                	push   %gs
   100f0:	54                   	push   %esp
   100f1:	e8 24 28 00 00       	call   1291a <do_handler_bound_range>
   100f6:	83 c4 04             	add    $0x4,%esp
   100f9:	0f a9                	pop    %gs
   100fb:	0f a1                	pop    %fs
   100fd:	07                   	pop    %es
   100fe:	1f                   	pop    %ds
   100ff:	61                   	popa   
   10100:	83 c4 08             	add    $0x8,%esp
   10103:	cf                   	iret   

00010104 <exception_handler_invalid_opcode>:
exception_handler invalid_opcode, 6, 0
   10104:	6a 00                	push   $0x0
   10106:	6a 06                	push   $0x6
   10108:	60                   	pusha  
   10109:	1e                   	push   %ds
   1010a:	06                   	push   %es
   1010b:	0f a0                	push   %fs
   1010d:	0f a8                	push   %gs
   1010f:	54                   	push   %esp
   10110:	e8 21 28 00 00       	call   12936 <do_handler_invalid_opcode>
   10115:	83 c4 04             	add    $0x4,%esp
   10118:	0f a9                	pop    %gs
   1011a:	0f a1                	pop    %fs
   1011c:	07                   	pop    %es
   1011d:	1f                   	pop    %ds
   1011e:	61                   	popa   
   1011f:	83 c4 08             	add    $0x8,%esp
   10122:	cf                   	iret   

00010123 <exception_handler_device_unavailable>:
exception_handler device_unavailable, 7, 0
   10123:	6a 00                	push   $0x0
   10125:	6a 07                	push   $0x7
   10127:	60                   	pusha  
   10128:	1e                   	push   %ds
   10129:	06                   	push   %es
   1012a:	0f a0                	push   %fs
   1012c:	0f a8                	push   %gs
   1012e:	54                   	push   %esp
   1012f:	e8 1e 28 00 00       	call   12952 <do_handler_device_unavailable>
   10134:	83 c4 04             	add    $0x4,%esp
   10137:	0f a9                	pop    %gs
   10139:	0f a1                	pop    %fs
   1013b:	07                   	pop    %es
   1013c:	1f                   	pop    %ds
   1013d:	61                   	popa   
   1013e:	83 c4 08             	add    $0x8,%esp
   10141:	cf                   	iret   

00010142 <exception_handler_double_fault>:
exception_handler double_fault, 8, 1
   10142:	6a 08                	push   $0x8
   10144:	60                   	pusha  
   10145:	1e                   	push   %ds
   10146:	06                   	push   %es
   10147:	0f a0                	push   %fs
   10149:	0f a8                	push   %gs
   1014b:	54                   	push   %esp
   1014c:	e8 1d 28 00 00       	call   1296e <do_handler_double_fault>
   10151:	83 c4 04             	add    $0x4,%esp
   10154:	0f a9                	pop    %gs
   10156:	0f a1                	pop    %fs
   10158:	07                   	pop    %es
   10159:	1f                   	pop    %ds
   1015a:	61                   	popa   
   1015b:	83 c4 08             	add    $0x8,%esp
   1015e:	cf                   	iret   

0001015f <exception_handler_invalid_tss>:
exception_handler invalid_tss, 10, 1
   1015f:	6a 0a                	push   $0xa
   10161:	60                   	pusha  
   10162:	1e                   	push   %ds
   10163:	06                   	push   %es
   10164:	0f a0                	push   %fs
   10166:	0f a8                	push   %gs
   10168:	54                   	push   %esp
   10169:	e8 1c 28 00 00       	call   1298a <do_handler_invalid_tss>
   1016e:	83 c4 04             	add    $0x4,%esp
   10171:	0f a9                	pop    %gs
   10173:	0f a1                	pop    %fs
   10175:	07                   	pop    %es
   10176:	1f                   	pop    %ds
   10177:	61                   	popa   
   10178:	83 c4 08             	add    $0x8,%esp
   1017b:	cf                   	iret   

0001017c <exception_handler_segment_not_present>:
exception_handler segment_not_present, 11, 1
   1017c:	6a 0b                	push   $0xb
   1017e:	60                   	pusha  
   1017f:	1e                   	push   %ds
   10180:	06                   	push   %es
   10181:	0f a0                	push   %fs
   10183:	0f a8                	push   %gs
   10185:	54                   	push   %esp
   10186:	e8 1b 28 00 00       	call   129a6 <do_handler_segment_not_present>
   1018b:	83 c4 04             	add    $0x4,%esp
   1018e:	0f a9                	pop    %gs
   10190:	0f a1                	pop    %fs
   10192:	07                   	pop    %es
   10193:	1f                   	pop    %ds
   10194:	61                   	popa   
   10195:	83 c4 08             	add    $0x8,%esp
   10198:	cf                   	iret   

00010199 <exception_handler_stack_segment_fault>:
exception_handler stack_segment_fault, 12, 1
   10199:	6a 0c                	push   $0xc
   1019b:	60                   	pusha  
   1019c:	1e                   	push   %ds
   1019d:	06                   	push   %es
   1019e:	0f a0                	push   %fs
   101a0:	0f a8                	push   %gs
   101a2:	54                   	push   %esp
   101a3:	e8 1a 28 00 00       	call   129c2 <do_handler_stack_segment_fault>
   101a8:	83 c4 04             	add    $0x4,%esp
   101ab:	0f a9                	pop    %gs
   101ad:	0f a1                	pop    %fs
   101af:	07                   	pop    %es
   101b0:	1f                   	pop    %ds
   101b1:	61                   	popa   
   101b2:	83 c4 08             	add    $0x8,%esp
   101b5:	cf                   	iret   

000101b6 <exception_handler_general_protection>:
exception_handler general_protection, 13, 1
   101b6:	6a 0d                	push   $0xd
   101b8:	60                   	pusha  
   101b9:	1e                   	push   %ds
   101ba:	06                   	push   %es
   101bb:	0f a0                	push   %fs
   101bd:	0f a8                	push   %gs
   101bf:	54                   	push   %esp
   101c0:	e8 19 28 00 00       	call   129de <do_handler_general_protection>
   101c5:	83 c4 04             	add    $0x4,%esp
   101c8:	0f a9                	pop    %gs
   101ca:	0f a1                	pop    %fs
   101cc:	07                   	pop    %es
   101cd:	1f                   	pop    %ds
   101ce:	61                   	popa   
   101cf:	83 c4 08             	add    $0x8,%esp
   101d2:	cf                   	iret   

000101d3 <exception_handler_page_fault>:
exception_handler page_fault, 14, 1
   101d3:	6a 0e                	push   $0xe
   101d5:	60                   	pusha  
   101d6:	1e                   	push   %ds
   101d7:	06                   	push   %es
   101d8:	0f a0                	push   %fs
   101da:	0f a8                	push   %gs
   101dc:	54                   	push   %esp
   101dd:	e8 b1 28 00 00       	call   12a93 <do_handler_page_fault>
   101e2:	83 c4 04             	add    $0x4,%esp
   101e5:	0f a9                	pop    %gs
   101e7:	0f a1                	pop    %fs
   101e9:	07                   	pop    %es
   101ea:	1f                   	pop    %ds
   101eb:	61                   	popa   
   101ec:	83 c4 08             	add    $0x8,%esp
   101ef:	cf                   	iret   

000101f0 <exception_handler_fpu_error>:
exception_handler fpu_error, 16, 0
   101f0:	6a 00                	push   $0x0
   101f2:	6a 10                	push   $0x10
   101f4:	60                   	pusha  
   101f5:	1e                   	push   %ds
   101f6:	06                   	push   %es
   101f7:	0f a0                	push   %fs
   101f9:	0f a8                	push   %gs
   101fb:	54                   	push   %esp
   101fc:	e8 66 29 00 00       	call   12b67 <do_handler_fpu_error>
   10201:	83 c4 04             	add    $0x4,%esp
   10204:	0f a9                	pop    %gs
   10206:	0f a1                	pop    %fs
   10208:	07                   	pop    %es
   10209:	1f                   	pop    %ds
   1020a:	61                   	popa   
   1020b:	83 c4 08             	add    $0x8,%esp
   1020e:	cf                   	iret   

0001020f <exception_handler_alignment_check>:
exception_handler alignment_check, 17, 1
   1020f:	6a 11                	push   $0x11
   10211:	60                   	pusha  
   10212:	1e                   	push   %ds
   10213:	06                   	push   %es
   10214:	0f a0                	push   %fs
   10216:	0f a8                	push   %gs
   10218:	54                   	push   %esp
   10219:	e8 65 29 00 00       	call   12b83 <do_handler_alignment_check>
   1021e:	83 c4 04             	add    $0x4,%esp
   10221:	0f a9                	pop    %gs
   10223:	0f a1                	pop    %fs
   10225:	07                   	pop    %es
   10226:	1f                   	pop    %ds
   10227:	61                   	popa   
   10228:	83 c4 08             	add    $0x8,%esp
   1022b:	cf                   	iret   

0001022c <exception_handler_machine_check>:
exception_handler machine_check, 18, 0
   1022c:	6a 00                	push   $0x0
   1022e:	6a 12                	push   $0x12
   10230:	60                   	pusha  
   10231:	1e                   	push   %ds
   10232:	06                   	push   %es
   10233:	0f a0                	push   %fs
   10235:	0f a8                	push   %gs
   10237:	54                   	push   %esp
   10238:	e8 62 29 00 00       	call   12b9f <do_handler_machine_check>
   1023d:	83 c4 04             	add    $0x4,%esp
   10240:	0f a9                	pop    %gs
   10242:	0f a1                	pop    %fs
   10244:	07                   	pop    %es
   10245:	1f                   	pop    %ds
   10246:	61                   	popa   
   10247:	83 c4 08             	add    $0x8,%esp
   1024a:	cf                   	iret   

0001024b <exception_handler_smd_exception>:
exception_handler smd_exception, 19, 0
   1024b:	6a 00                	push   $0x0
   1024d:	6a 13                	push   $0x13
   1024f:	60                   	pusha  
   10250:	1e                   	push   %ds
   10251:	06                   	push   %es
   10252:	0f a0                	push   %fs
   10254:	0f a8                	push   %gs
   10256:	54                   	push   %esp
   10257:	e8 5f 29 00 00       	call   12bbb <do_handler_smd_exception>
   1025c:	83 c4 04             	add    $0x4,%esp
   1025f:	0f a9                	pop    %gs
   10261:	0f a1                	pop    %fs
   10263:	07                   	pop    %es
   10264:	1f                   	pop    %ds
   10265:	61                   	popa   
   10266:	83 c4 08             	add    $0x8,%esp
   10269:	cf                   	iret   

0001026a <exception_handler_virtual_exception>:
exception_handler virtual_exception, 20, 0
   1026a:	6a 00                	push   $0x0
   1026c:	6a 14                	push   $0x14
   1026e:	60                   	pusha  
   1026f:	1e                   	push   %ds
   10270:	06                   	push   %es
   10271:	0f a0                	push   %fs
   10273:	0f a8                	push   %gs
   10275:	54                   	push   %esp
   10276:	e8 5c 29 00 00       	call   12bd7 <do_handler_virtual_exception>
   1027b:	83 c4 04             	add    $0x4,%esp
   1027e:	0f a9                	pop    %gs
   10280:	0f a1                	pop    %fs
   10282:	07                   	pop    %es
   10283:	1f                   	pop    %ds
   10284:	61                   	popa   
   10285:	83 c4 08             	add    $0x8,%esp
   10288:	cf                   	iret   

00010289 <exception_handler_time>:
exception_handler time,0x20,0
   10289:	6a 00                	push   $0x0
   1028b:	6a 20                	push   $0x20
   1028d:	60                   	pusha  
   1028e:	1e                   	push   %ds
   1028f:	06                   	push   %es
   10290:	0f a0                	push   %fs
   10292:	0f a8                	push   %gs
   10294:	54                   	push   %esp
   10295:	e8 94 3a 00 00       	call   13d2e <do_handler_time>
   1029a:	83 c4 04             	add    $0x4,%esp
   1029d:	0f a9                	pop    %gs
   1029f:	0f a1                	pop    %fs
   102a1:	07                   	pop    %es
   102a2:	1f                   	pop    %ds
   102a3:	61                   	popa   
   102a4:	83 c4 08             	add    $0x8,%esp
   102a7:	cf                   	iret   

000102a8 <exception_handler_kbd>:
exception_handler kbd,0x21,0
   102a8:	6a 00                	push   $0x0
   102aa:	6a 21                	push   $0x21
   102ac:	60                   	pusha  
   102ad:	1e                   	push   %ds
   102ae:	06                   	push   %es
   102af:	0f a0                	push   %fs
   102b1:	0f a8                	push   %gs
   102b3:	54                   	push   %esp
   102b4:	e8 96 39 00 00       	call   13c4f <do_handler_kbd>
   102b9:	83 c4 04             	add    $0x4,%esp
   102bc:	0f a9                	pop    %gs
   102be:	0f a1                	pop    %fs
   102c0:	07                   	pop    %es
   102c1:	1f                   	pop    %ds
   102c2:	61                   	popa   
   102c3:	83 c4 08             	add    $0x8,%esp
   102c6:	cf                   	iret   

000102c7 <exception_handler_syscall>:

    .global exception_handler_syscall
    .extern do_handler_syscall
exception_handler_syscall:
    pusha
   102c7:	60                   	pusha  
    push %ds
   102c8:	1e                   	push   %ds
    push %es
   102c9:	06                   	push   %es
    push %fs
   102ca:	0f a0                	push   %fs
    push %gs
   102cc:	0f a8                	push   %gs
    pushf
   102ce:	9c                   	pushf  

    mov %esp,%eax
   102cf:	89 e0                	mov    %esp,%eax
    push %eax
   102d1:	50                   	push   %eax

    call do_handler_syscall
   102d2:	e8 5b 0b 00 00       	call   10e32 <do_handler_syscall>
    add $4,%esp
   102d7:	83 c4 04             	add    $0x4,%esp
    
    popf
   102da:	9d                   	popf   
    pop %gs
   102db:	0f a9                	pop    %gs
    pop %fs
   102dd:	0f a1                	pop    %fs
    pop %es
   102df:	07                   	pop    %es
    pop %ds
   102e0:	1f                   	pop    %ds
    popa
   102e1:	61                   	popa   

   102e2:	ca 14 00             	lret   $0x14

000102e5 <read_cr0>:
        :[g]"m"(gdt)
    );
}

// 设置读cr0寄存器
static inline uint32_t read_cr0(void){
   102e5:	55                   	push   %ebp
   102e6:	89 e5                	mov    %esp,%ebp
   102e8:	83 ec 10             	sub    $0x10,%esp
    uint32_t cr0;
    __asm__ __volatile__(
   102eb:	0f 20 c0             	mov    %cr0,%eax
   102ee:	89 45 fc             	mov    %eax,-0x4(%ebp)
        "mov %%cr0, %[v]"
        :[v]"=r"(cr0)
        :
    );
    return cr0;
   102f1:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   102f4:	c9                   	leave  
   102f5:	c3                   	ret    

000102f6 <write_cr0>:

// 设置写cr0寄存器
static inline void write_cr0(uint32_t v){
   102f6:	55                   	push   %ebp
   102f7:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   102f9:	8b 45 08             	mov    0x8(%ebp),%eax
   102fc:	0f 22 c0             	mov    %eax,%cr0
        "mov %[v],%%cr0"
        :
        :[v]"r"(v)
    );
}
   102ff:	90                   	nop
   10300:	5d                   	pop    %ebp
   10301:	c3                   	ret    

00010302 <write_cr3>:
        :
        :"a"(eflags)
    );
}

static inline void write_cr3(uint32_t v){
   10302:	55                   	push   %ebp
   10303:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   10305:	8b 45 08             	mov    0x8(%ebp),%eax
   10308:	0f 22 d8             	mov    %eax,%cr3
        "mov %[v],%%cr3"
        :
        :[v]"r"(v)
    );
}
   1030b:	90                   	nop
   1030c:	5d                   	pop    %ebp
   1030d:	c3                   	ret    

0001030e <write_cr4>:
        :
    );
    return cr3;
}

static inline void write_cr4(uint32_t v){
   1030e:	55                   	push   %ebp
   1030f:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   10311:	8b 45 08             	mov    0x8(%ebp),%eax
   10314:	0f 22 e0             	mov    %eax,%cr4
        "mov %[v],%%cr4"
        :
        :[v]"r"(v)
    );
}
   10317:	90                   	nop
   10318:	5d                   	pop    %ebp
   10319:	c3                   	ret    

0001031a <read_cr4>:

static inline uint32_t read_cr4(void){
   1031a:	55                   	push   %ebp
   1031b:	89 e5                	mov    %esp,%ebp
   1031d:	83 ec 10             	sub    $0x10,%esp
    uint32_t cr4;
    __asm__ __volatile__(
   10320:	0f 20 e0             	mov    %cr4,%eax
   10323:	89 45 fc             	mov    %eax,-0x4(%ebp)
        "mov %%cr4,%[v]"
        :[v]"=r"(cr4)
        :
    );
    return cr4;
   10326:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   10329:	c9                   	leave  
   1032a:	c3                   	ret    

0001032b <down2>:
#include <stdarg.h>
#include "comm/types.h"
#include "tools/log.h"
#include "comm/cpu_instr.h"

static inline uint32_t down2(uint32_t size,uint32_t bound){
   1032b:	55                   	push   %ebp
   1032c:	89 e5                	mov    %esp,%ebp
    return size & ~(bound-1);
   1032e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10331:	f7 d8                	neg    %eax
   10333:	23 45 08             	and    0x8(%ebp),%eax
}
   10336:	5d                   	pop    %ebp
   10337:	c3                   	ret    

00010338 <up2>:

static inline uint32_t up2(uint32_t size,uint32_t bound){
   10338:	55                   	push   %ebp
   10339:	89 e5                	mov    %esp,%ebp
    return (size+bound-1) & ~(bound-1);
   1033b:	8b 55 08             	mov    0x8(%ebp),%edx
   1033e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10341:	01 d0                	add    %edx,%eax
   10343:	8d 50 ff             	lea    -0x1(%eax),%edx
   10346:	8b 45 0c             	mov    0xc(%ebp),%eax
   10349:	f7 d8                	neg    %eax
   1034b:	21 d0                	and    %edx,%eax
}
   1034d:	5d                   	pop    %ebp
   1034e:	c3                   	ret    

0001034f <mmu_set_page_dir>:
        uint32_t phy_pt_addr : 20;
    };

}pte_t;

static inline void mmu_set_page_dir(uint32_t paddr){
   1034f:	55                   	push   %ebp
   10350:	89 e5                	mov    %esp,%ebp
   10352:	83 ec 10             	sub    $0x10,%esp
    uint32_t cr4=read_cr4();
   10355:	e8 c0 ff ff ff       	call   1031a <read_cr4>
   1035a:	89 45 fc             	mov    %eax,-0x4(%ebp)
	write_cr4(cr4|CR4_PSE);
   1035d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10360:	83 c8 10             	or     $0x10,%eax
   10363:	50                   	push   %eax
   10364:	e8 a5 ff ff ff       	call   1030e <write_cr4>
   10369:	83 c4 04             	add    $0x4,%esp
	write_cr3(paddr);
   1036c:	ff 75 08             	pushl  0x8(%ebp)
   1036f:	e8 8e ff ff ff       	call   10302 <write_cr3>
   10374:	83 c4 04             	add    $0x4,%esp
	write_cr0(read_cr0()|CR0_PG);
   10377:	e8 69 ff ff ff       	call   102e5 <read_cr0>
   1037c:	0d 00 00 00 80       	or     $0x80000000,%eax
   10381:	50                   	push   %eax
   10382:	e8 6f ff ff ff       	call   102f6 <write_cr0>
   10387:	83 c4 04             	add    $0x4,%esp
}
   1038a:	90                   	nop
   1038b:	c9                   	leave  
   1038c:	c3                   	ret    

0001038d <pde_index>:

static inline uint32_t pde_index(uint32_t vaddr){
   1038d:	55                   	push   %ebp
   1038e:	89 e5                	mov    %esp,%ebp
    return vaddr >> 22;
   10390:	8b 45 08             	mov    0x8(%ebp),%eax
   10393:	c1 e8 16             	shr    $0x16,%eax
}
   10396:	5d                   	pop    %ebp
   10397:	c3                   	ret    

00010398 <pte_index>:

static inline uint32_t pte_index(uint32_t vaddr){
   10398:	55                   	push   %ebp
   10399:	89 e5                	mov    %esp,%ebp
    return (vaddr >> 12)  & 0x3FF;
   1039b:	8b 45 08             	mov    0x8(%ebp),%eax
   1039e:	c1 e8 0c             	shr    $0xc,%eax
   103a1:	25 ff 03 00 00       	and    $0x3ff,%eax
}
   103a6:	5d                   	pop    %ebp
   103a7:	c3                   	ret    

000103a8 <pde_paddr>:

static inline uint32_t pde_paddr(pde_t* pde){
   103a8:	55                   	push   %ebp
   103a9:	89 e5                	mov    %esp,%ebp
    return pde->phy_pt_addr << 12;
   103ab:	8b 45 08             	mov    0x8(%ebp),%eax
   103ae:	8b 00                	mov    (%eax),%eax
   103b0:	c1 e8 0c             	shr    $0xc,%eax
   103b3:	c1 e0 0c             	shl    $0xc,%eax
}
   103b6:	5d                   	pop    %ebp
   103b7:	c3                   	ret    

000103b8 <pte_paddr>:

static inline uint32_t pte_paddr(pte_t* pte){
   103b8:	55                   	push   %ebp
   103b9:	89 e5                	mov    %esp,%ebp
    return pte->phy_pt_addr << 12;
   103bb:	8b 45 08             	mov    0x8(%ebp),%eax
   103be:	8b 00                	mov    (%eax),%eax
   103c0:	c1 e8 0c             	shr    $0xc,%eax
   103c3:	c1 e0 0c             	shl    $0xc,%eax
}
   103c6:	5d                   	pop    %ebp
   103c7:	c3                   	ret    

000103c8 <get_pte_perm>:

static inline uint32_t get_pte_perm(pte_t* pte){
   103c8:	55                   	push   %ebp
   103c9:	89 e5                	mov    %esp,%ebp
    return (pte->v & 0x1FF);
   103cb:	8b 45 08             	mov    0x8(%ebp),%eax
   103ce:	8b 00                	mov    (%eax),%eax
   103d0:	25 ff 01 00 00       	and    $0x1ff,%eax
}
   103d5:	5d                   	pop    %ebp
   103d6:	c3                   	ret    

000103d7 <addr_alloc_init>:

static addr_alloc_t paddr_alloc;
static pde_t kernel_page_dir[PDE_CNT] __attribute__((aligned(MEM_PAGE_SIZE)));

static void addr_alloc_init(addr_alloc_t* alloc,uint8_t* bits,
    uint32_t start,uint32_t size,uint32_t page_size){
   103d7:	55                   	push   %ebp
   103d8:	89 e5                	mov    %esp,%ebp
   103da:	83 ec 08             	sub    $0x8,%esp
        mutex_init(&alloc->mutex);
   103dd:	8b 45 08             	mov    0x8(%ebp),%eax
   103e0:	83 ec 0c             	sub    $0xc,%esp
   103e3:	50                   	push   %eax
   103e4:	e8 7e 41 00 00       	call   14567 <mutex_init>
   103e9:	83 c4 10             	add    $0x10,%esp
        alloc->start=start;
   103ec:	8b 45 08             	mov    0x8(%ebp),%eax
   103ef:	8b 55 10             	mov    0x10(%ebp),%edx
   103f2:	89 50 1c             	mov    %edx,0x1c(%eax)
        alloc->size=size;
   103f5:	8b 45 08             	mov    0x8(%ebp),%eax
   103f8:	8b 55 14             	mov    0x14(%ebp),%edx
   103fb:	89 50 20             	mov    %edx,0x20(%eax)
        alloc->page_size=page_size;
   103fe:	8b 45 08             	mov    0x8(%ebp),%eax
   10401:	8b 55 18             	mov    0x18(%ebp),%edx
   10404:	89 50 24             	mov    %edx,0x24(%eax)
        bitmap_init(&alloc->bitmap,bits,alloc->size/page_size,0);
   10407:	8b 45 08             	mov    0x8(%ebp),%eax
   1040a:	8b 40 20             	mov    0x20(%eax),%eax
   1040d:	ba 00 00 00 00       	mov    $0x0,%edx
   10412:	f7 75 18             	divl   0x18(%ebp)
   10415:	89 c2                	mov    %eax,%edx
   10417:	8b 45 08             	mov    0x8(%ebp),%eax
   1041a:	83 c0 14             	add    $0x14,%eax
   1041d:	6a 00                	push   $0x0
   1041f:	52                   	push   %edx
   10420:	ff 75 0c             	pushl  0xc(%ebp)
   10423:	50                   	push   %eax
   10424:	e8 19 44 00 00       	call   14842 <bitmap_init>
   10429:	83 c4 10             	add    $0x10,%esp
}
   1042c:	90                   	nop
   1042d:	c9                   	leave  
   1042e:	c3                   	ret    

0001042f <addr_alloc_page>:

static uint32_t addr_alloc_page(addr_alloc_t* alloc,int page_count){
   1042f:	55                   	push   %ebp
   10430:	89 e5                	mov    %esp,%ebp
   10432:	83 ec 18             	sub    $0x18,%esp
    uint32_t addr=0;
   10435:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    mutex_lock(&alloc->mutex);
   1043c:	8b 45 08             	mov    0x8(%ebp),%eax
   1043f:	83 ec 0c             	sub    $0xc,%esp
   10442:	50                   	push   %eax
   10443:	e8 4d 41 00 00       	call   14595 <mutex_lock>
   10448:	83 c4 10             	add    $0x10,%esp
    int page_index=bitmap_alloc_nbits(&alloc->bitmap,0,page_count);
   1044b:	8b 45 08             	mov    0x8(%ebp),%eax
   1044e:	83 c0 14             	add    $0x14,%eax
   10451:	83 ec 04             	sub    $0x4,%esp
   10454:	ff 75 0c             	pushl  0xc(%ebp)
   10457:	6a 00                	push   $0x0
   10459:	50                   	push   %eax
   1045a:	e8 8b 45 00 00       	call   149ea <bitmap_alloc_nbits>
   1045f:	83 c4 10             	add    $0x10,%esp
   10462:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(page_index>=0){
   10465:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10469:	78 17                	js     10482 <addr_alloc_page+0x53>
        addr=alloc->start+page_index*alloc->page_size;
   1046b:	8b 45 08             	mov    0x8(%ebp),%eax
   1046e:	8b 50 1c             	mov    0x1c(%eax),%edx
   10471:	8b 45 08             	mov    0x8(%ebp),%eax
   10474:	8b 48 24             	mov    0x24(%eax),%ecx
   10477:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1047a:	0f af c1             	imul   %ecx,%eax
   1047d:	01 d0                	add    %edx,%eax
   1047f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    mutex_unlock(&alloc->mutex);
   10482:	8b 45 08             	mov    0x8(%ebp),%eax
   10485:	83 ec 0c             	sub    $0xc,%esp
   10488:	50                   	push   %eax
   10489:	e8 96 41 00 00       	call   14624 <mutex_unlock>
   1048e:	83 c4 10             	add    $0x10,%esp
    return addr;
   10491:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10494:	c9                   	leave  
   10495:	c3                   	ret    

00010496 <addr_free_page>:


static void addr_free_page(addr_alloc_t* alloc,uint32_t addr,int page_count){
   10496:	55                   	push   %ebp
   10497:	89 e5                	mov    %esp,%ebp
   10499:	53                   	push   %ebx
   1049a:	83 ec 14             	sub    $0x14,%esp
    mutex_lock(&alloc->mutex);
   1049d:	8b 45 08             	mov    0x8(%ebp),%eax
   104a0:	83 ec 0c             	sub    $0xc,%esp
   104a3:	50                   	push   %eax
   104a4:	e8 ec 40 00 00       	call   14595 <mutex_lock>
   104a9:	83 c4 10             	add    $0x10,%esp
    uint32_t pg_index=(addr-alloc->start)/alloc->page_size;
   104ac:	8b 45 08             	mov    0x8(%ebp),%eax
   104af:	8b 40 1c             	mov    0x1c(%eax),%eax
   104b2:	8b 55 0c             	mov    0xc(%ebp),%edx
   104b5:	89 d1                	mov    %edx,%ecx
   104b7:	29 c1                	sub    %eax,%ecx
   104b9:	8b 45 08             	mov    0x8(%ebp),%eax
   104bc:	8b 58 24             	mov    0x24(%eax),%ebx
   104bf:	89 c8                	mov    %ecx,%eax
   104c1:	ba 00 00 00 00       	mov    $0x0,%edx
   104c6:	f7 f3                	div    %ebx
   104c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    bitmap_set_bit(&alloc->bitmap,pg_index,page_count,0);
   104cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   104ce:	8b 55 08             	mov    0x8(%ebp),%edx
   104d1:	83 c2 14             	add    $0x14,%edx
   104d4:	6a 00                	push   $0x0
   104d6:	ff 75 10             	pushl  0x10(%ebp)
   104d9:	50                   	push   %eax
   104da:	52                   	push   %edx
   104db:	e8 04 44 00 00       	call   148e4 <bitmap_set_bit>
   104e0:	83 c4 10             	add    $0x10,%esp
    mutex_unlock(&alloc->mutex);
   104e3:	8b 45 08             	mov    0x8(%ebp),%eax
   104e6:	83 ec 0c             	sub    $0xc,%esp
   104e9:	50                   	push   %eax
   104ea:	e8 35 41 00 00       	call   14624 <mutex_unlock>
   104ef:	83 c4 10             	add    $0x10,%esp
}
   104f2:	90                   	nop
   104f3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   104f6:	c9                   	leave  
   104f7:	c3                   	ret    

000104f8 <total_mem_size>:

static uint32_t total_mem_size(boot_info_t* boot_info){
   104f8:	55                   	push   %ebp
   104f9:	89 e5                	mov    %esp,%ebp
   104fb:	83 ec 10             	sub    $0x10,%esp
    uint32_t mem_size=0;
   104fe:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    for(int i=0;i<boot_info->ram_region_count;i++){
   10505:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1050c:	eb 11                	jmp    1051f <total_mem_size+0x27>
        mem_size+=boot_info->ram_region_cfg[i].size;
   1050e:	8b 45 08             	mov    0x8(%ebp),%eax
   10511:	8b 55 f8             	mov    -0x8(%ebp),%edx
   10514:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
   10518:	01 45 fc             	add    %eax,-0x4(%ebp)
    for(int i=0;i<boot_info->ram_region_count;i++){
   1051b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   1051f:	8b 45 08             	mov    0x8(%ebp),%eax
   10522:	8b 40 50             	mov    0x50(%eax),%eax
   10525:	39 45 f8             	cmp    %eax,-0x8(%ebp)
   10528:	7c e4                	jl     1050e <total_mem_size+0x16>
    }
    return mem_size;
   1052a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   1052d:	c9                   	leave  
   1052e:	c3                   	ret    

0001052f <find_pte>:

pte_t* find_pte(pde_t*page_dir,uint32_t vaddr,int alloc){
   1052f:	55                   	push   %ebp
   10530:	89 e5                	mov    %esp,%ebp
   10532:	83 ec 18             	sub    $0x18,%esp
    pte_t* page_table;
    pde_t* pde=page_dir+pde_index(vaddr);
   10535:	ff 75 0c             	pushl  0xc(%ebp)
   10538:	e8 50 fe ff ff       	call   1038d <pde_index>
   1053d:	83 c4 04             	add    $0x4,%esp
   10540:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10547:	8b 45 08             	mov    0x8(%ebp),%eax
   1054a:	01 d0                	add    %edx,%eax
   1054c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(pde->present){
   1054f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10552:	0f b6 00             	movzbl (%eax),%eax
   10555:	83 e0 01             	and    $0x1,%eax
   10558:	84 c0                	test   %al,%al
   1055a:	74 10                	je     1056c <find_pte+0x3d>
        page_table=(pte_t*)pde_paddr(pde);
   1055c:	ff 75 f0             	pushl  -0x10(%ebp)
   1055f:	e8 44 fe ff ff       	call   103a8 <pde_paddr>
   10564:	83 c4 04             	add    $0x4,%esp
   10567:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1056a:	eb 57                	jmp    105c3 <find_pte+0x94>
    }
    else{
        if(alloc==0){
   1056c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   10570:	75 07                	jne    10579 <find_pte+0x4a>
            return (pte_t*)0;
   10572:	b8 00 00 00 00       	mov    $0x0,%eax
   10577:	eb 64                	jmp    105dd <find_pte+0xae>
        }
        uint32_t pg_paddr=addr_alloc_page(&paddr_alloc,1);
   10579:	83 ec 08             	sub    $0x8,%esp
   1057c:	6a 01                	push   $0x1
   1057e:	68 00 70 01 00       	push   $0x17000
   10583:	e8 a7 fe ff ff       	call   1042f <addr_alloc_page>
   10588:	83 c4 10             	add    $0x10,%esp
   1058b:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(pg_paddr==0) return (pte_t*)0;
   1058e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10592:	75 07                	jne    1059b <find_pte+0x6c>
   10594:	b8 00 00 00 00       	mov    $0x0,%eax
   10599:	eb 42                	jmp    105dd <find_pte+0xae>
        pde->v=pg_paddr | PTE_P | PDE_W | PDE_U;
   1059b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1059e:	83 c8 07             	or     $0x7,%eax
   105a1:	89 c2                	mov    %eax,%edx
   105a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   105a6:	89 10                	mov    %edx,(%eax)
        page_table=(pte_t*)pg_paddr;
   105a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   105ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
        kernel_memset(page_table,0,MEM_PAGE_SIZE);
   105ae:	83 ec 04             	sub    $0x4,%esp
   105b1:	68 00 10 00 00       	push   $0x1000
   105b6:	6a 00                	push   $0x0
   105b8:	ff 75 f4             	pushl  -0xc(%ebp)
   105bb:	e8 9f 46 00 00       	call   14c5f <kernel_memset>
   105c0:	83 c4 10             	add    $0x10,%esp
    }

    return page_table+pte_index(vaddr);
   105c3:	83 ec 0c             	sub    $0xc,%esp
   105c6:	ff 75 0c             	pushl  0xc(%ebp)
   105c9:	e8 ca fd ff ff       	call   10398 <pte_index>
   105ce:	83 c4 10             	add    $0x10,%esp
   105d1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   105d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   105db:	01 d0                	add    %edx,%eax
}
   105dd:	c9                   	leave  
   105de:	c3                   	ret    

000105df <memory_create_map>:

int memory_create_map(pde_t* page_dir,uint32_t vaddr,uint32_t paddr,int count,uint32_t perm){
   105df:	55                   	push   %ebp
   105e0:	89 e5                	mov    %esp,%ebp
   105e2:	83 ec 18             	sub    $0x18,%esp
    for(int i=0;i<count;i++){
   105e5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   105ec:	eb 7b                	jmp    10669 <memory_create_map+0x8a>
        pte_t* pte=find_pte(page_dir,vaddr,1);
   105ee:	83 ec 04             	sub    $0x4,%esp
   105f1:	6a 01                	push   $0x1
   105f3:	ff 75 0c             	pushl  0xc(%ebp)
   105f6:	ff 75 08             	pushl  0x8(%ebp)
   105f9:	e8 31 ff ff ff       	call   1052f <find_pte>
   105fe:	83 c4 10             	add    $0x10,%esp
   10601:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(pte==(pte_t*)0){
   10604:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10608:	75 17                	jne    10621 <memory_create_map+0x42>
            log_printf("create pte failed.pte==0");
   1060a:	83 ec 0c             	sub    $0xc,%esp
   1060d:	68 40 53 01 00       	push   $0x15340
   10612:	e8 6b 4c 00 00       	call   15282 <log_printf>
   10617:	83 c4 10             	add    $0x10,%esp
            return -1;
   1061a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1061f:	eb 59                	jmp    1067a <memory_create_map+0x9b>
        }
        ASSERT(pte->present==0);
   10621:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10624:	0f b6 00             	movzbl (%eax),%eax
   10627:	83 e0 01             	and    $0x1,%eax
   1062a:	84 c0                	test   %al,%al
   1062c:	74 19                	je     10647 <memory_create_map+0x68>
   1062e:	68 59 53 01 00       	push   $0x15359
   10633:	68 6c 54 01 00       	push   $0x1546c
   10638:	6a 48                	push   $0x48
   1063a:	68 6c 53 01 00       	push   $0x1536c
   1063f:	e8 6e 49 00 00       	call   14fb2 <panic>
   10644:	83 c4 10             	add    $0x10,%esp
        pte->v=paddr | perm | PTE_P;
   10647:	8b 45 10             	mov    0x10(%ebp),%eax
   1064a:	0b 45 18             	or     0x18(%ebp),%eax
   1064d:	83 c8 01             	or     $0x1,%eax
   10650:	89 c2                	mov    %eax,%edx
   10652:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10655:	89 10                	mov    %edx,(%eax)
        vaddr+=MEM_PAGE_SIZE;
   10657:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
        paddr+=MEM_PAGE_SIZE;
   1065e:	81 45 10 00 10 00 00 	addl   $0x1000,0x10(%ebp)
    for(int i=0;i<count;i++){
   10665:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10669:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1066c:	3b 45 14             	cmp    0x14(%ebp),%eax
   1066f:	0f 8c 79 ff ff ff    	jl     105ee <memory_create_map+0xf>
    }
    return 0;
   10675:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1067a:	c9                   	leave  
   1067b:	c3                   	ret    

0001067c <create_kernel_table>:

void create_kernel_table(void){
   1067c:	55                   	push   %ebp
   1067d:	89 e5                	mov    %esp,%ebp
   1067f:	83 ec 28             	sub    $0x28,%esp
        {s_data,(void*)(MEM_EBDA_START-1),s_data,PTE_W},
        {(void*)CONSOLE_DISP_ADDR,(void*)CONSOLE_DISP_END,(void*)CONSOLE_DISP_ADDR, PTE_W},
        {(void*)MEM_EXT_START,(void*)MEM_EXT_END,(void*)MEM_EXT_START,PTE_W},
    };

    for(int i=0;i<sizeof(kernel_map)/sizeof(memory_map_t);i++){
   10682:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   10689:	e9 86 00 00 00       	jmp    10714 <create_kernel_table+0x98>
        memory_map_t* map=kernel_map+i;
   1068e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10691:	c1 e0 04             	shl    $0x4,%eax
   10694:	05 00 60 01 00       	add    $0x16000,%eax
   10699:	89 45 f0             	mov    %eax,-0x10(%ebp)

        uint32_t vstart=down2((uint32_t)map->vstart,MEM_PAGE_SIZE);
   1069c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1069f:	8b 00                	mov    (%eax),%eax
   106a1:	68 00 10 00 00       	push   $0x1000
   106a6:	50                   	push   %eax
   106a7:	e8 7f fc ff ff       	call   1032b <down2>
   106ac:	83 c4 08             	add    $0x8,%esp
   106af:	89 45 ec             	mov    %eax,-0x14(%ebp)
        uint32_t vend=up2((uint32_t)map->vend,MEM_PAGE_SIZE);
   106b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   106b5:	8b 40 04             	mov    0x4(%eax),%eax
   106b8:	68 00 10 00 00       	push   $0x1000
   106bd:	50                   	push   %eax
   106be:	e8 75 fc ff ff       	call   10338 <up2>
   106c3:	83 c4 08             	add    $0x8,%esp
   106c6:	89 45 e8             	mov    %eax,-0x18(%ebp)
        uint32_t paddr=down2((uint32_t)map->pstart,MEM_PAGE_SIZE);
   106c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   106cc:	8b 40 08             	mov    0x8(%eax),%eax
   106cf:	68 00 10 00 00       	push   $0x1000
   106d4:	50                   	push   %eax
   106d5:	e8 51 fc ff ff       	call   1032b <down2>
   106da:	83 c4 08             	add    $0x8,%esp
   106dd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        int page_count=(vend-vstart) / MEM_PAGE_SIZE;
   106e0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   106e3:	2b 45 ec             	sub    -0x14(%ebp),%eax
   106e6:	c1 e8 0c             	shr    $0xc,%eax
   106e9:	89 45 e0             	mov    %eax,-0x20(%ebp)
        
        
        memory_create_map(kernel_page_dir,vstart,(uint32_t)map->pstart,page_count,map->perm);
   106ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
   106ef:	8b 40 0c             	mov    0xc(%eax),%eax
   106f2:	8b 55 f0             	mov    -0x10(%ebp),%edx
   106f5:	8b 52 08             	mov    0x8(%edx),%edx
   106f8:	83 ec 0c             	sub    $0xc,%esp
   106fb:	50                   	push   %eax
   106fc:	ff 75 e0             	pushl  -0x20(%ebp)
   106ff:	52                   	push   %edx
   10700:	ff 75 ec             	pushl  -0x14(%ebp)
   10703:	68 00 80 01 00       	push   $0x18000
   10708:	e8 d2 fe ff ff       	call   105df <memory_create_map>
   1070d:	83 c4 20             	add    $0x20,%esp
    for(int i=0;i<sizeof(kernel_map)/sizeof(memory_map_t);i++){
   10710:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10714:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10717:	83 f8 04             	cmp    $0x4,%eax
   1071a:	0f 86 6e ff ff ff    	jbe    1068e <create_kernel_table+0x12>
    }
}
   10720:	90                   	nop
   10721:	c9                   	leave  
   10722:	c3                   	ret    

00010723 <memory_init>:

void memory_init(boot_info_t* boot_info){
   10723:	55                   	push   %ebp
   10724:	89 e5                	mov    %esp,%ebp
   10726:	83 ec 18             	sub    $0x18,%esp
   extern uint8_t* mem_free_start;
   uint8_t* mem_free=(uint8_t*)&mem_free_start;
   10729:	c7 45 f4 c4 b6 06 00 	movl   $0x6b6c4,-0xc(%ebp)
   uint32_t mem_up1MB_free=total_mem_size(boot_info)-MEM_EXT_START;
   10730:	ff 75 08             	pushl  0x8(%ebp)
   10733:	e8 c0 fd ff ff       	call   104f8 <total_mem_size>
   10738:	83 c4 04             	add    $0x4,%esp
   1073b:	2d 00 00 10 00       	sub    $0x100000,%eax
   10740:	89 45 f0             	mov    %eax,-0x10(%ebp)
   mem_up1MB_free=down2(mem_up1MB_free,MEM_PAGE_SIZE);
   10743:	68 00 10 00 00       	push   $0x1000
   10748:	ff 75 f0             	pushl  -0x10(%ebp)
   1074b:	e8 db fb ff ff       	call   1032b <down2>
   10750:	83 c4 08             	add    $0x8,%esp
   10753:	89 45 f0             	mov    %eax,-0x10(%ebp)
   addr_alloc_init(&paddr_alloc,mem_free,MEM_EXT_START,mem_up1MB_free,MEM_PAGE_SIZE);
   10756:	83 ec 0c             	sub    $0xc,%esp
   10759:	68 00 10 00 00       	push   $0x1000
   1075e:	ff 75 f0             	pushl  -0x10(%ebp)
   10761:	68 00 00 10 00       	push   $0x100000
   10766:	ff 75 f4             	pushl  -0xc(%ebp)
   10769:	68 00 70 01 00       	push   $0x17000
   1076e:	e8 64 fc ff ff       	call   103d7 <addr_alloc_init>
   10773:	83 c4 20             	add    $0x20,%esp
   mem_free+=bitmap_byte_count(paddr_alloc.size/MEM_PAGE_SIZE);
   10776:	a1 20 70 01 00       	mov    0x17020,%eax
   1077b:	c1 e8 0c             	shr    $0xc,%eax
   1077e:	83 ec 0c             	sub    $0xc,%esp
   10781:	50                   	push   %eax
   10782:	e8 a5 40 00 00       	call   1482c <bitmap_byte_count>
   10787:	83 c4 10             	add    $0x10,%esp
   1078a:	01 45 f4             	add    %eax,-0xc(%ebp)
   ASSERT(mem_free < (uint8_t *)MEM_EBDA_START);
   1078d:	81 7d f4 ff ff 07 00 	cmpl   $0x7ffff,-0xc(%ebp)
   10794:	76 19                	jbe    107af <memory_init+0x8c>
   10796:	68 a4 53 01 00       	push   $0x153a4
   1079b:	68 80 54 01 00       	push   $0x15480
   107a0:	6a 6e                	push   $0x6e
   107a2:	68 6c 53 01 00       	push   $0x1536c
   107a7:	e8 06 48 00 00       	call   14fb2 <panic>
   107ac:	83 c4 10             	add    $0x10,%esp
   create_kernel_table();
   107af:	e8 c8 fe ff ff       	call   1067c <create_kernel_table>
   mmu_set_page_dir((uint32_t)kernel_page_dir);
   107b4:	b8 00 80 01 00       	mov    $0x18000,%eax
   107b9:	83 ec 0c             	sub    $0xc,%esp
   107bc:	50                   	push   %eax
   107bd:	e8 8d fb ff ff       	call   1034f <mmu_set_page_dir>
   107c2:	83 c4 10             	add    $0x10,%esp
}
   107c5:	90                   	nop
   107c6:	c9                   	leave  
   107c7:	c3                   	ret    

000107c8 <memory_create_uvm>:

uint32_t memory_create_uvm(void){
   107c8:	55                   	push   %ebp
   107c9:	89 e5                	mov    %esp,%ebp
   107cb:	83 ec 18             	sub    $0x18,%esp
    pde_t* page_dir=(pde_t*)addr_alloc_page(&paddr_alloc,1);
   107ce:	83 ec 08             	sub    $0x8,%esp
   107d1:	6a 01                	push   $0x1
   107d3:	68 00 70 01 00       	push   $0x17000
   107d8:	e8 52 fc ff ff       	call   1042f <addr_alloc_page>
   107dd:	83 c4 10             	add    $0x10,%esp
   107e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(page_dir==0){
   107e3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   107e7:	75 07                	jne    107f0 <memory_create_uvm+0x28>
        return 0;
   107e9:	b8 00 00 00 00       	mov    $0x0,%eax
   107ee:	eb 5b                	jmp    1084b <memory_create_uvm+0x83>
    }
    kernel_memset((void*)page_dir,0,MEM_PAGE_SIZE);
   107f0:	83 ec 04             	sub    $0x4,%esp
   107f3:	68 00 10 00 00       	push   $0x1000
   107f8:	6a 00                	push   $0x0
   107fa:	ff 75 f0             	pushl  -0x10(%ebp)
   107fd:	e8 5d 44 00 00       	call   14c5f <kernel_memset>
   10802:	83 c4 10             	add    $0x10,%esp
    uint32_t user_pde_start=pde_index(MEMORY_TASK_BASE);
   10805:	83 ec 0c             	sub    $0xc,%esp
   10808:	68 00 00 00 80       	push   $0x80000000
   1080d:	e8 7b fb ff ff       	call   1038d <pde_index>
   10812:	83 c4 10             	add    $0x10,%esp
   10815:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for(int i=0;i<user_pde_start;i++){
   10818:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1081f:	eb 1f                	jmp    10840 <memory_create_uvm+0x78>
        page_dir[i].v=kernel_page_dir[i].v;
   10821:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10824:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1082b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1082e:	01 c2                	add    %eax,%edx
   10830:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10833:	8b 04 85 00 80 01 00 	mov    0x18000(,%eax,4),%eax
   1083a:	89 02                	mov    %eax,(%edx)
    for(int i=0;i<user_pde_start;i++){
   1083c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10840:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10843:	39 45 ec             	cmp    %eax,-0x14(%ebp)
   10846:	77 d9                	ja     10821 <memory_create_uvm+0x59>
    }

    return (uint32_t)page_dir;
   10848:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   1084b:	c9                   	leave  
   1084c:	c3                   	ret    

0001084d <memory_alloc_for_page_dir>:

int memory_alloc_for_page_dir(uint32_t page_dir,uint32_t vaddr,uint32_t size,int perm){
   1084d:	55                   	push   %ebp
   1084e:	89 e5                	mov    %esp,%ebp
   10850:	83 ec 28             	sub    $0x28,%esp
    uint32_t curr_vaddr=vaddr;
   10853:	8b 45 0c             	mov    0xc(%ebp),%eax
   10856:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int page_count=up2(size,MEM_PAGE_SIZE) / MEM_PAGE_SIZE;
   10859:	68 00 10 00 00       	push   $0x1000
   1085e:	ff 75 10             	pushl  0x10(%ebp)
   10861:	e8 d2 fa ff ff       	call   10338 <up2>
   10866:	83 c4 08             	add    $0x8,%esp
   10869:	c1 e8 0c             	shr    $0xc,%eax
   1086c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for(int i=0;i<page_count;i++){
   1086f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   10876:	eb 7b                	jmp    108f3 <memory_alloc_for_page_dir+0xa6>
        uint32_t paddr=addr_alloc_page(&paddr_alloc,1);
   10878:	83 ec 08             	sub    $0x8,%esp
   1087b:	6a 01                	push   $0x1
   1087d:	68 00 70 01 00       	push   $0x17000
   10882:	e8 a8 fb ff ff       	call   1042f <addr_alloc_page>
   10887:	83 c4 10             	add    $0x10,%esp
   1088a:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if(paddr==0){
   1088d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   10891:	75 17                	jne    108aa <memory_alloc_for_page_dir+0x5d>
            log_printf("mem alloc failed. no memory");
   10893:	83 ec 0c             	sub    $0xc,%esp
   10896:	68 c9 53 01 00       	push   $0x153c9
   1089b:	e8 e2 49 00 00       	call   15282 <log_printf>
   108a0:	83 c4 10             	add    $0x10,%esp
            return 0;
   108a3:	b8 00 00 00 00       	mov    $0x0,%eax
   108a8:	eb 55                	jmp    108ff <memory_alloc_for_page_dir+0xb2>
        }

        int err=memory_create_map((pde_t*)page_dir,curr_vaddr,paddr,1,perm);
   108aa:	8b 55 14             	mov    0x14(%ebp),%edx
   108ad:	8b 45 08             	mov    0x8(%ebp),%eax
   108b0:	83 ec 0c             	sub    $0xc,%esp
   108b3:	52                   	push   %edx
   108b4:	6a 01                	push   $0x1
   108b6:	ff 75 e8             	pushl  -0x18(%ebp)
   108b9:	ff 75 f4             	pushl  -0xc(%ebp)
   108bc:	50                   	push   %eax
   108bd:	e8 1d fd ff ff       	call   105df <memory_create_map>
   108c2:	83 c4 20             	add    $0x20,%esp
   108c5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(err < 0){
   108c8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   108cc:	79 1a                	jns    108e8 <memory_alloc_for_page_dir+0x9b>
            log_printf("create memory failed. err=%d",err);
   108ce:	83 ec 08             	sub    $0x8,%esp
   108d1:	ff 75 e4             	pushl  -0x1c(%ebp)
   108d4:	68 e5 53 01 00       	push   $0x153e5
   108d9:	e8 a4 49 00 00       	call   15282 <log_printf>
   108de:	83 c4 10             	add    $0x10,%esp
            return 0;
   108e1:	b8 00 00 00 00       	mov    $0x0,%eax
   108e6:	eb 17                	jmp    108ff <memory_alloc_for_page_dir+0xb2>
        }

        curr_vaddr+=MEM_PAGE_SIZE;
   108e8:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
    for(int i=0;i<page_count;i++){
   108ef:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   108f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   108f6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   108f9:	0f 8c 79 ff ff ff    	jl     10878 <memory_alloc_for_page_dir+0x2b>

    }
}
   108ff:	c9                   	leave  
   10900:	c3                   	ret    

00010901 <memory_alloc_page_for>:

int memory_alloc_page_for(uint32_t addr,uint32_t size,int perm){
   10901:	55                   	push   %ebp
   10902:	89 e5                	mov    %esp,%ebp
   10904:	83 ec 08             	sub    $0x8,%esp
    return memory_alloc_for_page_dir(task_current()->tss.cr3,addr,size,perm);
   10907:	e8 d9 0c 00 00       	call   115e5 <task_current>
   1090c:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
   10912:	ff 75 10             	pushl  0x10(%ebp)
   10915:	ff 75 0c             	pushl  0xc(%ebp)
   10918:	ff 75 08             	pushl  0x8(%ebp)
   1091b:	50                   	push   %eax
   1091c:	e8 2c ff ff ff       	call   1084d <memory_alloc_for_page_dir>
   10921:	83 c4 10             	add    $0x10,%esp
}
   10924:	c9                   	leave  
   10925:	c3                   	ret    

00010926 <memory_alloc_page>:

uint32_t memory_alloc_page(void){
   10926:	55                   	push   %ebp
   10927:	89 e5                	mov    %esp,%ebp
   10929:	83 ec 18             	sub    $0x18,%esp
    uint32_t addr=addr_alloc_page(&paddr_alloc,1);
   1092c:	83 ec 08             	sub    $0x8,%esp
   1092f:	6a 01                	push   $0x1
   10931:	68 00 70 01 00       	push   $0x17000
   10936:	e8 f4 fa ff ff       	call   1042f <addr_alloc_page>
   1093b:	83 c4 10             	add    $0x10,%esp
   1093e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return addr;
   10941:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10944:	c9                   	leave  
   10945:	c3                   	ret    

00010946 <curr_page_dir>:

static pde_t* curr_page_dir(void){
   10946:	55                   	push   %ebp
   10947:	89 e5                	mov    %esp,%ebp
   10949:	83 ec 08             	sub    $0x8,%esp
    return (pde_t*)(task_current()->tss.cr3);
   1094c:	e8 94 0c 00 00       	call   115e5 <task_current>
   10951:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
}
   10957:	c9                   	leave  
   10958:	c3                   	ret    

00010959 <memory_free_page>:

void memory_free_page(uint32_t addr){
   10959:	55                   	push   %ebp
   1095a:	89 e5                	mov    %esp,%ebp
   1095c:	83 ec 18             	sub    $0x18,%esp
    if(addr < MEMORY_TASK_BASE){
   1095f:	8b 45 08             	mov    0x8(%ebp),%eax
   10962:	85 c0                	test   %eax,%eax
   10964:	78 17                	js     1097d <memory_free_page+0x24>
        addr_free_page(&paddr_alloc,addr,1);
   10966:	83 ec 04             	sub    $0x4,%esp
   10969:	6a 01                	push   $0x1
   1096b:	ff 75 08             	pushl  0x8(%ebp)
   1096e:	68 00 70 01 00       	push   $0x17000
   10973:	e8 1e fb ff ff       	call   10496 <addr_free_page>
   10978:	83 c4 10             	add    $0x10,%esp
        pte_t* pte=find_pte(curr_page_dir(),addr,0);
        ASSERT((pte==(pte_t*)0) &&  pte->present);
        addr_free_page(&paddr_alloc,pte_paddr(pte),1);
        pte->v=0;
    }
}
   1097b:	eb 72                	jmp    109ef <memory_free_page+0x96>
        pte_t* pte=find_pte(curr_page_dir(),addr,0);
   1097d:	e8 c4 ff ff ff       	call   10946 <curr_page_dir>
   10982:	83 ec 04             	sub    $0x4,%esp
   10985:	6a 00                	push   $0x0
   10987:	ff 75 08             	pushl  0x8(%ebp)
   1098a:	50                   	push   %eax
   1098b:	e8 9f fb ff ff       	call   1052f <find_pte>
   10990:	83 c4 10             	add    $0x10,%esp
   10993:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ASSERT((pte==(pte_t*)0) &&  pte->present);
   10996:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1099a:	75 0d                	jne    109a9 <memory_free_page+0x50>
   1099c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1099f:	0f b6 00             	movzbl (%eax),%eax
   109a2:	83 e0 01             	and    $0x1,%eax
   109a5:	84 c0                	test   %al,%al
   109a7:	75 1c                	jne    109c5 <memory_free_page+0x6c>
   109a9:	68 04 54 01 00       	push   $0x15404
   109ae:	68 8c 54 01 00       	push   $0x1548c
   109b3:	68 a9 00 00 00       	push   $0xa9
   109b8:	68 6c 53 01 00       	push   $0x1536c
   109bd:	e8 f0 45 00 00       	call   14fb2 <panic>
   109c2:	83 c4 10             	add    $0x10,%esp
        addr_free_page(&paddr_alloc,pte_paddr(pte),1);
   109c5:	83 ec 0c             	sub    $0xc,%esp
   109c8:	ff 75 f4             	pushl  -0xc(%ebp)
   109cb:	e8 e8 f9 ff ff       	call   103b8 <pte_paddr>
   109d0:	83 c4 10             	add    $0x10,%esp
   109d3:	83 ec 04             	sub    $0x4,%esp
   109d6:	6a 01                	push   $0x1
   109d8:	50                   	push   %eax
   109d9:	68 00 70 01 00       	push   $0x17000
   109de:	e8 b3 fa ff ff       	call   10496 <addr_free_page>
   109e3:	83 c4 10             	add    $0x10,%esp
        pte->v=0;
   109e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   109e9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
   109ef:	90                   	nop
   109f0:	c9                   	leave  
   109f1:	c3                   	ret    

000109f2 <memory_destroy_uvm>:

void memory_destroy_uvm(uint32_t page_dir){
   109f2:	55                   	push   %ebp
   109f3:	89 e5                	mov    %esp,%ebp
   109f5:	83 ec 28             	sub    $0x28,%esp
    uint32_t user_pde_start=pde_index(MEMORY_TASK_BASE);
   109f8:	68 00 00 00 80       	push   $0x80000000
   109fd:	e8 8b f9 ff ff       	call   1038d <pde_index>
   10a02:	83 c4 04             	add    $0x4,%esp
   10a05:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    pde_t* pde=(pde_t*)page_dir+user_pde_start;
   10a08:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10a0b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10a12:	8b 45 08             	mov    0x8(%ebp),%eax
   10a15:	01 d0                	add    %edx,%eax
   10a17:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for(int i=user_pde_start;i<PDE_CNT;i++,pde++){
   10a1a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10a1d:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10a20:	e9 8f 00 00 00       	jmp    10ab4 <memory_destroy_uvm+0xc2>
        if(!pde->present){
   10a25:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10a28:	0f b6 00             	movzbl (%eax),%eax
   10a2b:	83 e0 01             	and    $0x1,%eax
   10a2e:	84 c0                	test   %al,%al
   10a30:	74 79                	je     10aab <memory_destroy_uvm+0xb9>
            continue;
        }

        pte_t* pte=(pte_t*)pde_paddr(pde);
   10a32:	ff 75 f4             	pushl  -0xc(%ebp)
   10a35:	e8 6e f9 ff ff       	call   103a8 <pde_paddr>
   10a3a:	83 c4 04             	add    $0x4,%esp
   10a3d:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(int j=0;j<PTE_CNT;j++,pte++){
   10a40:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   10a47:	eb 36                	jmp    10a7f <memory_destroy_uvm+0x8d>
            if(!pte->present){
   10a49:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10a4c:	0f b6 00             	movzbl (%eax),%eax
   10a4f:	83 e0 01             	and    $0x1,%eax
   10a52:	84 c0                	test   %al,%al
   10a54:	74 20                	je     10a76 <memory_destroy_uvm+0x84>
                continue;
            }

            addr_free_page(&paddr_alloc,pte_paddr(pte),1);
   10a56:	ff 75 ec             	pushl  -0x14(%ebp)
   10a59:	e8 5a f9 ff ff       	call   103b8 <pte_paddr>
   10a5e:	83 c4 04             	add    $0x4,%esp
   10a61:	83 ec 04             	sub    $0x4,%esp
   10a64:	6a 01                	push   $0x1
   10a66:	50                   	push   %eax
   10a67:	68 00 70 01 00       	push   $0x17000
   10a6c:	e8 25 fa ff ff       	call   10496 <addr_free_page>
   10a71:	83 c4 10             	add    $0x10,%esp
   10a74:	eb 01                	jmp    10a77 <memory_destroy_uvm+0x85>
                continue;
   10a76:	90                   	nop
        for(int j=0;j<PTE_CNT;j++,pte++){
   10a77:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   10a7b:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
   10a7f:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
   10a86:	7e c1                	jle    10a49 <memory_destroy_uvm+0x57>
        }

        addr_free_page(&paddr_alloc,(uint32_t)pde_paddr(pde),1);
   10a88:	83 ec 0c             	sub    $0xc,%esp
   10a8b:	ff 75 f4             	pushl  -0xc(%ebp)
   10a8e:	e8 15 f9 ff ff       	call   103a8 <pde_paddr>
   10a93:	83 c4 10             	add    $0x10,%esp
   10a96:	83 ec 04             	sub    $0x4,%esp
   10a99:	6a 01                	push   $0x1
   10a9b:	50                   	push   %eax
   10a9c:	68 00 70 01 00       	push   $0x17000
   10aa1:	e8 f0 f9 ff ff       	call   10496 <addr_free_page>
   10aa6:	83 c4 10             	add    $0x10,%esp
   10aa9:	eb 01                	jmp    10aac <memory_destroy_uvm+0xba>
            continue;
   10aab:	90                   	nop
    for(int i=user_pde_start;i<PDE_CNT;i++,pde++){
   10aac:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   10ab0:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
   10ab4:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
   10abb:	0f 8e 64 ff ff ff    	jle    10a25 <memory_destroy_uvm+0x33>
    }

    addr_free_page(&paddr_alloc,page_dir,1);
   10ac1:	83 ec 04             	sub    $0x4,%esp
   10ac4:	6a 01                	push   $0x1
   10ac6:	ff 75 08             	pushl  0x8(%ebp)
   10ac9:	68 00 70 01 00       	push   $0x17000
   10ace:	e8 c3 f9 ff ff       	call   10496 <addr_free_page>
   10ad3:	83 c4 10             	add    $0x10,%esp
}
   10ad6:	90                   	nop
   10ad7:	c9                   	leave  
   10ad8:	c3                   	ret    

00010ad9 <memory_copy_uvm>:

uint32_t memory_copy_uvm(uint32_t page_dir){
   10ad9:	55                   	push   %ebp
   10ada:	89 e5                	mov    %esp,%ebp
   10adc:	83 ec 38             	sub    $0x38,%esp
    uint32_t to_page_dir=memory_create_uvm();
   10adf:	e8 e4 fc ff ff       	call   107c8 <memory_create_uvm>
   10ae4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(to_page_dir == 0){
   10ae7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   10aeb:	0f 84 1b 01 00 00    	je     10c0c <memory_copy_uvm+0x133>
        goto copy_uvm_failed;
    }

    uint32_t user_pde_start=pde_index(MEMORY_TASK_BASE);
   10af1:	83 ec 0c             	sub    $0xc,%esp
   10af4:	68 00 00 00 80       	push   $0x80000000
   10af9:	e8 8f f8 ff ff       	call   1038d <pde_index>
   10afe:	83 c4 10             	add    $0x10,%esp
   10b01:	89 45 e0             	mov    %eax,-0x20(%ebp)
    pde_t* pde=(pde_t*)page_dir+user_pde_start;
   10b04:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10b07:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10b0e:	8b 45 08             	mov    0x8(%ebp),%eax
   10b11:	01 d0                	add    %edx,%eax
   10b13:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for(int i=user_pde_start;i<PDE_CNT;i++,pde++){
   10b16:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10b19:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10b1c:	e9 d9 00 00 00       	jmp    10bfa <memory_copy_uvm+0x121>
        if(!pde->present){
   10b21:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10b24:	0f b6 00             	movzbl (%eax),%eax
   10b27:	83 e0 01             	and    $0x1,%eax
   10b2a:	84 c0                	test   %al,%al
   10b2c:	0f 84 bf 00 00 00    	je     10bf1 <memory_copy_uvm+0x118>
            continue;
        }

        pte_t*pte=(pte_t*)pde_paddr(pde);
   10b32:	83 ec 0c             	sub    $0xc,%esp
   10b35:	ff 75 f4             	pushl  -0xc(%ebp)
   10b38:	e8 6b f8 ff ff       	call   103a8 <pde_paddr>
   10b3d:	83 c4 10             	add    $0x10,%esp
   10b40:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(int j=0;j<PTE_CNT;j++,pte++){
   10b43:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   10b4a:	e9 93 00 00 00       	jmp    10be2 <memory_copy_uvm+0x109>
            if(!pte->present){
   10b4f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10b52:	0f b6 00             	movzbl (%eax),%eax
   10b55:	83 e0 01             	and    $0x1,%eax
   10b58:	84 c0                	test   %al,%al
   10b5a:	74 7d                	je     10bd9 <memory_copy_uvm+0x100>
                continue;
            }

            uint32_t page=addr_alloc_page(&paddr_alloc,1);
   10b5c:	83 ec 08             	sub    $0x8,%esp
   10b5f:	6a 01                	push   $0x1
   10b61:	68 00 70 01 00       	push   $0x17000
   10b66:	e8 c4 f8 ff ff       	call   1042f <addr_alloc_page>
   10b6b:	83 c4 10             	add    $0x10,%esp
   10b6e:	89 45 dc             	mov    %eax,-0x24(%ebp)
            if(page==0) {
   10b71:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   10b75:	0f 84 94 00 00 00    	je     10c0f <memory_copy_uvm+0x136>
                goto copy_uvm_failed;
            }
            uint32_t vaddr=(i<<22) | (j<<12);
   10b7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10b7e:	c1 e0 16             	shl    $0x16,%eax
   10b81:	89 c2                	mov    %eax,%edx
   10b83:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b86:	c1 e0 0c             	shl    $0xc,%eax
   10b89:	09 d0                	or     %edx,%eax
   10b8b:	89 45 d8             	mov    %eax,-0x28(%ebp)
            int err=memory_create_map((pde_t*)to_page_dir,vaddr,page,1,get_pte_perm(pte));
   10b8e:	83 ec 0c             	sub    $0xc,%esp
   10b91:	ff 75 ec             	pushl  -0x14(%ebp)
   10b94:	e8 2f f8 ff ff       	call   103c8 <get_pte_perm>
   10b99:	83 c4 10             	add    $0x10,%esp
   10b9c:	89 c2                	mov    %eax,%edx
   10b9e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10ba1:	83 ec 0c             	sub    $0xc,%esp
   10ba4:	52                   	push   %edx
   10ba5:	6a 01                	push   $0x1
   10ba7:	ff 75 dc             	pushl  -0x24(%ebp)
   10baa:	ff 75 d8             	pushl  -0x28(%ebp)
   10bad:	50                   	push   %eax
   10bae:	e8 2c fa ff ff       	call   105df <memory_create_map>
   10bb3:	83 c4 20             	add    $0x20,%esp
   10bb6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            if(err < 0){
   10bb9:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   10bbd:	78 53                	js     10c12 <memory_copy_uvm+0x139>
                goto copy_uvm_failed;
            }

            kernel_memcpy((void*)page,(void*)vaddr,MEM_PAGE_SIZE);
   10bbf:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10bc2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10bc5:	83 ec 04             	sub    $0x4,%esp
   10bc8:	68 00 10 00 00       	push   $0x1000
   10bcd:	52                   	push   %edx
   10bce:	50                   	push   %eax
   10bcf:	e8 3c 40 00 00       	call   14c10 <kernel_memcpy>
   10bd4:	83 c4 10             	add    $0x10,%esp
   10bd7:	eb 01                	jmp    10bda <memory_copy_uvm+0x101>
                continue;
   10bd9:	90                   	nop
        for(int j=0;j<PTE_CNT;j++,pte++){
   10bda:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   10bde:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
   10be2:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
   10be9:	0f 8e 60 ff ff ff    	jle    10b4f <memory_copy_uvm+0x76>
   10bef:	eb 01                	jmp    10bf2 <memory_copy_uvm+0x119>
            continue;
   10bf1:	90                   	nop
    for(int i=user_pde_start;i<PDE_CNT;i++,pde++){
   10bf2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   10bf6:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
   10bfa:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
   10c01:	0f 8e 1a ff ff ff    	jle    10b21 <memory_copy_uvm+0x48>
        }
    }

    return to_page_dir;
   10c07:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10c0a:	eb 20                	jmp    10c2c <memory_copy_uvm+0x153>
        goto copy_uvm_failed;
   10c0c:	90                   	nop
   10c0d:	eb 04                	jmp    10c13 <memory_copy_uvm+0x13a>
                goto copy_uvm_failed;
   10c0f:	90                   	nop
   10c10:	eb 01                	jmp    10c13 <memory_copy_uvm+0x13a>
                goto copy_uvm_failed;
   10c12:	90                   	nop
copy_uvm_failed:
    if(to_page_dir){
   10c13:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   10c17:	74 0e                	je     10c27 <memory_copy_uvm+0x14e>
        memory_destroy_uvm(to_page_dir);
   10c19:	83 ec 0c             	sub    $0xc,%esp
   10c1c:	ff 75 e4             	pushl  -0x1c(%ebp)
   10c1f:	e8 ce fd ff ff       	call   109f2 <memory_destroy_uvm>
   10c24:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   10c27:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   10c2c:	c9                   	leave  
   10c2d:	c3                   	ret    

00010c2e <memory_get_paddr>:

uint32_t memory_get_paddr(uint32_t page_dir,uint32_t vaddr){
   10c2e:	55                   	push   %ebp
   10c2f:	89 e5                	mov    %esp,%ebp
   10c31:	83 ec 18             	sub    $0x18,%esp
    pte_t* pte=find_pte((pde_t*)page_dir,vaddr,0);
   10c34:	8b 45 08             	mov    0x8(%ebp),%eax
   10c37:	83 ec 04             	sub    $0x4,%esp
   10c3a:	6a 00                	push   $0x0
   10c3c:	ff 75 0c             	pushl  0xc(%ebp)
   10c3f:	50                   	push   %eax
   10c40:	e8 ea f8 ff ff       	call   1052f <find_pte>
   10c45:	83 c4 10             	add    $0x10,%esp
   10c48:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!pte){
   10c4b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10c4f:	75 07                	jne    10c58 <memory_get_paddr+0x2a>
        return 0;
   10c51:	b8 00 00 00 00       	mov    $0x0,%eax
   10c56:	eb 1a                	jmp    10c72 <memory_get_paddr+0x44>
    }

    return pte_paddr(pte) + (vaddr & (MEM_PAGE_SIZE-1));
   10c58:	83 ec 0c             	sub    $0xc,%esp
   10c5b:	ff 75 f4             	pushl  -0xc(%ebp)
   10c5e:	e8 55 f7 ff ff       	call   103b8 <pte_paddr>
   10c63:	83 c4 10             	add    $0x10,%esp
   10c66:	89 c2                	mov    %eax,%edx
   10c68:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c6b:	25 ff 0f 00 00       	and    $0xfff,%eax
   10c70:	01 d0                	add    %edx,%eax
}
   10c72:	c9                   	leave  
   10c73:	c3                   	ret    

00010c74 <memory_copy_uvm_data>:

int memory_copy_uvm_data(uint32_t to,uint32_t page_dir,uint32_t from,uint32_t size){
   10c74:	55                   	push   %ebp
   10c75:	89 e5                	mov    %esp,%ebp
   10c77:	83 ec 18             	sub    $0x18,%esp
    while(size > 0){
   10c7a:	eb 6d                	jmp    10ce9 <memory_copy_uvm_data+0x75>
        uint32_t to_paddr=memory_get_paddr(page_dir,to);
   10c7c:	83 ec 08             	sub    $0x8,%esp
   10c7f:	ff 75 08             	pushl  0x8(%ebp)
   10c82:	ff 75 0c             	pushl  0xc(%ebp)
   10c85:	e8 a4 ff ff ff       	call   10c2e <memory_get_paddr>
   10c8a:	83 c4 10             	add    $0x10,%esp
   10c8d:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(to_paddr == 0){
   10c90:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10c94:	75 07                	jne    10c9d <memory_copy_uvm_data+0x29>
            return -1;
   10c96:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10c9b:	eb 57                	jmp    10cf4 <memory_copy_uvm_data+0x80>
        }

        uint32_t offset_in_page=to_paddr & (MEM_PAGE_SIZE-1);
   10c9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10ca0:	25 ff 0f 00 00       	and    $0xfff,%eax
   10ca5:	89 45 ec             	mov    %eax,-0x14(%ebp)
        uint32_t curr_size=MEM_PAGE_SIZE-offset_in_page;
   10ca8:	b8 00 10 00 00       	mov    $0x1000,%eax
   10cad:	2b 45 ec             	sub    -0x14(%ebp),%eax
   10cb0:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(curr_size > size){
   10cb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10cb6:	3b 45 14             	cmp    0x14(%ebp),%eax
   10cb9:	76 06                	jbe    10cc1 <memory_copy_uvm_data+0x4d>
            curr_size = size;
   10cbb:	8b 45 14             	mov    0x14(%ebp),%eax
   10cbe:	89 45 f4             	mov    %eax,-0xc(%ebp)
        }

        kernel_memcpy((void*)to_paddr,(void*)from,curr_size);
   10cc1:	8b 55 10             	mov    0x10(%ebp),%edx
   10cc4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10cc7:	83 ec 04             	sub    $0x4,%esp
   10cca:	ff 75 f4             	pushl  -0xc(%ebp)
   10ccd:	52                   	push   %edx
   10cce:	50                   	push   %eax
   10ccf:	e8 3c 3f 00 00       	call   14c10 <kernel_memcpy>
   10cd4:	83 c4 10             	add    $0x10,%esp
        size -= curr_size;
   10cd7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10cda:	29 45 14             	sub    %eax,0x14(%ebp)
        to += curr_size;
   10cdd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10ce0:	01 45 08             	add    %eax,0x8(%ebp)
        from += curr_size;
   10ce3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10ce6:	01 45 10             	add    %eax,0x10(%ebp)
    while(size > 0){
   10ce9:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   10ced:	75 8d                	jne    10c7c <memory_copy_uvm_data+0x8>
    }
    return 0;
   10cef:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10cf4:	c9                   	leave  
   10cf5:	c3                   	ret    

00010cf6 <sys_sbrk>:

char* sys_sbrk(int incr){
   10cf6:	55                   	push   %ebp
   10cf7:	89 e5                	mov    %esp,%ebp
   10cf9:	83 ec 38             	sub    $0x38,%esp
    task_t* task=task_current();
   10cfc:	e8 e4 08 00 00       	call   115e5 <task_current>
   10d01:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint8_t*pre_heap_end=(uint8_t*) task->heap_end;
   10d04:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10d07:	8b 40 10             	mov    0x10(%eax),%eax
   10d0a:	89 45 ec             	mov    %eax,-0x14(%ebp)

    ASSERT(incr>=0);
   10d0d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   10d11:	79 1c                	jns    10d2f <sys_sbrk+0x39>
   10d13:	68 25 54 01 00       	push   $0x15425
   10d18:	68 a0 54 01 00       	push   $0x154a0
   10d1d:	68 13 01 00 00       	push   $0x113
   10d22:	68 6c 53 01 00       	push   $0x1536c
   10d27:	e8 86 42 00 00       	call   14fb2 <panic>
   10d2c:	83 c4 10             	add    $0x10,%esp

    int pre_incr=incr;
   10d2f:	8b 45 08             	mov    0x8(%ebp),%eax
   10d32:	89 45 e8             	mov    %eax,-0x18(%ebp)

    if(incr==0){
   10d35:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   10d39:	75 1b                	jne    10d56 <sys_sbrk+0x60>
        log_printf("sbrk(0): end=0x%x",pre_heap_end);
   10d3b:	83 ec 08             	sub    $0x8,%esp
   10d3e:	ff 75 ec             	pushl  -0x14(%ebp)
   10d41:	68 2d 54 01 00       	push   $0x1542d
   10d46:	e8 37 45 00 00       	call   15282 <log_printf>
   10d4b:	83 c4 10             	add    $0x10,%esp
        return pre_heap_end;
   10d4e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10d51:	e9 c0 00 00 00       	jmp    10e16 <sys_sbrk+0x120>
    }

    uint32_t start=task->heap_end;
   10d56:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10d59:	8b 40 10             	mov    0x10(%eax),%eax
   10d5c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t end=start+incr;
   10d5f:	8b 55 08             	mov    0x8(%ebp),%edx
   10d62:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d65:	01 d0                	add    %edx,%eax
   10d67:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    int start_offset=start % MEM_PAGE_SIZE;
   10d6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d6d:	25 ff 0f 00 00       	and    $0xfff,%eax
   10d72:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(start_offset){
   10d75:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   10d79:	74 37                	je     10db2 <sys_sbrk+0xbc>
        if(start_offset+incr <= MEM_PAGE_SIZE){
   10d7b:	8b 55 e0             	mov    -0x20(%ebp),%edx
   10d7e:	8b 45 08             	mov    0x8(%ebp),%eax
   10d81:	01 d0                	add    %edx,%eax
   10d83:	3d 00 10 00 00       	cmp    $0x1000,%eax
   10d88:	7f 0e                	jg     10d98 <sys_sbrk+0xa2>
            task->heap_end=end;
   10d8a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10d8d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   10d90:	89 50 10             	mov    %edx,0x10(%eax)
            return pre_heap_end;
   10d93:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10d96:	eb 7e                	jmp    10e16 <sys_sbrk+0x120>
        }
        else{
            uint32_t curr_size=MEM_PAGE_SIZE - start_offset;
   10d98:	b8 00 10 00 00       	mov    $0x1000,%eax
   10d9d:	2b 45 e0             	sub    -0x20(%ebp),%eax
   10da0:	89 45 dc             	mov    %eax,-0x24(%ebp)
            start+=curr_size;
   10da3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10da6:	01 45 f4             	add    %eax,-0xc(%ebp)
            incr-=curr_size;
   10da9:	8b 45 08             	mov    0x8(%ebp),%eax
   10dac:	2b 45 dc             	sub    -0x24(%ebp),%eax
   10daf:	89 45 08             	mov    %eax,0x8(%ebp)
        }
    }

    if(incr){
   10db2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   10db6:	74 3c                	je     10df4 <sys_sbrk+0xfe>
        uint32_t curr_size=end-start;
   10db8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10dbb:	2b 45 f4             	sub    -0xc(%ebp),%eax
   10dbe:	89 45 d8             	mov    %eax,-0x28(%ebp)
        int err=memory_alloc_page_for(start,curr_size,PTE_P | PTE_U | PTE_W);
   10dc1:	83 ec 04             	sub    $0x4,%esp
   10dc4:	6a 07                	push   $0x7
   10dc6:	ff 75 d8             	pushl  -0x28(%ebp)
   10dc9:	ff 75 f4             	pushl  -0xc(%ebp)
   10dcc:	e8 30 fb ff ff       	call   10901 <memory_alloc_page_for>
   10dd1:	83 c4 10             	add    $0x10,%esp
   10dd4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        if(err<0){
   10dd7:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   10ddb:	79 17                	jns    10df4 <sys_sbrk+0xfe>
            log_printf("sbrk: alloc mem failed.");
   10ddd:	83 ec 0c             	sub    $0xc,%esp
   10de0:	68 3f 54 01 00       	push   $0x1543f
   10de5:	e8 98 44 00 00       	call   15282 <log_printf>
   10dea:	83 c4 10             	add    $0x10,%esp
            return (char*)-1;
   10ded:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10df2:	eb 22                	jmp    10e16 <sys_sbrk+0x120>
        }
    }

    log_printf("sbrk(%d): end=0x%x",pre_incr,end);
   10df4:	83 ec 04             	sub    $0x4,%esp
   10df7:	ff 75 e4             	pushl  -0x1c(%ebp)
   10dfa:	ff 75 e8             	pushl  -0x18(%ebp)
   10dfd:	68 57 54 01 00       	push   $0x15457
   10e02:	e8 7b 44 00 00       	call   15282 <log_printf>
   10e07:	83 c4 10             	add    $0x10,%esp
    task->heap_end=end;
   10e0a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10e0d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   10e10:	89 50 10             	mov    %edx,0x10(%eax)
    return (char*)pre_heap_end;
   10e13:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10e16:	c9                   	leave  
   10e17:	c3                   	ret    

00010e18 <sys_print_msg>:
#include "core/task.h"
#include "fs/fs.h"
#include "core/memory.h"
typedef int (*syscall_handler_t)(uint32_t arg0,uint32_t arg1,uint32_t arg2,uint32_t arg3);

void sys_print_msg(char* fmt,int arg){
   10e18:	55                   	push   %ebp
   10e19:	89 e5                	mov    %esp,%ebp
   10e1b:	83 ec 08             	sub    $0x8,%esp
    log_printf(fmt,arg);
   10e1e:	83 ec 08             	sub    $0x8,%esp
   10e21:	ff 75 0c             	pushl  0xc(%ebp)
   10e24:	ff 75 08             	pushl  0x8(%ebp)
   10e27:	e8 56 44 00 00       	call   15282 <log_printf>
   10e2c:	83 c4 10             	add    $0x10,%esp
}
   10e2f:	90                   	nop
   10e30:	c9                   	leave  
   10e31:	c3                   	ret    

00010e32 <do_handler_syscall>:
    [SYS_FSTAT]=(syscall_handler_t)sys_fstat,
    [SYS_PRINT_MSG]=(syscall_handler_t)sys_print_msg,
};


void do_handler_syscall(syscall_frame_t*frame){
   10e32:	55                   	push   %ebp
   10e33:	89 e5                	mov    %esp,%ebp
   10e35:	53                   	push   %ebx
   10e36:	83 ec 14             	sub    $0x14,%esp
    if(frame->func_id < sizeof(sys_table)/sizeof(sys_table[0])){
   10e39:	8b 45 08             	mov    0x8(%ebp),%eax
   10e3c:	8b 40 3c             	mov    0x3c(%eax),%eax
   10e3f:	83 f8 64             	cmp    $0x64,%eax
   10e42:	77 48                	ja     10e8c <do_handler_syscall+0x5a>
        syscall_handler_t handler=sys_table[frame->func_id];
   10e44:	8b 45 08             	mov    0x8(%ebp),%eax
   10e47:	8b 40 3c             	mov    0x3c(%eax),%eax
   10e4a:	8b 04 85 c0 54 01 00 	mov    0x154c0(,%eax,4),%eax
   10e51:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(handler){
   10e54:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10e58:	74 32                	je     10e8c <do_handler_syscall+0x5a>
            int ret=handler(frame->arg0,frame->arg1,frame->arg2,frame->arg3);
   10e5a:	8b 45 08             	mov    0x8(%ebp),%eax
   10e5d:	8b 58 4c             	mov    0x4c(%eax),%ebx
   10e60:	8b 45 08             	mov    0x8(%ebp),%eax
   10e63:	8b 48 48             	mov    0x48(%eax),%ecx
   10e66:	8b 45 08             	mov    0x8(%ebp),%eax
   10e69:	8b 50 44             	mov    0x44(%eax),%edx
   10e6c:	8b 45 08             	mov    0x8(%ebp),%eax
   10e6f:	8b 40 40             	mov    0x40(%eax),%eax
   10e72:	53                   	push   %ebx
   10e73:	51                   	push   %ecx
   10e74:	52                   	push   %edx
   10e75:	50                   	push   %eax
   10e76:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10e79:	ff d0                	call   *%eax
   10e7b:	83 c4 10             	add    $0x10,%esp
   10e7e:	89 45 f0             	mov    %eax,-0x10(%ebp)
            frame->eax=ret;
   10e81:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10e84:	8b 45 08             	mov    0x8(%ebp),%eax
   10e87:	89 50 30             	mov    %edx,0x30(%eax)
            return;
   10e8a:	eb 30                	jmp    10ebc <do_handler_syscall+0x8a>
        }
    }

    task_t* task=task_current();
   10e8c:	e8 54 07 00 00       	call   115e5 <task_current>
   10e91:	89 45 ec             	mov    %eax,-0x14(%ebp)
    log_printf("task: %s, Unknown syscall: %d",task->name,frame->func_id);
   10e94:	8b 45 08             	mov    0x8(%ebp),%eax
   10e97:	8b 40 3c             	mov    0x3c(%eax),%eax
   10e9a:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10e9d:	83 c2 20             	add    $0x20,%edx
   10ea0:	83 ec 04             	sub    $0x4,%esp
   10ea3:	50                   	push   %eax
   10ea4:	52                   	push   %edx
   10ea5:	68 54 56 01 00       	push   $0x15654
   10eaa:	e8 d3 43 00 00       	call   15282 <log_printf>
   10eaf:	83 c4 10             	add    $0x10,%esp
    frame->eax=-1;
   10eb2:	8b 45 08             	mov    0x8(%ebp),%eax
   10eb5:	c7 40 30 ff ff ff ff 	movl   $0xffffffff,0x30(%eax)
   10ebc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10ebf:	c9                   	leave  
   10ec0:	c3                   	ret    

00010ec1 <read_cr0>:
static inline uint32_t read_cr0(void){
   10ec1:	55                   	push   %ebp
   10ec2:	89 e5                	mov    %esp,%ebp
   10ec4:	83 ec 10             	sub    $0x10,%esp
    __asm__ __volatile__(
   10ec7:	0f 20 c0             	mov    %cr0,%eax
   10eca:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return cr0;
   10ecd:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   10ed0:	c9                   	leave  
   10ed1:	c3                   	ret    

00010ed2 <write_cr0>:
static inline void write_cr0(uint32_t v){
   10ed2:	55                   	push   %ebp
   10ed3:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   10ed5:	8b 45 08             	mov    0x8(%ebp),%eax
   10ed8:	0f 22 c0             	mov    %eax,%cr0
}
   10edb:	90                   	nop
   10edc:	5d                   	pop    %ebp
   10edd:	c3                   	ret    

00010ede <hlt>:
static inline void hlt(void){
   10ede:	55                   	push   %ebp
   10edf:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile("hlt");
   10ee1:	f4                   	hlt    
}
   10ee2:	90                   	nop
   10ee3:	5d                   	pop    %ebp
   10ee4:	c3                   	ret    

00010ee5 <write_tr>:
static inline void write_tr(uint16_t tss_sel){
   10ee5:	55                   	push   %ebp
   10ee6:	89 e5                	mov    %esp,%ebp
   10ee8:	83 ec 04             	sub    $0x4,%esp
   10eeb:	8b 45 08             	mov    0x8(%ebp),%eax
   10eee:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    __asm__ __volatile__(
   10ef2:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
   10ef6:	0f 00 d8             	ltr    %ax
}
   10ef9:	90                   	nop
   10efa:	c9                   	leave  
   10efb:	c3                   	ret    

00010efc <write_cr3>:
static inline void write_cr3(uint32_t v){
   10efc:	55                   	push   %ebp
   10efd:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   10eff:	8b 45 08             	mov    0x8(%ebp),%eax
   10f02:	0f 22 d8             	mov    %eax,%cr3
}
   10f05:	90                   	nop
   10f06:	5d                   	pop    %ebp
   10f07:	c3                   	ret    

00010f08 <write_cr4>:
static inline void write_cr4(uint32_t v){
   10f08:	55                   	push   %ebp
   10f09:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   10f0b:	8b 45 08             	mov    0x8(%ebp),%eax
   10f0e:	0f 22 e0             	mov    %eax,%cr4
}
   10f11:	90                   	nop
   10f12:	5d                   	pop    %ebp
   10f13:	c3                   	ret    

00010f14 <read_cr4>:
static inline uint32_t read_cr4(void){
   10f14:	55                   	push   %ebp
   10f15:	89 e5                	mov    %esp,%ebp
   10f17:	83 ec 10             	sub    $0x10,%esp
    __asm__ __volatile__(
   10f1a:	0f 20 e0             	mov    %cr4,%eax
   10f1d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return cr4;
   10f20:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   10f23:	c9                   	leave  
   10f24:	c3                   	ret    

00010f25 <list_node_init>:
typedef struct _list_node_t{
    struct _list_node_t*pre;
    struct _list_node_t*next;
}list_node_t;

static inline void list_node_init(list_node_t* node){
   10f25:	55                   	push   %ebp
   10f26:	89 e5                	mov    %esp,%ebp
    node->pre=node->next=(list_node_t*)0;
   10f28:	8b 45 08             	mov    0x8(%ebp),%eax
   10f2b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   10f32:	8b 45 08             	mov    0x8(%ebp),%eax
   10f35:	8b 50 04             	mov    0x4(%eax),%edx
   10f38:	8b 45 08             	mov    0x8(%ebp),%eax
   10f3b:	89 10                	mov    %edx,(%eax)
}
   10f3d:	90                   	nop
   10f3e:	5d                   	pop    %ebp
   10f3f:	c3                   	ret    

00010f40 <list_node_next>:

static inline list_node_t* list_node_pre(list_node_t* node){
    return node->pre;
}

static inline list_node_t* list_node_next(list_node_t* node){
   10f40:	55                   	push   %ebp
   10f41:	89 e5                	mov    %esp,%ebp
    return node->next;
   10f43:	8b 45 08             	mov    0x8(%ebp),%eax
   10f46:	8b 40 04             	mov    0x4(%eax),%eax
}
   10f49:	5d                   	pop    %ebp
   10f4a:	c3                   	ret    

00010f4b <list_count>:
void list_init(list_t* list);
static inline int list_is_empty(list_t* list){
    return list->count==0;
}

static inline int list_count(list_t* list){
   10f4b:	55                   	push   %ebp
   10f4c:	89 e5                	mov    %esp,%ebp
    return list->count;
   10f4e:	8b 45 08             	mov    0x8(%ebp),%eax
   10f51:	8b 40 08             	mov    0x8(%eax),%eax
}
   10f54:	5d                   	pop    %ebp
   10f55:	c3                   	ret    

00010f56 <list_first>:

static inline list_node_t* list_first(list_t* list){
   10f56:	55                   	push   %ebp
   10f57:	89 e5                	mov    %esp,%ebp
    return list->first;
   10f59:	8b 45 08             	mov    0x8(%ebp),%eax
   10f5c:	8b 00                	mov    (%eax),%eax
}
   10f5e:	5d                   	pop    %ebp
   10f5f:	c3                   	ret    

00010f60 <mmu_set_page_dir>:
static inline void mmu_set_page_dir(uint32_t paddr){
   10f60:	55                   	push   %ebp
   10f61:	89 e5                	mov    %esp,%ebp
   10f63:	83 ec 10             	sub    $0x10,%esp
    uint32_t cr4=read_cr4();
   10f66:	e8 a9 ff ff ff       	call   10f14 <read_cr4>
   10f6b:	89 45 fc             	mov    %eax,-0x4(%ebp)
	write_cr4(cr4|CR4_PSE);
   10f6e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10f71:	83 c8 10             	or     $0x10,%eax
   10f74:	50                   	push   %eax
   10f75:	e8 8e ff ff ff       	call   10f08 <write_cr4>
   10f7a:	83 c4 04             	add    $0x4,%esp
	write_cr3(paddr);
   10f7d:	ff 75 08             	pushl  0x8(%ebp)
   10f80:	e8 77 ff ff ff       	call   10efc <write_cr3>
   10f85:	83 c4 04             	add    $0x4,%esp
	write_cr0(read_cr0()|CR0_PG);
   10f88:	e8 34 ff ff ff       	call   10ec1 <read_cr0>
   10f8d:	0d 00 00 00 80       	or     $0x80000000,%eax
   10f92:	50                   	push   %eax
   10f93:	e8 3a ff ff ff       	call   10ed2 <write_cr0>
   10f98:	83 c4 04             	add    $0x4,%esp
}
   10f9b:	90                   	nop
   10f9c:	c9                   	leave  
   10f9d:	c3                   	ret    

00010f9e <tss_init>:
static task_manager_t task_manager;
static uint32_t idle_task_stack[IDLE_TASK_SIZE];
static task_t task_table[TASK_NR];
static mutex_t table_mutex;

static int tss_init(task_t* task,int flag,uint32_t entry,uint32_t esp){
   10f9e:	55                   	push   %ebp
   10f9f:	89 e5                	mov    %esp,%ebp
   10fa1:	83 ec 28             	sub    $0x28,%esp
    int tss_sel=gdt_alloc_desc();
   10fa4:	e8 8b 12 00 00       	call   12234 <gdt_alloc_desc>
   10fa9:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(tss_sel<0){
   10fac:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10fb0:	79 1a                	jns    10fcc <tss_init+0x2e>
        log_printf("alloc tss failed.\n");
   10fb2:	83 ec 0c             	sub    $0xc,%esp
   10fb5:	68 74 56 01 00       	push   $0x15674
   10fba:	e8 c3 42 00 00       	call   15282 <log_printf>
   10fbf:	83 c4 10             	add    $0x10,%esp
        return -1;
   10fc2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10fc7:	e9 6b 01 00 00       	jmp    11137 <tss_init+0x199>
    }
    segment_desc_set(tss_sel,(uint32_t)&task->tss,sizeof(tss_t),
   10fcc:	8b 45 08             	mov    0x8(%ebp),%eax
   10fcf:	05 58 02 00 00       	add    $0x258,%eax
   10fd4:	68 89 00 00 00       	push   $0x89
   10fd9:	6a 68                	push   $0x68
   10fdb:	50                   	push   %eax
   10fdc:	ff 75 ec             	pushl  -0x14(%ebp)
   10fdf:	e8 da 10 00 00       	call   120be <segment_desc_set>
   10fe4:	83 c4 10             	add    $0x10,%esp
        SEG_P_PRESENT | SEG_DPL0 | SEG_TYPE_TSS
    );
    kernel_memset(&task->tss,0,sizeof(tss_t));
   10fe7:	8b 45 08             	mov    0x8(%ebp),%eax
   10fea:	05 58 02 00 00       	add    $0x258,%eax
   10fef:	83 ec 04             	sub    $0x4,%esp
   10ff2:	6a 68                	push   $0x68
   10ff4:	6a 00                	push   $0x0
   10ff6:	50                   	push   %eax
   10ff7:	e8 63 3c 00 00       	call   14c5f <kernel_memset>
   10ffc:	83 c4 10             	add    $0x10,%esp

    uint32_t kernel_stack=memory_alloc_page();
   10fff:	e8 22 f9 ff ff       	call   10926 <memory_alloc_page>
   11004:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(kernel_stack == 0){
   11007:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1100b:	0f 84 fb 00 00 00    	je     1110c <tss_init+0x16e>
        goto tss_init_failed;
    }
    
    int code_sel,data_sel;
    if(flag & TASK_FLAGS_SYSTEM){
   11011:	8b 45 0c             	mov    0xc(%ebp),%eax
   11014:	83 e0 01             	and    $0x1,%eax
   11017:	85 c0                	test   %eax,%eax
   11019:	74 10                	je     1102b <tss_init+0x8d>
        code_sel=KERNEL_SELECTOR_CS;
   1101b:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%ebp)
        data_sel=KERNEL_SELECTOR_DS;
   11022:	c7 45 f0 10 00 00 00 	movl   $0x10,-0x10(%ebp)
   11029:	eb 16                	jmp    11041 <tss_init+0xa3>
    }
    else{
        code_sel=task_manager.app_code_sel | SEG_CPL3;
   1102b:	a1 b0 95 01 00       	mov    0x195b0,%eax
   11030:	83 c8 03             	or     $0x3,%eax
   11033:	89 45 f4             	mov    %eax,-0xc(%ebp)
        data_sel=task_manager.app_data_sel | SEG_CPL3;
   11036:	a1 b4 95 01 00       	mov    0x195b4,%eax
   1103b:	83 c8 03             	or     $0x3,%eax
   1103e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    task->tss.eip=entry;
   11041:	8b 45 08             	mov    0x8(%ebp),%eax
   11044:	8b 55 10             	mov    0x10(%ebp),%edx
   11047:	89 90 78 02 00 00    	mov    %edx,0x278(%eax)
    task->tss.esp=esp;
   1104d:	8b 45 08             	mov    0x8(%ebp),%eax
   11050:	8b 55 14             	mov    0x14(%ebp),%edx
   11053:	89 90 90 02 00 00    	mov    %edx,0x290(%eax)
    task->tss.esp0=kernel_stack+MEM_PAGE_SIZE;
   11059:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1105c:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
   11062:	8b 45 08             	mov    0x8(%ebp),%eax
   11065:	89 90 5c 02 00 00    	mov    %edx,0x25c(%eax)
    task->tss.ss=data_sel;
   1106b:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1106e:	8b 45 08             	mov    0x8(%ebp),%eax
   11071:	89 90 a8 02 00 00    	mov    %edx,0x2a8(%eax)
    task->tss.ss0=KERNEL_SELECTOR_DS;
   11077:	8b 45 08             	mov    0x8(%ebp),%eax
   1107a:	c7 80 60 02 00 00 10 	movl   $0x10,0x260(%eax)
   11081:	00 00 00 
    task->tss.es=task->tss.ds=task->tss.fs=task->tss.gs=data_sel;
   11084:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11087:	8b 45 08             	mov    0x8(%ebp),%eax
   1108a:	89 90 b4 02 00 00    	mov    %edx,0x2b4(%eax)
   11090:	8b 45 08             	mov    0x8(%ebp),%eax
   11093:	8b 90 b4 02 00 00    	mov    0x2b4(%eax),%edx
   11099:	8b 45 08             	mov    0x8(%ebp),%eax
   1109c:	89 90 b0 02 00 00    	mov    %edx,0x2b0(%eax)
   110a2:	8b 45 08             	mov    0x8(%ebp),%eax
   110a5:	8b 90 b0 02 00 00    	mov    0x2b0(%eax),%edx
   110ab:	8b 45 08             	mov    0x8(%ebp),%eax
   110ae:	89 90 ac 02 00 00    	mov    %edx,0x2ac(%eax)
   110b4:	8b 45 08             	mov    0x8(%ebp),%eax
   110b7:	8b 90 ac 02 00 00    	mov    0x2ac(%eax),%edx
   110bd:	8b 45 08             	mov    0x8(%ebp),%eax
   110c0:	89 90 a0 02 00 00    	mov    %edx,0x2a0(%eax)
    task->tss.cs=code_sel;
   110c6:	8b 55 f4             	mov    -0xc(%ebp),%edx
   110c9:	8b 45 08             	mov    0x8(%ebp),%eax
   110cc:	89 90 a4 02 00 00    	mov    %edx,0x2a4(%eax)
    task->tss.eflags=EFLAGS_DEFAULT | EFLAGS_IF;
   110d2:	8b 45 08             	mov    0x8(%ebp),%eax
   110d5:	c7 80 7c 02 00 00 02 	movl   $0x202,0x27c(%eax)
   110dc:	02 00 00 

    uint32_t page_dir=memory_create_uvm();
   110df:	e8 e4 f6 ff ff       	call   107c8 <memory_create_uvm>
   110e4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(page_dir == 0){
   110e7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   110eb:	74 22                	je     1110f <tss_init+0x171>
        goto tss_init_failed;
    }
    task->tss.cr3=page_dir;
   110ed:	8b 45 08             	mov    0x8(%ebp),%eax
   110f0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   110f3:	89 90 74 02 00 00    	mov    %edx,0x274(%eax)
    task->tss_sel=tss_sel;
   110f9:	8b 45 08             	mov    0x8(%ebp),%eax
   110fc:	8b 55 ec             	mov    -0x14(%ebp),%edx
   110ff:	89 90 c0 02 00 00    	mov    %edx,0x2c0(%eax)
    return 0;
   11105:	b8 00 00 00 00       	mov    $0x0,%eax
   1110a:	eb 2b                	jmp    11137 <tss_init+0x199>
        goto tss_init_failed;
   1110c:	90                   	nop
   1110d:	eb 01                	jmp    11110 <tss_init+0x172>
        goto tss_init_failed;
   1110f:	90                   	nop
tss_init_failed:
    gdt_free_sel(tss_sel);
   11110:	83 ec 0c             	sub    $0xc,%esp
   11113:	ff 75 ec             	pushl  -0x14(%ebp)
   11116:	e8 a2 11 00 00       	call   122bd <gdt_free_sel>
   1111b:	83 c4 10             	add    $0x10,%esp
    if(kernel_stack){
   1111e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11122:	74 0e                	je     11132 <tss_init+0x194>
        memory_free_page(kernel_stack);
   11124:	83 ec 0c             	sub    $0xc,%esp
   11127:	ff 75 e8             	pushl  -0x18(%ebp)
   1112a:	e8 2a f8 ff ff       	call   10959 <memory_free_page>
   1112f:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   11132:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
   11137:	c9                   	leave  
   11138:	c3                   	ret    

00011139 <task_init>:

int task_init(task_t* task,const char*name,int flag,uint32_t entry,uint32_t esp){
   11139:	55                   	push   %ebp
   1113a:	89 e5                	mov    %esp,%ebp
   1113c:	83 ec 18             	sub    $0x18,%esp
    ASSERT(task!=(task_t*)0);
   1113f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11143:	75 19                	jne    1115e <task_init+0x25>
   11145:	68 87 56 01 00       	push   $0x15687
   1114a:	68 98 57 01 00       	push   $0x15798
   1114f:	6a 41                	push   $0x41
   11151:	68 98 56 01 00       	push   $0x15698
   11156:	e8 57 3e 00 00       	call   14fb2 <panic>
   1115b:	83 c4 10             	add    $0x10,%esp
    int err=tss_init(task,flag,entry,esp);
   1115e:	ff 75 18             	pushl  0x18(%ebp)
   11161:	ff 75 14             	pushl  0x14(%ebp)
   11164:	ff 75 10             	pushl  0x10(%ebp)
   11167:	ff 75 08             	pushl  0x8(%ebp)
   1116a:	e8 2f fe ff ff       	call   10f9e <tss_init>
   1116f:	83 c4 10             	add    $0x10,%esp
   11172:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(err<0){
   11175:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11179:	79 18                	jns    11193 <task_init+0x5a>
        log_printf("init task failed.");
   1117b:	83 ec 0c             	sub    $0xc,%esp
   1117e:	68 cb 56 01 00       	push   $0x156cb
   11183:	e8 fa 40 00 00       	call   15282 <log_printf>
   11188:	83 c4 10             	add    $0x10,%esp
        return err;
   1118b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1118e:	e9 f0 00 00 00       	jmp    11283 <task_init+0x14a>
    }
    kernel_strncpy(task->name,name,TASK_NAME_SIZE);
   11193:	8b 45 08             	mov    0x8(%ebp),%eax
   11196:	83 c0 20             	add    $0x20,%eax
   11199:	83 ec 04             	sub    $0x4,%esp
   1119c:	6a 20                	push   $0x20
   1119e:	ff 75 0c             	pushl  0xc(%ebp)
   111a1:	50                   	push   %eax
   111a2:	e8 44 39 00 00       	call   14aeb <kernel_strncpy>
   111a7:	83 c4 10             	add    $0x10,%esp

    task->state=TASK_CREATED;
   111aa:	8b 45 08             	mov    0x8(%ebp),%eax
   111ad:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    task->time_ticks=TASK_TIME_SLICE_DEFAULT;
   111b3:	8b 45 08             	mov    0x8(%ebp),%eax
   111b6:	c7 40 1c 0a 00 00 00 	movl   $0xa,0x1c(%eax)
    task->slice_ticks=task->time_ticks;
   111bd:	8b 45 08             	mov    0x8(%ebp),%eax
   111c0:	8b 50 1c             	mov    0x1c(%eax),%edx
   111c3:	8b 45 08             	mov    0x8(%ebp),%eax
   111c6:	89 50 18             	mov    %edx,0x18(%eax)
    task->sleep_ticks=0;
   111c9:	8b 45 08             	mov    0x8(%ebp),%eax
   111cc:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
    
    list_node_init(&task->all_node);
   111d3:	8b 45 08             	mov    0x8(%ebp),%eax
   111d6:	05 48 02 00 00       	add    $0x248,%eax
   111db:	83 ec 0c             	sub    $0xc,%esp
   111de:	50                   	push   %eax
   111df:	e8 41 fd ff ff       	call   10f25 <list_node_init>
   111e4:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->run_node);
   111e7:	8b 45 08             	mov    0x8(%ebp),%eax
   111ea:	05 40 02 00 00       	add    $0x240,%eax
   111ef:	83 ec 0c             	sub    $0xc,%esp
   111f2:	50                   	push   %eax
   111f3:	e8 2d fd ff ff       	call   10f25 <list_node_init>
   111f8:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->wait_node);
   111fb:	8b 45 08             	mov    0x8(%ebp),%eax
   111fe:	05 50 02 00 00       	add    $0x250,%eax
   11203:	83 ec 0c             	sub    $0xc,%esp
   11206:	50                   	push   %eax
   11207:	e8 19 fd ff ff       	call   10f25 <list_node_init>
   1120c:	83 c4 10             	add    $0x10,%esp
    
    irq_state_t state=irq_enter_protection();
   1120f:	e8 0a 1a 00 00       	call   12c1e <irq_enter_protection>
   11214:	89 45 f0             	mov    %eax,-0x10(%ebp)

    task->pid=(uint32_t)task;
   11217:	8b 55 08             	mov    0x8(%ebp),%edx
   1121a:	8b 45 08             	mov    0x8(%ebp),%eax
   1121d:	89 50 04             	mov    %edx,0x4(%eax)
    task->parent=(task_t*)0;
   11220:	8b 45 08             	mov    0x8(%ebp),%eax
   11223:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    task->heap_start=0;
   1122a:	8b 45 08             	mov    0x8(%ebp),%eax
   1122d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    task->heap_end=0;
   11234:	8b 45 08             	mov    0x8(%ebp),%eax
   11237:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

    // 对task->file_table进行初始化
    kernel_memset(&task->file_table,0,sizeof(task->file_table));
   1123e:	8b 45 08             	mov    0x8(%ebp),%eax
   11241:	83 c0 40             	add    $0x40,%eax
   11244:	83 ec 04             	sub    $0x4,%esp
   11247:	68 00 02 00 00       	push   $0x200
   1124c:	6a 00                	push   $0x0
   1124e:	50                   	push   %eax
   1124f:	e8 0b 3a 00 00       	call   14c5f <kernel_memset>
   11254:	83 c4 10             	add    $0x10,%esp

    list_insert_last(&task_manager.task_list,&task->all_node);
   11257:	8b 45 08             	mov    0x8(%ebp),%eax
   1125a:	05 48 02 00 00       	add    $0x248,%eax
   1125f:	83 ec 08             	sub    $0x8,%esp
   11262:	50                   	push   %eax
   11263:	68 10 90 01 00       	push   $0x19010
   11268:	e8 85 3e 00 00       	call   150f2 <list_insert_last>
   1126d:	83 c4 10             	add    $0x10,%esp
    irq_leave_protection(state);
   11270:	83 ec 0c             	sub    $0xc,%esp
   11273:	ff 75 f0             	pushl  -0x10(%ebp)
   11276:	e8 bb 19 00 00       	call   12c36 <irq_leave_protection>
   1127b:	83 c4 10             	add    $0x10,%esp

    return 0;
   1127e:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11283:	c9                   	leave  
   11284:	c3                   	ret    

00011285 <task_start>:

void task_start(task_t* task){
   11285:	55                   	push   %ebp
   11286:	89 e5                	mov    %esp,%ebp
   11288:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   1128b:	e8 8e 19 00 00       	call   12c1e <irq_enter_protection>
   11290:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_set_ready(task);
   11293:	83 ec 0c             	sub    $0xc,%esp
   11296:	ff 75 08             	pushl  0x8(%ebp)
   11299:	e8 9f 02 00 00       	call   1153d <task_set_ready>
   1129e:	83 c4 10             	add    $0x10,%esp
    irq_leave_protection(state);
   112a1:	83 ec 0c             	sub    $0xc,%esp
   112a4:	ff 75 f4             	pushl  -0xc(%ebp)
   112a7:	e8 8a 19 00 00       	call   12c36 <irq_leave_protection>
   112ac:	83 c4 10             	add    $0x10,%esp
}
   112af:	90                   	nop
   112b0:	c9                   	leave  
   112b1:	c3                   	ret    

000112b2 <task_uninit>:

void task_uninit(task_t* task){
   112b2:	55                   	push   %ebp
   112b3:	89 e5                	mov    %esp,%ebp
   112b5:	83 ec 08             	sub    $0x8,%esp
    if(task->tss_sel){
   112b8:	8b 45 08             	mov    0x8(%ebp),%eax
   112bb:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
   112c1:	85 c0                	test   %eax,%eax
   112c3:	74 15                	je     112da <task_uninit+0x28>
        gdt_free_sel(task->tss_sel);
   112c5:	8b 45 08             	mov    0x8(%ebp),%eax
   112c8:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
   112ce:	83 ec 0c             	sub    $0xc,%esp
   112d1:	50                   	push   %eax
   112d2:	e8 e6 0f 00 00       	call   122bd <gdt_free_sel>
   112d7:	83 c4 10             	add    $0x10,%esp
    }

    if(task->tss.esp0){
   112da:	8b 45 08             	mov    0x8(%ebp),%eax
   112dd:	8b 80 5c 02 00 00    	mov    0x25c(%eax),%eax
   112e3:	85 c0                	test   %eax,%eax
   112e5:	74 1a                	je     11301 <task_uninit+0x4f>
        memory_free_page(task->tss.esp-MEM_PAGE_SIZE);
   112e7:	8b 45 08             	mov    0x8(%ebp),%eax
   112ea:	8b 80 90 02 00 00    	mov    0x290(%eax),%eax
   112f0:	2d 00 10 00 00       	sub    $0x1000,%eax
   112f5:	83 ec 0c             	sub    $0xc,%esp
   112f8:	50                   	push   %eax
   112f9:	e8 5b f6 ff ff       	call   10959 <memory_free_page>
   112fe:	83 c4 10             	add    $0x10,%esp
    }

    if(task->tss.cr3){
   11301:	8b 45 08             	mov    0x8(%ebp),%eax
   11304:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
   1130a:	85 c0                	test   %eax,%eax
   1130c:	74 15                	je     11323 <task_uninit+0x71>
        memory_destroy_uvm(task->tss.cr3);
   1130e:	8b 45 08             	mov    0x8(%ebp),%eax
   11311:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
   11317:	83 ec 0c             	sub    $0xc,%esp
   1131a:	50                   	push   %eax
   1131b:	e8 d2 f6 ff ff       	call   109f2 <memory_destroy_uvm>
   11320:	83 c4 10             	add    $0x10,%esp
    }

    kernel_memset(task,0,sizeof(task));
   11323:	83 ec 04             	sub    $0x4,%esp
   11326:	6a 04                	push   $0x4
   11328:	6a 00                	push   $0x0
   1132a:	ff 75 08             	pushl  0x8(%ebp)
   1132d:	e8 2d 39 00 00       	call   14c5f <kernel_memset>
   11332:	83 c4 10             	add    $0x10,%esp
}
   11335:	90                   	nop
   11336:	c9                   	leave  
   11337:	c3                   	ret    

00011338 <task_switch_from_to>:

void task_switch_from_to(task_t*from,task_t*to){
   11338:	55                   	push   %ebp
   11339:	89 e5                	mov    %esp,%ebp
   1133b:	83 ec 08             	sub    $0x8,%esp
    switch_to_tss(to->tss_sel);
   1133e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11341:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
   11347:	83 ec 0c             	sub    $0xc,%esp
   1134a:	50                   	push   %eax
   1134b:	e8 59 0f 00 00       	call   122a9 <switch_to_tss>
   11350:	83 c4 10             	add    $0x10,%esp
}
   11353:	90                   	nop
   11354:	c9                   	leave  
   11355:	c3                   	ret    

00011356 <idle_task_entry>:

static void idle_task_entry(void){
   11356:	55                   	push   %ebp
   11357:	89 e5                	mov    %esp,%ebp
    for(;;){
        hlt();
   11359:	e8 80 fb ff ff       	call   10ede <hlt>
   1135e:	eb f9                	jmp    11359 <idle_task_entry+0x3>

00011360 <task_manager_init>:
    }
}

void task_manager_init(void){
   11360:	55                   	push   %ebp
   11361:	89 e5                	mov    %esp,%ebp
   11363:	83 ec 18             	sub    $0x18,%esp

    kernel_memset(task_table,0,sizeof(task_table));
   11366:	83 ec 04             	sub    $0x4,%esp
   11369:	68 00 62 01 00       	push   $0x16200
   1136e:	6a 00                	push   $0x0
   11370:	68 c0 a5 01 00       	push   $0x1a5c0
   11375:	e8 e5 38 00 00       	call   14c5f <kernel_memset>
   1137a:	83 c4 10             	add    $0x10,%esp
    mutex_init(&table_mutex);
   1137d:	83 ec 0c             	sub    $0xc,%esp
   11380:	68 c0 07 03 00       	push   $0x307c0
   11385:	e8 dd 31 00 00       	call   14567 <mutex_init>
   1138a:	83 c4 10             	add    $0x10,%esp

    int sel=gdt_alloc_desc();
   1138d:	e8 a2 0e 00 00       	call   12234 <gdt_alloc_desc>
   11392:	89 45 f4             	mov    %eax,-0xc(%ebp)
    segment_desc_set(sel,0x0,0xFFFFFFFF,
   11395:	68 f2 40 00 00       	push   $0x40f2
   1139a:	6a ff                	push   $0xffffffff
   1139c:	6a 00                	push   $0x0
   1139e:	ff 75 f4             	pushl  -0xc(%ebp)
   113a1:	e8 18 0d 00 00       	call   120be <segment_desc_set>
   113a6:	83 c4 10             	add    $0x10,%esp
        SEG_P_PRESENT | SEG_DPL3 | SEG_S_NORMAL | SEG_TYPE_DATA | SEG_TYPE_RW | SEG_D
    );
    task_manager.app_data_sel=sel;
   113a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   113ac:	a3 b4 95 01 00       	mov    %eax,0x195b4

    sel=gdt_alloc_desc();
   113b1:	e8 7e 0e 00 00       	call   12234 <gdt_alloc_desc>
   113b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    segment_desc_set(sel,0x0,0xFFFFFFFF,
   113b9:	68 fa 40 00 00       	push   $0x40fa
   113be:	6a ff                	push   $0xffffffff
   113c0:	6a 00                	push   $0x0
   113c2:	ff 75 f4             	pushl  -0xc(%ebp)
   113c5:	e8 f4 0c 00 00       	call   120be <segment_desc_set>
   113ca:	83 c4 10             	add    $0x10,%esp
           SEG_P_PRESENT | SEG_DPL3 | SEG_S_NORMAL |SEG_TYPE_CODE | SEG_TYPE_RW | SEG_D
    );
    task_manager.app_code_sel=sel;
   113cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   113d0:	a3 b0 95 01 00       	mov    %eax,0x195b0

    list_init(&task_manager.ready_list);
   113d5:	83 ec 0c             	sub    $0xc,%esp
   113d8:	68 04 90 01 00       	push   $0x19004
   113dd:	e8 8c 3c 00 00       	call   1506e <list_init>
   113e2:	83 c4 10             	add    $0x10,%esp
    list_init(&task_manager.task_list);
   113e5:	83 ec 0c             	sub    $0xc,%esp
   113e8:	68 10 90 01 00       	push   $0x19010
   113ed:	e8 7c 3c 00 00       	call   1506e <list_init>
   113f2:	83 c4 10             	add    $0x10,%esp
    list_init(&task_manager.sleep_list);
   113f5:	83 ec 0c             	sub    $0xc,%esp
   113f8:	68 1c 90 01 00       	push   $0x1901c
   113fd:	e8 6c 3c 00 00       	call   1506e <list_init>
   11402:	83 c4 10             	add    $0x10,%esp
    task_manager.curr_task=(task_t*)0;
   11405:	c7 05 00 90 01 00 00 	movl   $0x0,0x19000
   1140c:	00 00 00 
    task_init(&task_manager.idle_task,"idle_task",TASK_FLAGS_SYSTEM,(uint32_t)idle_task_entry,
    (uint32_t)(idle_task_stack+IDLE_TASK_SIZE));
   1140f:	b8 c0 a5 01 00       	mov    $0x1a5c0,%eax
    task_init(&task_manager.idle_task,"idle_task",TASK_FLAGS_SYSTEM,(uint32_t)idle_task_entry,
   11414:	89 c2                	mov    %eax,%edx
   11416:	b8 56 13 01 00       	mov    $0x11356,%eax
   1141b:	83 ec 0c             	sub    $0xc,%esp
   1141e:	52                   	push   %edx
   1141f:	50                   	push   %eax
   11420:	6a 01                	push   $0x1
   11422:	68 dd 56 01 00       	push   $0x156dd
   11427:	68 ec 92 01 00       	push   $0x192ec
   1142c:	e8 08 fd ff ff       	call   11139 <task_init>
   11431:	83 c4 20             	add    $0x20,%esp

    task_start(&task_manager.idle_task);
   11434:	83 ec 0c             	sub    $0xc,%esp
   11437:	68 ec 92 01 00       	push   $0x192ec
   1143c:	e8 44 fe ff ff       	call   11285 <task_start>
   11441:	83 c4 10             	add    $0x10,%esp
}
   11444:	90                   	nop
   11445:	c9                   	leave  
   11446:	c3                   	ret    

00011447 <task_first_init>:

void task_first_init(void){
   11447:	55                   	push   %ebp
   11448:	89 e5                	mov    %esp,%ebp
   1144a:	83 ec 18             	sub    $0x18,%esp
    void first_task_entry(void);
    extern uint8_t s_first_task[],e_first_task[];

    uint32_t copy_size=(uint32_t)(e_first_task-s_first_task);
   1144d:	ba c4 b6 06 00       	mov    $0x6b6c4,%edx
   11452:	b8 00 b3 06 00       	mov    $0x6b300,%eax
   11457:	29 c2                	sub    %eax,%edx
   11459:	89 d0                	mov    %edx,%eax
   1145b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t alloc_size=10*MEM_PAGE_SIZE;
   1145e:	c7 45 f0 00 a0 00 00 	movl   $0xa000,-0x10(%ebp)
    ASSERT(copy_size < alloc_size);
   11465:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11468:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   1146b:	72 1c                	jb     11489 <task_first_init+0x42>
   1146d:	68 e7 56 01 00       	push   $0x156e7
   11472:	68 a4 57 01 00       	push   $0x157a4
   11477:	68 a3 00 00 00       	push   $0xa3
   1147c:	68 98 56 01 00       	push   $0x15698
   11481:	e8 2c 3b 00 00       	call   14fb2 <panic>
   11486:	83 c4 10             	add    $0x10,%esp

    uint32_t first_start=(uint32_t)first_task_entry;
   11489:	c7 45 ec 00 00 00 80 	movl   $0x80000000,-0x14(%ebp)

    task_init(&task_manager.first_task,"first task",0,first_start,first_start+alloc_size);
   11490:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11493:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11496:	01 d0                	add    %edx,%eax
   11498:	83 ec 0c             	sub    $0xc,%esp
   1149b:	50                   	push   %eax
   1149c:	ff 75 ec             	pushl  -0x14(%ebp)
   1149f:	6a 00                	push   $0x0
   114a1:	68 fe 56 01 00       	push   $0x156fe
   114a6:	68 28 90 01 00       	push   $0x19028
   114ab:	e8 89 fc ff ff       	call   11139 <task_init>
   114b0:	83 c4 20             	add    $0x20,%esp

    task_manager.first_task.heap_start=(uint32_t)e_first_task;
   114b3:	b8 c4 b6 06 00       	mov    $0x6b6c4,%eax
   114b8:	a3 34 90 01 00       	mov    %eax,0x19034
    task_manager.first_task.heap_end=(uint32_t)e_first_task;
   114bd:	b8 c4 b6 06 00       	mov    $0x6b6c4,%eax
   114c2:	a3 38 90 01 00       	mov    %eax,0x19038

    write_tr(task_manager.first_task.tss_sel);
   114c7:	a1 e8 92 01 00       	mov    0x192e8,%eax
   114cc:	0f b7 c0             	movzwl %ax,%eax
   114cf:	83 ec 0c             	sub    $0xc,%esp
   114d2:	50                   	push   %eax
   114d3:	e8 0d fa ff ff       	call   10ee5 <write_tr>
   114d8:	83 c4 10             	add    $0x10,%esp
    task_manager.curr_task=&task_manager.first_task;
   114db:	c7 05 00 90 01 00 28 	movl   $0x19028,0x19000
   114e2:	90 01 00 

    mmu_set_page_dir(task_manager.first_task.tss.cr3);
   114e5:	a1 9c 92 01 00       	mov    0x1929c,%eax
   114ea:	83 ec 0c             	sub    $0xc,%esp
   114ed:	50                   	push   %eax
   114ee:	e8 6d fa ff ff       	call   10f60 <mmu_set_page_dir>
   114f3:	83 c4 10             	add    $0x10,%esp

    memory_alloc_page_for(first_start,alloc_size,PTE_P | PTE_W | PTE_U);
   114f6:	83 ec 04             	sub    $0x4,%esp
   114f9:	6a 07                	push   $0x7
   114fb:	ff 75 f0             	pushl  -0x10(%ebp)
   114fe:	ff 75 ec             	pushl  -0x14(%ebp)
   11501:	e8 fb f3 ff ff       	call   10901 <memory_alloc_page_for>
   11506:	83 c4 10             	add    $0x10,%esp
    kernel_memcpy((void*)first_start,s_first_task,copy_size);
   11509:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1150c:	83 ec 04             	sub    $0x4,%esp
   1150f:	ff 75 f4             	pushl  -0xc(%ebp)
   11512:	68 00 b3 06 00       	push   $0x6b300
   11517:	50                   	push   %eax
   11518:	e8 f3 36 00 00       	call   14c10 <kernel_memcpy>
   1151d:	83 c4 10             	add    $0x10,%esp

    task_start(&task_manager.first_task);
   11520:	83 ec 0c             	sub    $0xc,%esp
   11523:	68 28 90 01 00       	push   $0x19028
   11528:	e8 58 fd ff ff       	call   11285 <task_start>
   1152d:	83 c4 10             	add    $0x10,%esp
}
   11530:	90                   	nop
   11531:	c9                   	leave  
   11532:	c3                   	ret    

00011533 <task_first_task>:

task_t* task_first_task(void){
   11533:	55                   	push   %ebp
   11534:	89 e5                	mov    %esp,%ebp
    return &task_manager.first_task;
   11536:	b8 28 90 01 00       	mov    $0x19028,%eax
}
   1153b:	5d                   	pop    %ebp
   1153c:	c3                   	ret    

0001153d <task_set_ready>:

void task_set_ready(task_t* task){
   1153d:	55                   	push   %ebp
   1153e:	89 e5                	mov    %esp,%ebp
   11540:	83 ec 08             	sub    $0x8,%esp
    if(task==&task_manager.idle_task){
   11543:	81 7d 08 ec 92 01 00 	cmpl   $0x192ec,0x8(%ebp)
   1154a:	74 24                	je     11570 <task_set_ready+0x33>
        return;
    }
    list_insert_last(&task_manager.ready_list,&task->run_node);
   1154c:	8b 45 08             	mov    0x8(%ebp),%eax
   1154f:	05 40 02 00 00       	add    $0x240,%eax
   11554:	83 ec 08             	sub    $0x8,%esp
   11557:	50                   	push   %eax
   11558:	68 04 90 01 00       	push   $0x19004
   1155d:	e8 90 3b 00 00       	call   150f2 <list_insert_last>
   11562:	83 c4 10             	add    $0x10,%esp
    task->state=TASK_READY;
   11565:	8b 45 08             	mov    0x8(%ebp),%eax
   11568:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   1156e:	eb 01                	jmp    11571 <task_set_ready+0x34>
        return;
   11570:	90                   	nop
}
   11571:	c9                   	leave  
   11572:	c3                   	ret    

00011573 <task_set_block>:

void task_set_block(task_t* task){
   11573:	55                   	push   %ebp
   11574:	89 e5                	mov    %esp,%ebp
   11576:	83 ec 08             	sub    $0x8,%esp
    if(task==&task_manager.idle_task){
   11579:	81 7d 08 ec 92 01 00 	cmpl   $0x192ec,0x8(%ebp)
   11580:	74 1b                	je     1159d <task_set_block+0x2a>
        return;
    }
    list_remove(&task_manager.ready_list,&task->run_node);
   11582:	8b 45 08             	mov    0x8(%ebp),%eax
   11585:	05 40 02 00 00       	add    $0x240,%eax
   1158a:	83 ec 08             	sub    $0x8,%esp
   1158d:	50                   	push   %eax
   1158e:	68 04 90 01 00       	push   $0x19004
   11593:	e8 36 3c 00 00       	call   151ce <list_remove>
   11598:	83 c4 10             	add    $0x10,%esp
   1159b:	eb 01                	jmp    1159e <task_set_block+0x2b>
        return;
   1159d:	90                   	nop
}
   1159e:	c9                   	leave  
   1159f:	c3                   	ret    

000115a0 <task_next_run>:

task_t* task_next_run(void){
   115a0:	55                   	push   %ebp
   115a1:	89 e5                	mov    %esp,%ebp
   115a3:	83 ec 10             	sub    $0x10,%esp
    if(list_count(&task_manager.ready_list)==0){
   115a6:	68 04 90 01 00       	push   $0x19004
   115ab:	e8 9b f9 ff ff       	call   10f4b <list_count>
   115b0:	83 c4 04             	add    $0x4,%esp
   115b3:	85 c0                	test   %eax,%eax
   115b5:	75 07                	jne    115be <task_next_run+0x1e>
        return &task_manager.idle_task;
   115b7:	b8 ec 92 01 00       	mov    $0x192ec,%eax
   115bc:	eb 25                	jmp    115e3 <task_next_run+0x43>
    }
    list_node_t* task_node=list_first(&task_manager.ready_list);
   115be:	68 04 90 01 00       	push   $0x19004
   115c3:	e8 8e f9 ff ff       	call   10f56 <list_first>
   115c8:	83 c4 04             	add    $0x4,%esp
   115cb:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return list_node_parent(task_node,task_t,run_node);
   115ce:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   115d2:	74 0a                	je     115de <task_next_run+0x3e>
   115d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
   115d7:	2d 40 02 00 00       	sub    $0x240,%eax
   115dc:	eb 05                	jmp    115e3 <task_next_run+0x43>
   115de:	b8 00 00 00 00       	mov    $0x0,%eax
}
   115e3:	c9                   	leave  
   115e4:	c3                   	ret    

000115e5 <task_current>:

task_t* task_current(void){
   115e5:	55                   	push   %ebp
   115e6:	89 e5                	mov    %esp,%ebp
    return task_manager.curr_task;
   115e8:	a1 00 90 01 00       	mov    0x19000,%eax
}
   115ed:	5d                   	pop    %ebp
   115ee:	c3                   	ret    

000115ef <sys_sched_yield>:

int sys_sched_yield(void){
   115ef:	55                   	push   %ebp
   115f0:	89 e5                	mov    %esp,%ebp
   115f2:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   115f5:	e8 24 16 00 00       	call   12c1e <irq_enter_protection>
   115fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(list_count(&task_manager.ready_list)>1){
   115fd:	83 ec 0c             	sub    $0xc,%esp
   11600:	68 04 90 01 00       	push   $0x19004
   11605:	e8 41 f9 ff ff       	call   10f4b <list_count>
   1160a:	83 c4 10             	add    $0x10,%esp
   1160d:	83 f8 01             	cmp    $0x1,%eax
   11610:	7e 29                	jle    1163b <sys_sched_yield+0x4c>
        task_t* curr_task=task_current();
   11612:	e8 ce ff ff ff       	call   115e5 <task_current>
   11617:	89 45 f0             	mov    %eax,-0x10(%ebp)

        task_set_block(curr_task);
   1161a:	83 ec 0c             	sub    $0xc,%esp
   1161d:	ff 75 f0             	pushl  -0x10(%ebp)
   11620:	e8 4e ff ff ff       	call   11573 <task_set_block>
   11625:	83 c4 10             	add    $0x10,%esp
        task_set_ready(curr_task);
   11628:	83 ec 0c             	sub    $0xc,%esp
   1162b:	ff 75 f0             	pushl  -0x10(%ebp)
   1162e:	e8 0a ff ff ff       	call   1153d <task_set_ready>
   11633:	83 c4 10             	add    $0x10,%esp

        task_dispatch();
   11636:	e8 15 00 00 00       	call   11650 <task_dispatch>
    }
    irq_leave_protection(state);
   1163b:	83 ec 0c             	sub    $0xc,%esp
   1163e:	ff 75 f4             	pushl  -0xc(%ebp)
   11641:	e8 f0 15 00 00       	call   12c36 <irq_leave_protection>
   11646:	83 c4 10             	add    $0x10,%esp
    return 0;
   11649:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1164e:	c9                   	leave  
   1164f:	c3                   	ret    

00011650 <task_dispatch>:

void task_dispatch(void){
   11650:	55                   	push   %ebp
   11651:	89 e5                	mov    %esp,%ebp
   11653:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   11656:	e8 c3 15 00 00       	call   12c1e <irq_enter_protection>
   1165b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t* to=task_next_run();
   1165e:	e8 3d ff ff ff       	call   115a0 <task_next_run>
   11663:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(to!=task_manager.curr_task){
   11666:	a1 00 90 01 00       	mov    0x19000,%eax
   1166b:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1166e:	74 2a                	je     1169a <task_dispatch+0x4a>
        task_t* from=task_current();
   11670:	e8 70 ff ff ff       	call   115e5 <task_current>
   11675:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_manager.curr_task=to;
   11678:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1167b:	a3 00 90 01 00       	mov    %eax,0x19000
        to->state=TASK_RUNNING;
   11680:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11683:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        task_switch_from_to(from,to);
   11689:	83 ec 08             	sub    $0x8,%esp
   1168c:	ff 75 f0             	pushl  -0x10(%ebp)
   1168f:	ff 75 ec             	pushl  -0x14(%ebp)
   11692:	e8 a1 fc ff ff       	call   11338 <task_switch_from_to>
   11697:	83 c4 10             	add    $0x10,%esp
    }
    irq_leave_protection(state);
   1169a:	83 ec 0c             	sub    $0xc,%esp
   1169d:	ff 75 f4             	pushl  -0xc(%ebp)
   116a0:	e8 91 15 00 00       	call   12c36 <irq_leave_protection>
   116a5:	83 c4 10             	add    $0x10,%esp
}
   116a8:	90                   	nop
   116a9:	c9                   	leave  
   116aa:	c3                   	ret    

000116ab <task_time_tick>:

void task_time_tick(void){
   116ab:	55                   	push   %ebp
   116ac:	89 e5                	mov    %esp,%ebp
   116ae:	83 ec 28             	sub    $0x28,%esp
    irq_state_t state=irq_enter_protection();
   116b1:	e8 68 15 00 00       	call   12c1e <irq_enter_protection>
   116b6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    task_t* curr_task=task_current();
   116b9:	e8 27 ff ff ff       	call   115e5 <task_current>
   116be:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(--curr_task->slice_ticks==0){
   116c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116c4:	8b 40 18             	mov    0x18(%eax),%eax
   116c7:	8d 50 ff             	lea    -0x1(%eax),%edx
   116ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116cd:	89 50 18             	mov    %edx,0x18(%eax)
   116d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116d3:	8b 40 18             	mov    0x18(%eax),%eax
   116d6:	85 c0                	test   %eax,%eax
   116d8:	75 28                	jne    11702 <task_time_tick+0x57>
        curr_task->slice_ticks=curr_task->time_ticks;
   116da:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116dd:	8b 50 1c             	mov    0x1c(%eax),%edx
   116e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116e3:	89 50 18             	mov    %edx,0x18(%eax)
        task_set_block(curr_task);
   116e6:	83 ec 0c             	sub    $0xc,%esp
   116e9:	ff 75 ec             	pushl  -0x14(%ebp)
   116ec:	e8 82 fe ff ff       	call   11573 <task_set_block>
   116f1:	83 c4 10             	add    $0x10,%esp
        task_set_ready(curr_task);
   116f4:	83 ec 0c             	sub    $0xc,%esp
   116f7:	ff 75 ec             	pushl  -0x14(%ebp)
   116fa:	e8 3e fe ff ff       	call   1153d <task_set_ready>
   116ff:	83 c4 10             	add    $0x10,%esp
    }
    list_node_t* curr=list_first(&task_manager.sleep_list);
   11702:	83 ec 0c             	sub    $0xc,%esp
   11705:	68 1c 90 01 00       	push   $0x1901c
   1170a:	e8 47 f8 ff ff       	call   10f56 <list_first>
   1170f:	83 c4 10             	add    $0x10,%esp
   11712:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while(curr){
   11715:	eb 64                	jmp    1177b <task_time_tick+0xd0>
        list_node_t*next=list_node_next(curr);
   11717:	83 ec 0c             	sub    $0xc,%esp
   1171a:	ff 75 f4             	pushl  -0xc(%ebp)
   1171d:	e8 1e f8 ff ff       	call   10f40 <list_node_next>
   11722:	83 c4 10             	add    $0x10,%esp
   11725:	89 45 e8             	mov    %eax,-0x18(%ebp)
        task_t* task=list_node_parent(curr,task_t,run_node);
   11728:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1172c:	74 0a                	je     11738 <task_time_tick+0x8d>
   1172e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11731:	2d 40 02 00 00       	sub    $0x240,%eax
   11736:	eb 05                	jmp    1173d <task_time_tick+0x92>
   11738:	b8 00 00 00 00       	mov    $0x0,%eax
   1173d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(--task->sleep_ticks==0){
   11740:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11743:	8b 40 14             	mov    0x14(%eax),%eax
   11746:	8d 50 ff             	lea    -0x1(%eax),%edx
   11749:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1174c:	89 50 14             	mov    %edx,0x14(%eax)
   1174f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11752:	8b 40 14             	mov    0x14(%eax),%eax
   11755:	85 c0                	test   %eax,%eax
   11757:	75 1c                	jne    11775 <task_time_tick+0xca>
            task_set_wakeup(task);
   11759:	83 ec 0c             	sub    $0xc,%esp
   1175c:	ff 75 e4             	pushl  -0x1c(%ebp)
   1175f:	e8 6f 00 00 00       	call   117d3 <task_set_wakeup>
   11764:	83 c4 10             	add    $0x10,%esp
            task_set_ready(task);
   11767:	83 ec 0c             	sub    $0xc,%esp
   1176a:	ff 75 e4             	pushl  -0x1c(%ebp)
   1176d:	e8 cb fd ff ff       	call   1153d <task_set_ready>
   11772:	83 c4 10             	add    $0x10,%esp
        }
        curr=next;
   11775:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11778:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while(curr){
   1177b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1177f:	75 96                	jne    11717 <task_time_tick+0x6c>
    }
    task_dispatch();
   11781:	e8 ca fe ff ff       	call   11650 <task_dispatch>
    irq_leave_protection(state);
   11786:	83 ec 0c             	sub    $0xc,%esp
   11789:	ff 75 f0             	pushl  -0x10(%ebp)
   1178c:	e8 a5 14 00 00       	call   12c36 <irq_leave_protection>
   11791:	83 c4 10             	add    $0x10,%esp
}
   11794:	90                   	nop
   11795:	c9                   	leave  
   11796:	c3                   	ret    

00011797 <task_set_sleep>:

void task_set_sleep(task_t* task,uint32_t ticks){
   11797:	55                   	push   %ebp
   11798:	89 e5                	mov    %esp,%ebp
   1179a:	83 ec 08             	sub    $0x8,%esp
    if(ticks==0){
   1179d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   117a1:	74 2d                	je     117d0 <task_set_sleep+0x39>
        return;
    }
    task->sleep_ticks=ticks;
   117a3:	8b 55 0c             	mov    0xc(%ebp),%edx
   117a6:	8b 45 08             	mov    0x8(%ebp),%eax
   117a9:	89 50 14             	mov    %edx,0x14(%eax)
    task->state=TASK_SLEEP;
   117ac:	8b 45 08             	mov    0x8(%ebp),%eax
   117af:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    list_insert_last(&task_manager.sleep_list,&task->run_node);
   117b5:	8b 45 08             	mov    0x8(%ebp),%eax
   117b8:	05 40 02 00 00       	add    $0x240,%eax
   117bd:	83 ec 08             	sub    $0x8,%esp
   117c0:	50                   	push   %eax
   117c1:	68 1c 90 01 00       	push   $0x1901c
   117c6:	e8 27 39 00 00       	call   150f2 <list_insert_last>
   117cb:	83 c4 10             	add    $0x10,%esp
   117ce:	eb 01                	jmp    117d1 <task_set_sleep+0x3a>
        return;
   117d0:	90                   	nop
}
   117d1:	c9                   	leave  
   117d2:	c3                   	ret    

000117d3 <task_set_wakeup>:

void task_set_wakeup(task_t* task){
   117d3:	55                   	push   %ebp
   117d4:	89 e5                	mov    %esp,%ebp
   117d6:	83 ec 08             	sub    $0x8,%esp
    list_remove(&task_manager.sleep_list,&task->run_node);
   117d9:	8b 45 08             	mov    0x8(%ebp),%eax
   117dc:	05 40 02 00 00       	add    $0x240,%eax
   117e1:	83 ec 08             	sub    $0x8,%esp
   117e4:	50                   	push   %eax
   117e5:	68 1c 90 01 00       	push   $0x1901c
   117ea:	e8 df 39 00 00       	call   151ce <list_remove>
   117ef:	83 c4 10             	add    $0x10,%esp
}
   117f2:	90                   	nop
   117f3:	c9                   	leave  
   117f4:	c3                   	ret    

000117f5 <sys_msleep>:

void sys_msleep (uint32_t ms) {
   117f5:	55                   	push   %ebp
   117f6:	89 e5                	mov    %esp,%ebp
   117f8:	83 ec 18             	sub    $0x18,%esp
    if (ms < OS_TICK_MS) {
   117fb:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
   117ff:	77 07                	ja     11808 <sys_msleep+0x13>
        ms = OS_TICK_MS;
   11801:	c7 45 08 0a 00 00 00 	movl   $0xa,0x8(%ebp)
    }

    irq_state_t state = irq_enter_protection();
   11808:	e8 11 14 00 00       	call   12c1e <irq_enter_protection>
   1180d:	89 45 f4             	mov    %eax,-0xc(%ebp)

    task_set_block(task_manager.curr_task);
   11810:	a1 00 90 01 00       	mov    0x19000,%eax
   11815:	83 ec 0c             	sub    $0xc,%esp
   11818:	50                   	push   %eax
   11819:	e8 55 fd ff ff       	call   11573 <task_set_block>
   1181e:	83 c4 10             	add    $0x10,%esp
    task_set_sleep(task_manager.curr_task, (ms + (OS_TICK_MS - 1))/ OS_TICK_MS);
   11821:	8b 45 08             	mov    0x8(%ebp),%eax
   11824:	83 c0 09             	add    $0x9,%eax
   11827:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
   1182c:	f7 e2                	mul    %edx
   1182e:	c1 ea 03             	shr    $0x3,%edx
   11831:	a1 00 90 01 00       	mov    0x19000,%eax
   11836:	83 ec 08             	sub    $0x8,%esp
   11839:	52                   	push   %edx
   1183a:	50                   	push   %eax
   1183b:	e8 57 ff ff ff       	call   11797 <task_set_sleep>
   11840:	83 c4 10             	add    $0x10,%esp
    
    task_dispatch();
   11843:	e8 08 fe ff ff       	call   11650 <task_dispatch>

    irq_leave_protection(state);
   11848:	83 ec 0c             	sub    $0xc,%esp
   1184b:	ff 75 f4             	pushl  -0xc(%ebp)
   1184e:	e8 e3 13 00 00       	call   12c36 <irq_leave_protection>
   11853:	83 c4 10             	add    $0x10,%esp
}
   11856:	90                   	nop
   11857:	c9                   	leave  
   11858:	c3                   	ret    

00011859 <sys_getpid>:

int sys_getpid(void){
   11859:	55                   	push   %ebp
   1185a:	89 e5                	mov    %esp,%ebp
   1185c:	83 ec 10             	sub    $0x10,%esp
    task_t* task=task_current();
   1185f:	e8 81 fd ff ff       	call   115e5 <task_current>
   11864:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return task->pid;
   11867:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1186a:	8b 40 04             	mov    0x4(%eax),%eax
}
   1186d:	c9                   	leave  
   1186e:	c3                   	ret    

0001186f <alloc_task>:

static task_t* alloc_task(void){
   1186f:	55                   	push   %ebp
   11870:	89 e5                	mov    %esp,%ebp
   11872:	83 ec 18             	sub    $0x18,%esp
    task_t* task=(task_t*)0;
   11875:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    mutex_lock(&table_mutex);
   1187c:	83 ec 0c             	sub    $0xc,%esp
   1187f:	68 c0 07 03 00       	push   $0x307c0
   11884:	e8 0c 2d 00 00       	call   14595 <mutex_lock>
   11889:	83 c4 10             	add    $0x10,%esp
    for(int i=0;i<TASK_NR;i++){
   1188c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11893:	eb 27                	jmp    118bc <alloc_task+0x4d>
        task_t* curr=task_table+i;
   11895:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11898:	69 c0 c4 02 00 00    	imul   $0x2c4,%eax,%eax
   1189e:	05 c0 a5 01 00       	add    $0x1a5c0,%eax
   118a3:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(curr->pid==0){
   118a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   118a9:	8b 40 04             	mov    0x4(%eax),%eax
   118ac:	85 c0                	test   %eax,%eax
   118ae:	75 08                	jne    118b8 <alloc_task+0x49>
            task=curr;
   118b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   118b3:	89 45 f4             	mov    %eax,-0xc(%ebp)
            break;
   118b6:	eb 0a                	jmp    118c2 <alloc_task+0x53>
    for(int i=0;i<TASK_NR;i++){
   118b8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   118bc:	83 7d f0 7f          	cmpl   $0x7f,-0x10(%ebp)
   118c0:	7e d3                	jle    11895 <alloc_task+0x26>
        }
    }   
    mutex_unlock(&table_mutex);
   118c2:	83 ec 0c             	sub    $0xc,%esp
   118c5:	68 c0 07 03 00       	push   $0x307c0
   118ca:	e8 55 2d 00 00       	call   14624 <mutex_unlock>
   118cf:	83 c4 10             	add    $0x10,%esp

    return task;
   118d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   118d5:	c9                   	leave  
   118d6:	c3                   	ret    

000118d7 <free_task>:

static void free_task(task_t* task){
   118d7:	55                   	push   %ebp
   118d8:	89 e5                	mov    %esp,%ebp
   118da:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&table_mutex);
   118dd:	83 ec 0c             	sub    $0xc,%esp
   118e0:	68 c0 07 03 00       	push   $0x307c0
   118e5:	e8 ab 2c 00 00       	call   14595 <mutex_lock>
   118ea:	83 c4 10             	add    $0x10,%esp
    task->pid=0;
   118ed:	8b 45 08             	mov    0x8(%ebp),%eax
   118f0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    mutex_unlock(&table_mutex);
   118f7:	83 ec 0c             	sub    $0xc,%esp
   118fa:	68 c0 07 03 00       	push   $0x307c0
   118ff:	e8 20 2d 00 00       	call   14624 <mutex_unlock>
   11904:	83 c4 10             	add    $0x10,%esp
}
   11907:	90                   	nop
   11908:	c9                   	leave  
   11909:	c3                   	ret    

0001190a <sys_fork>:

int sys_fork(void){
   1190a:	55                   	push   %ebp
   1190b:	89 e5                	mov    %esp,%ebp
   1190d:	83 ec 28             	sub    $0x28,%esp
    task_t* parent_task=task_current();
   11910:	e8 d0 fc ff ff       	call   115e5 <task_current>
   11915:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t* child_task=alloc_task();
   11918:	e8 52 ff ff ff       	call   1186f <alloc_task>
   1191d:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if(child_task==(task_t*)0){
   11920:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11924:	0f 84 24 01 00 00    	je     11a4e <sys_fork+0x144>
        goto fork_failed;
    }

    syscall_frame_t* frame=(syscall_frame_t*)(parent_task->tss.esp0-sizeof(syscall_frame_t));
   1192a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1192d:	8b 80 5c 02 00 00    	mov    0x25c(%eax),%eax
   11933:	83 e8 58             	sub    $0x58,%eax
   11936:	89 45 ec             	mov    %eax,-0x14(%ebp)
    int err=task_init(child_task,parent_task->name,0,frame->eip,frame->esp+sizeof(uint32_t)*SYSCALL_PARAM_COUNT);
   11939:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1193c:	8b 40 50             	mov    0x50(%eax),%eax
   1193f:	8d 48 14             	lea    0x14(%eax),%ecx
   11942:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11945:	8b 40 34             	mov    0x34(%eax),%eax
   11948:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1194b:	83 c2 20             	add    $0x20,%edx
   1194e:	83 ec 0c             	sub    $0xc,%esp
   11951:	51                   	push   %ecx
   11952:	50                   	push   %eax
   11953:	6a 00                	push   $0x0
   11955:	52                   	push   %edx
   11956:	ff 75 f0             	pushl  -0x10(%ebp)
   11959:	e8 db f7 ff ff       	call   11139 <task_init>
   1195e:	83 c4 20             	add    $0x20,%esp
   11961:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(err < 0){
   11964:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11968:	0f 88 e3 00 00 00    	js     11a51 <sys_fork+0x147>
        goto fork_failed;
    }

    tss_t* tss=&child_task->tss;
   1196e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11971:	05 58 02 00 00       	add    $0x258,%eax
   11976:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    tss->eax= 0;
   11979:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1197c:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
    tss->ebx=frame->ebx;
   11983:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11986:	8b 50 24             	mov    0x24(%eax),%edx
   11989:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1198c:	89 50 34             	mov    %edx,0x34(%eax)
    tss->ecx=frame->ecx;
   1198f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11992:	8b 50 2c             	mov    0x2c(%eax),%edx
   11995:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11998:	89 50 2c             	mov    %edx,0x2c(%eax)
    tss->edx=frame->edx;
   1199b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1199e:	8b 50 28             	mov    0x28(%eax),%edx
   119a1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119a4:	89 50 30             	mov    %edx,0x30(%eax)
    tss->esi=frame->esi;
   119a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119aa:	8b 50 18             	mov    0x18(%eax),%edx
   119ad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119b0:	89 50 40             	mov    %edx,0x40(%eax)
    tss->edi=frame->edi;
   119b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119b6:	8b 50 14             	mov    0x14(%eax),%edx
   119b9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119bc:	89 50 44             	mov    %edx,0x44(%eax)
    tss->ebp=frame->ebp;
   119bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119c2:	8b 50 1c             	mov    0x1c(%eax),%edx
   119c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119c8:	89 50 3c             	mov    %edx,0x3c(%eax)

    tss->cs=frame->cs;
   119cb:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119ce:	8b 50 38             	mov    0x38(%eax),%edx
   119d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119d4:	89 50 4c             	mov    %edx,0x4c(%eax)
    tss->ds=frame->ds;
   119d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119da:	8b 50 10             	mov    0x10(%eax),%edx
   119dd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119e0:	89 50 54             	mov    %edx,0x54(%eax)
    tss->es=frame->es;
   119e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119e6:	8b 50 0c             	mov    0xc(%eax),%edx
   119e9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119ec:	89 50 48             	mov    %edx,0x48(%eax)
    tss->fs=frame->fs;
   119ef:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119f2:	8b 50 08             	mov    0x8(%eax),%edx
   119f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119f8:	89 50 58             	mov    %edx,0x58(%eax)
    tss->gs=frame->gs;
   119fb:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119fe:	8b 50 04             	mov    0x4(%eax),%edx
   11a01:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11a04:	89 50 5c             	mov    %edx,0x5c(%eax)
    tss->eflags=frame->eflags;
   11a07:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11a0a:	8b 10                	mov    (%eax),%edx
   11a0c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11a0f:	89 50 24             	mov    %edx,0x24(%eax)

    child_task->parent=parent_task;
   11a12:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11a15:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11a18:	89 50 08             	mov    %edx,0x8(%eax)

    if((tss->cr3=memory_copy_uvm(parent_task->tss.cr3))<0){
   11a1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11a1e:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
   11a24:	83 ec 0c             	sub    $0xc,%esp
   11a27:	50                   	push   %eax
   11a28:	e8 ac f0 ff ff       	call   10ad9 <memory_copy_uvm>
   11a2d:	83 c4 10             	add    $0x10,%esp
   11a30:	89 c2                	mov    %eax,%edx
   11a32:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11a35:	89 50 1c             	mov    %edx,0x1c(%eax)
        goto fork_failed;
    }

    task_start(child_task);
   11a38:	83 ec 0c             	sub    $0xc,%esp
   11a3b:	ff 75 f0             	pushl  -0x10(%ebp)
   11a3e:	e8 42 f8 ff ff       	call   11285 <task_start>
   11a43:	83 c4 10             	add    $0x10,%esp

    return child_task->pid;
   11a46:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11a49:	8b 40 04             	mov    0x4(%eax),%eax
   11a4c:	eb 2b                	jmp    11a79 <sys_fork+0x16f>
        goto fork_failed;
   11a4e:	90                   	nop
   11a4f:	eb 01                	jmp    11a52 <sys_fork+0x148>
        goto fork_failed;
   11a51:	90                   	nop

fork_failed:
    if(child_task){
   11a52:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11a56:	74 1c                	je     11a74 <sys_fork+0x16a>
        task_uninit(child_task);
   11a58:	83 ec 0c             	sub    $0xc,%esp
   11a5b:	ff 75 f0             	pushl  -0x10(%ebp)
   11a5e:	e8 4f f8 ff ff       	call   112b2 <task_uninit>
   11a63:	83 c4 10             	add    $0x10,%esp
        free_task(child_task);
   11a66:	83 ec 0c             	sub    $0xc,%esp
   11a69:	ff 75 f0             	pushl  -0x10(%ebp)
   11a6c:	e8 66 fe ff ff       	call   118d7 <free_task>
   11a71:	83 c4 10             	add    $0x10,%esp
    }

    return -1;
   11a74:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   11a79:	c9                   	leave  
   11a7a:	c3                   	ret    

00011a7b <load_phdr>:

static int load_phdr(int file,Elf32_Phdr*phdr ,uint32_t page_dir){
   11a7b:	55                   	push   %ebp
   11a7c:	89 e5                	mov    %esp,%ebp
   11a7e:	83 ec 28             	sub    $0x28,%esp
    int err=memory_alloc_for_page_dir(page_dir,phdr->p_vaddr,phdr->p_memsz,PTE_P|PTE_U|PTE_W);
   11a81:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a84:	8b 50 14             	mov    0x14(%eax),%edx
   11a87:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a8a:	8b 40 08             	mov    0x8(%eax),%eax
   11a8d:	6a 07                	push   $0x7
   11a8f:	52                   	push   %edx
   11a90:	50                   	push   %eax
   11a91:	ff 75 10             	pushl  0x10(%ebp)
   11a94:	e8 b4 ed ff ff       	call   1084d <memory_alloc_for_page_dir>
   11a99:	83 c4 10             	add    $0x10,%esp
   11a9c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(err < 0){
   11a9f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11aa3:	79 1a                	jns    11abf <load_phdr+0x44>
        log_printf("no memory");
   11aa5:	83 ec 0c             	sub    $0xc,%esp
   11aa8:	68 09 57 01 00       	push   $0x15709
   11aad:	e8 d0 37 00 00       	call   15282 <log_printf>
   11ab2:	83 c4 10             	add    $0x10,%esp
        return -1;
   11ab5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11aba:	e9 b8 00 00 00       	jmp    11b77 <load_phdr+0xfc>
    }

    if(sys_lseek(file,phdr->p_offset,0)<0){
   11abf:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ac2:	8b 40 04             	mov    0x4(%eax),%eax
   11ac5:	83 ec 04             	sub    $0x4,%esp
   11ac8:	6a 00                	push   $0x0
   11aca:	50                   	push   %eax
   11acb:	ff 75 08             	pushl  0x8(%ebp)
   11ace:	e8 74 29 00 00       	call   14447 <sys_lseek>
   11ad3:	83 c4 10             	add    $0x10,%esp
   11ad6:	85 c0                	test   %eax,%eax
   11ad8:	79 1a                	jns    11af4 <load_phdr+0x79>
        log_printf("read file failed");
   11ada:	83 ec 0c             	sub    $0xc,%esp
   11add:	68 13 57 01 00       	push   $0x15713
   11ae2:	e8 9b 37 00 00       	call   15282 <log_printf>
   11ae7:	83 c4 10             	add    $0x10,%esp
        return -1;
   11aea:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11aef:	e9 83 00 00 00       	jmp    11b77 <load_phdr+0xfc>
    }

    uint32_t vaddr=phdr->p_vaddr;
   11af4:	8b 45 0c             	mov    0xc(%ebp),%eax
   11af7:	8b 40 08             	mov    0x8(%eax),%eax
   11afa:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t size=phdr->p_filesz;
   11afd:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b00:	8b 40 10             	mov    0x10(%eax),%eax
   11b03:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while(size > 0){
   11b06:	eb 64                	jmp    11b6c <load_phdr+0xf1>
        int curr_size=(size > MEM_PAGE_SIZE) ? MEM_PAGE_SIZE : size;
   11b08:	b8 00 10 00 00       	mov    $0x1000,%eax
   11b0d:	81 7d f0 00 10 00 00 	cmpl   $0x1000,-0x10(%ebp)
   11b14:	0f 46 45 f0          	cmovbe -0x10(%ebp),%eax
   11b18:	89 45 e8             	mov    %eax,-0x18(%ebp)
        uint32_t paddr=memory_get_paddr(page_dir,vaddr);
   11b1b:	83 ec 08             	sub    $0x8,%esp
   11b1e:	ff 75 f4             	pushl  -0xc(%ebp)
   11b21:	ff 75 10             	pushl  0x10(%ebp)
   11b24:	e8 05 f1 ff ff       	call   10c2e <memory_get_paddr>
   11b29:	83 c4 10             	add    $0x10,%esp
   11b2c:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        if(sys_read(file,(char*)paddr,curr_size)<curr_size){
   11b2f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11b32:	83 ec 04             	sub    $0x4,%esp
   11b35:	ff 75 e8             	pushl  -0x18(%ebp)
   11b38:	50                   	push   %eax
   11b39:	ff 75 08             	pushl  0x8(%ebp)
   11b3c:	e8 97 28 00 00       	call   143d8 <sys_read>
   11b41:	83 c4 10             	add    $0x10,%esp
   11b44:	39 45 e8             	cmp    %eax,-0x18(%ebp)
   11b47:	7e 17                	jle    11b60 <load_phdr+0xe5>
            log_printf("read file failed.");
   11b49:	83 ec 0c             	sub    $0xc,%esp
   11b4c:	68 24 57 01 00       	push   $0x15724
   11b51:	e8 2c 37 00 00       	call   15282 <log_printf>
   11b56:	83 c4 10             	add    $0x10,%esp
            return -1;
   11b59:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11b5e:	eb 17                	jmp    11b77 <load_phdr+0xfc>
        }

        size-=curr_size;
   11b60:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11b63:	29 45 f0             	sub    %eax,-0x10(%ebp)
        vaddr+=curr_size;
   11b66:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11b69:	01 45 f4             	add    %eax,-0xc(%ebp)
    while(size > 0){
   11b6c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11b70:	75 96                	jne    11b08 <load_phdr+0x8d>
    }

    return 0;
   11b72:	b8 00 00 00 00       	mov    $0x0,%eax

}
   11b77:	c9                   	leave  
   11b78:	c3                   	ret    

00011b79 <load_elf_file>:

static uint32_t load_elf_file(task_t* task,const char* name,uint32_t page_dir){
   11b79:	55                   	push   %ebp
   11b7a:	89 e5                	mov    %esp,%ebp
   11b7c:	83 ec 78             	sub    $0x78,%esp
    Elf32_Ehdr elf_hdr;
    Elf32_Phdr elf_phdr;

    int file=sys_open(name,0);
   11b7f:	83 ec 08             	sub    $0x8,%esp
   11b82:	6a 00                	push   $0x0
   11b84:	ff 75 0c             	pushl  0xc(%ebp)
   11b87:	e8 13 28 00 00       	call   1439f <sys_open>
   11b8c:	83 c4 10             	add    $0x10,%esp
   11b8f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(file<0){
   11b92:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11b96:	79 18                	jns    11bb0 <load_elf_file+0x37>
        log_printf("open failed. %s",name);
   11b98:	83 ec 08             	sub    $0x8,%esp
   11b9b:	ff 75 0c             	pushl  0xc(%ebp)
   11b9e:	68 36 57 01 00       	push   $0x15736
   11ba3:	e8 da 36 00 00       	call   15282 <log_printf>
   11ba8:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   11bab:	e9 6c 01 00 00       	jmp    11d1c <load_elf_file+0x1a3>
    }

    int cnt=sys_read(file,(char*)&elf_hdr,sizeof(elf_hdr));
   11bb0:	83 ec 04             	sub    $0x4,%esp
   11bb3:	6a 34                	push   $0x34
   11bb5:	8d 45 b0             	lea    -0x50(%ebp),%eax
   11bb8:	50                   	push   %eax
   11bb9:	ff 75 ec             	pushl  -0x14(%ebp)
   11bbc:	e8 17 28 00 00       	call   143d8 <sys_read>
   11bc1:	83 c4 10             	add    $0x10,%esp
   11bc4:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(cnt<sizeof(Elf32_Ehdr)){
   11bc7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11bca:	83 f8 33             	cmp    $0x33,%eax
   11bcd:	77 18                	ja     11be7 <load_elf_file+0x6e>
        log_printf("elf hdr too small. size=%d",cnt);
   11bcf:	83 ec 08             	sub    $0x8,%esp
   11bd2:	ff 75 e8             	pushl  -0x18(%ebp)
   11bd5:	68 46 57 01 00       	push   $0x15746
   11bda:	e8 a3 36 00 00       	call   15282 <log_printf>
   11bdf:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   11be2:	e9 35 01 00 00       	jmp    11d1c <load_elf_file+0x1a3>
    }

    if((elf_hdr.e_ident[0]!=0x7f)||(elf_hdr.e_ident[1]!='E')
   11be7:	0f b6 45 b0          	movzbl -0x50(%ebp),%eax
   11beb:	3c 7f                	cmp    $0x7f,%al
   11bed:	75 18                	jne    11c07 <load_elf_file+0x8e>
   11bef:	0f b6 45 b1          	movzbl -0x4f(%ebp),%eax
   11bf3:	3c 45                	cmp    $0x45,%al
   11bf5:	75 10                	jne    11c07 <load_elf_file+0x8e>
		|| (elf_hdr.e_ident[2]!='L')||(elf_hdr.e_ident[3]!='F')){
   11bf7:	0f b6 45 b2          	movzbl -0x4e(%ebp),%eax
   11bfb:	3c 4c                	cmp    $0x4c,%al
   11bfd:	75 08                	jne    11c07 <load_elf_file+0x8e>
   11bff:	0f b6 45 b3          	movzbl -0x4d(%ebp),%eax
   11c03:	3c 46                	cmp    $0x46,%al
   11c05:	74 15                	je     11c1c <load_elf_file+0xa3>
            log_printf("check elf ident failed.");
   11c07:	83 ec 0c             	sub    $0xc,%esp
   11c0a:	68 61 57 01 00       	push   $0x15761
   11c0f:	e8 6e 36 00 00       	call   15282 <log_printf>
   11c14:	83 c4 10             	add    $0x10,%esp
			goto load_failed;
   11c17:	e9 00 01 00 00       	jmp    11d1c <load_elf_file+0x1a3>
	}

    uint32_t e_phoff=elf_hdr.e_phoff;
   11c1c:	8b 45 cc             	mov    -0x34(%ebp),%eax
   11c1f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(int i=0;i<elf_hdr.e_phnum;i++,e_phoff+=elf_hdr.e_phentsize){
   11c22:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11c29:	e9 cb 00 00 00       	jmp    11cf9 <load_elf_file+0x180>
        if(sys_lseek(file,e_phoff,0)<0){
   11c2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11c31:	83 ec 04             	sub    $0x4,%esp
   11c34:	6a 00                	push   $0x0
   11c36:	50                   	push   %eax
   11c37:	ff 75 ec             	pushl  -0x14(%ebp)
   11c3a:	e8 08 28 00 00       	call   14447 <sys_lseek>
   11c3f:	83 c4 10             	add    $0x10,%esp
   11c42:	85 c0                	test   %eax,%eax
   11c44:	79 15                	jns    11c5b <load_elf_file+0xe2>
            log_printf("read file failed.");
   11c46:	83 ec 0c             	sub    $0xc,%esp
   11c49:	68 24 57 01 00       	push   $0x15724
   11c4e:	e8 2f 36 00 00       	call   15282 <log_printf>
   11c53:	83 c4 10             	add    $0x10,%esp
            goto load_failed;
   11c56:	e9 c1 00 00 00       	jmp    11d1c <load_elf_file+0x1a3>
        }

        cnt=sys_read(file,(char*)&elf_phdr,sizeof(elf_phdr));
   11c5b:	83 ec 04             	sub    $0x4,%esp
   11c5e:	6a 20                	push   $0x20
   11c60:	8d 45 90             	lea    -0x70(%ebp),%eax
   11c63:	50                   	push   %eax
   11c64:	ff 75 ec             	pushl  -0x14(%ebp)
   11c67:	e8 6c 27 00 00       	call   143d8 <sys_read>
   11c6c:	83 c4 10             	add    $0x10,%esp
   11c6f:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if(cnt<sizeof(elf_phdr)){
   11c72:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11c75:	83 f8 1f             	cmp    $0x1f,%eax
   11c78:	77 15                	ja     11c8f <load_elf_file+0x116>
            log_printf("read file failed.");
   11c7a:	83 ec 0c             	sub    $0xc,%esp
   11c7d:	68 24 57 01 00       	push   $0x15724
   11c82:	e8 fb 35 00 00       	call   15282 <log_printf>
   11c87:	83 c4 10             	add    $0x10,%esp
            goto load_failed;
   11c8a:	e9 8d 00 00 00       	jmp    11d1c <load_elf_file+0x1a3>
        }

        if((elf_phdr.p_type!=1)|| (elf_phdr.p_vaddr<MEMORY_TASK_BASE)){
   11c8f:	8b 45 90             	mov    -0x70(%ebp),%eax
   11c92:	83 f8 01             	cmp    $0x1,%eax
   11c95:	75 53                	jne    11cea <load_elf_file+0x171>
   11c97:	8b 45 98             	mov    -0x68(%ebp),%eax
   11c9a:	85 c0                	test   %eax,%eax
   11c9c:	79 4c                	jns    11cea <load_elf_file+0x171>
            continue;
        }

        int err=load_phdr(file,&elf_phdr,page_dir);
   11c9e:	83 ec 04             	sub    $0x4,%esp
   11ca1:	ff 75 10             	pushl  0x10(%ebp)
   11ca4:	8d 45 90             	lea    -0x70(%ebp),%eax
   11ca7:	50                   	push   %eax
   11ca8:	ff 75 ec             	pushl  -0x14(%ebp)
   11cab:	e8 cb fd ff ff       	call   11a7b <load_phdr>
   11cb0:	83 c4 10             	add    $0x10,%esp
   11cb3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(err<0){
   11cb6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   11cba:	79 12                	jns    11cce <load_elf_file+0x155>
            log_printf("load program failed.");
   11cbc:	83 ec 0c             	sub    $0xc,%esp
   11cbf:	68 79 57 01 00       	push   $0x15779
   11cc4:	e8 b9 35 00 00       	call   15282 <log_printf>
   11cc9:	83 c4 10             	add    $0x10,%esp
            goto load_failed;
   11ccc:	eb 4e                	jmp    11d1c <load_elf_file+0x1a3>
        }

        task->heap_start=elf_phdr.p_vaddr+elf_phdr.p_memsz;
   11cce:	8b 55 98             	mov    -0x68(%ebp),%edx
   11cd1:	8b 45 a4             	mov    -0x5c(%ebp),%eax
   11cd4:	01 c2                	add    %eax,%edx
   11cd6:	8b 45 08             	mov    0x8(%ebp),%eax
   11cd9:	89 50 0c             	mov    %edx,0xc(%eax)
        task->heap_end=task->heap_start;
   11cdc:	8b 45 08             	mov    0x8(%ebp),%eax
   11cdf:	8b 50 0c             	mov    0xc(%eax),%edx
   11ce2:	8b 45 08             	mov    0x8(%ebp),%eax
   11ce5:	89 50 10             	mov    %edx,0x10(%eax)
   11ce8:	eb 01                	jmp    11ceb <load_elf_file+0x172>
            continue;
   11cea:	90                   	nop
    for(int i=0;i<elf_hdr.e_phnum;i++,e_phoff+=elf_hdr.e_phentsize){
   11ceb:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11cef:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
   11cf3:	0f b7 c0             	movzwl %ax,%eax
   11cf6:	01 45 f4             	add    %eax,-0xc(%ebp)
   11cf9:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
   11cfd:	0f b7 c0             	movzwl %ax,%eax
   11d00:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11d03:	0f 8c 25 ff ff ff    	jl     11c2e <load_elf_file+0xb5>
    }


    sys_close(file);
   11d09:	83 ec 0c             	sub    $0xc,%esp
   11d0c:	ff 75 ec             	pushl  -0x14(%ebp)
   11d0f:	e8 57 27 00 00       	call   1446b <sys_close>
   11d14:	83 c4 10             	add    $0x10,%esp
    return elf_hdr.e_entry;
   11d17:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11d1a:	eb 19                	jmp    11d35 <load_elf_file+0x1bc>

load_failed:
    if(file){
   11d1c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11d20:	74 0e                	je     11d30 <load_elf_file+0x1b7>
        sys_close(file);
   11d22:	83 ec 0c             	sub    $0xc,%esp
   11d25:	ff 75 ec             	pushl  -0x14(%ebp)
   11d28:	e8 3e 27 00 00       	call   1446b <sys_close>
   11d2d:	83 c4 10             	add    $0x10,%esp
    }
    return 0;
   11d30:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11d35:	c9                   	leave  
   11d36:	c3                   	ret    

00011d37 <copy_args>:

static int copy_args(char* to,uint32_t page_dir,int argc,char**argv){
   11d37:	55                   	push   %ebp
   11d38:	89 e5                	mov    %esp,%ebp
   11d3a:	83 ec 38             	sub    $0x38,%esp
    task_args_t task_args;
    task_args.argc=argc;
   11d3d:	8b 45 10             	mov    0x10(%ebp),%eax
   11d40:	89 45 d8             	mov    %eax,-0x28(%ebp)
    task_args.argv=(char**)(to+sizeof(task_args_t));
   11d43:	8b 45 08             	mov    0x8(%ebp),%eax
   11d46:	83 c0 0c             	add    $0xc,%eax
   11d49:	89 45 dc             	mov    %eax,-0x24(%ebp)

    char* dest_arg=to+sizeof(task_args_t)+sizeof(char*)*argc;
   11d4c:	8b 45 10             	mov    0x10(%ebp),%eax
   11d4f:	83 c0 03             	add    $0x3,%eax
   11d52:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11d59:	8b 45 08             	mov    0x8(%ebp),%eax
   11d5c:	01 d0                	add    %edx,%eax
   11d5e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char** dest_arg_tb=(char**)memory_get_paddr(page_dir,(uint32_t)(to+sizeof(task_args_t)));
   11d61:	8b 45 08             	mov    0x8(%ebp),%eax
   11d64:	83 c0 0c             	add    $0xc,%eax
   11d67:	83 ec 08             	sub    $0x8,%esp
   11d6a:	50                   	push   %eax
   11d6b:	ff 75 0c             	pushl  0xc(%ebp)
   11d6e:	e8 bb ee ff ff       	call   10c2e <memory_get_paddr>
   11d73:	83 c4 10             	add    $0x10,%esp
   11d76:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for(int i=0;i<argc;i++){
   11d79:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11d80:	e9 82 00 00 00       	jmp    11e07 <copy_args+0xd0>
        char* from=argv[i];
   11d85:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d88:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11d8f:	8b 45 14             	mov    0x14(%ebp),%eax
   11d92:	01 d0                	add    %edx,%eax
   11d94:	8b 00                	mov    (%eax),%eax
   11d96:	89 45 e8             	mov    %eax,-0x18(%ebp)
        int len=kernel_strlen(from)+1;
   11d99:	83 ec 0c             	sub    $0xc,%esp
   11d9c:	ff 75 e8             	pushl  -0x18(%ebp)
   11d9f:	e8 31 2e 00 00       	call   14bd5 <kernel_strlen>
   11da4:	83 c4 10             	add    $0x10,%esp
   11da7:	83 c0 01             	add    $0x1,%eax
   11daa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        int err=memory_copy_uvm_data((uint32_t)dest_arg,page_dir,(uint32_t)from,len);
   11dad:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   11db0:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11db3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11db6:	51                   	push   %ecx
   11db7:	52                   	push   %edx
   11db8:	ff 75 0c             	pushl  0xc(%ebp)
   11dbb:	50                   	push   %eax
   11dbc:	e8 b3 ee ff ff       	call   10c74 <memory_copy_uvm_data>
   11dc1:	83 c4 10             	add    $0x10,%esp
   11dc4:	89 45 e0             	mov    %eax,-0x20(%ebp)
        ASSERT(err >= 0);
   11dc7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   11dcb:	79 1c                	jns    11de9 <copy_args+0xb2>
   11dcd:	68 8e 57 01 00       	push   $0x1578e
   11dd2:	68 b4 57 01 00       	push   $0x157b4
   11dd7:	68 d5 01 00 00       	push   $0x1d5
   11ddc:	68 98 56 01 00       	push   $0x15698
   11de1:	e8 cc 31 00 00       	call   14fb2 <panic>
   11de6:	83 c4 10             	add    $0x10,%esp

        dest_arg_tb[i]=dest_arg;
   11de9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11dec:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11df3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11df6:	01 c2                	add    %eax,%edx
   11df8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11dfb:	89 02                	mov    %eax,(%edx)
        dest_arg+=len;
   11dfd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11e00:	01 45 f4             	add    %eax,-0xc(%ebp)
    for(int i=0;i<argc;i++){
   11e03:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11e07:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11e0a:	3b 45 10             	cmp    0x10(%ebp),%eax
   11e0d:	0f 8c 72 ff ff ff    	jl     11d85 <copy_args+0x4e>

    }
    return memory_copy_uvm_data((uint32_t)to,page_dir,(uint32_t)&task_args,sizeof(task_args));
   11e13:	8d 55 d4             	lea    -0x2c(%ebp),%edx
   11e16:	8b 45 08             	mov    0x8(%ebp),%eax
   11e19:	6a 0c                	push   $0xc
   11e1b:	52                   	push   %edx
   11e1c:	ff 75 0c             	pushl  0xc(%ebp)
   11e1f:	50                   	push   %eax
   11e20:	e8 4f ee ff ff       	call   10c74 <memory_copy_uvm_data>
   11e25:	83 c4 10             	add    $0x10,%esp

}
   11e28:	c9                   	leave  
   11e29:	c3                   	ret    

00011e2a <sys_execve>:

int sys_execve(char* name,char** argv,char** env){
   11e2a:	55                   	push   %ebp
   11e2b:	89 e5                	mov    %esp,%ebp
   11e2d:	83 ec 28             	sub    $0x28,%esp
    task_t* task=task_current();
   11e30:	e8 b0 f7 ff ff       	call   115e5 <task_current>
   11e35:	89 45 f4             	mov    %eax,-0xc(%ebp)

    kernel_strncpy(task->name,get_file_name(name),TASK_NAME_SIZE);
   11e38:	83 ec 0c             	sub    $0xc,%esp
   11e3b:	ff 75 08             	pushl  0x8(%ebp)
   11e3e:	e8 d2 31 00 00       	call   15015 <get_file_name>
   11e43:	83 c4 10             	add    $0x10,%esp
   11e46:	89 c2                	mov    %eax,%edx
   11e48:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11e4b:	83 c0 20             	add    $0x20,%eax
   11e4e:	83 ec 04             	sub    $0x4,%esp
   11e51:	6a 20                	push   $0x20
   11e53:	52                   	push   %edx
   11e54:	50                   	push   %eax
   11e55:	e8 91 2c 00 00       	call   14aeb <kernel_strncpy>
   11e5a:	83 c4 10             	add    $0x10,%esp

    uint32_t old_page_dir=task->tss.cr3;
   11e5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11e60:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
   11e66:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint32_t new_page_dir=memory_create_uvm();
   11e69:	e8 5a e9 ff ff       	call   107c8 <memory_create_uvm>
   11e6e:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(!new_page_dir){
   11e71:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11e75:	0f 84 1f 01 00 00    	je     11f9a <sys_execve+0x170>
        goto exec_failed;
    }

    uint32_t entry=load_elf_file(task,name,new_page_dir);
   11e7b:	83 ec 04             	sub    $0x4,%esp
   11e7e:	ff 75 ec             	pushl  -0x14(%ebp)
   11e81:	ff 75 08             	pushl  0x8(%ebp)
   11e84:	ff 75 f4             	pushl  -0xc(%ebp)
   11e87:	e8 ed fc ff ff       	call   11b79 <load_elf_file>
   11e8c:	83 c4 10             	add    $0x10,%esp
   11e8f:	89 45 e8             	mov    %eax,-0x18(%ebp)

    if(entry==0){
   11e92:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11e96:	0f 84 01 01 00 00    	je     11f9d <sys_execve+0x173>
        goto exec_failed;
    }

    uint32_t stack_top=MEM_TASK_STACK_TOP-MEM_TASK_ARG_SIZE;
   11e9c:	c7 45 e4 00 c0 ff df 	movl   $0xdfffc000,-0x1c(%ebp)

    int err=memory_alloc_for_page_dir(new_page_dir,
   11ea3:	6a 07                	push   $0x7
   11ea5:	68 00 40 1f 00       	push   $0x1f4000
   11eaa:	68 00 c0 e0 df       	push   $0xdfe0c000
   11eaf:	ff 75 ec             	pushl  -0x14(%ebp)
   11eb2:	e8 96 e9 ff ff       	call   1084d <memory_alloc_for_page_dir>
   11eb7:	83 c4 10             	add    $0x10,%esp
   11eba:	89 45 e0             	mov    %eax,-0x20(%ebp)
        MEM_TASK_STACK_TOP-MEM_TASK_STACK_SIZE,MEM_TASK_STACK_SIZE,
        PTE_P | PTE_U | PTE_W
    );

    if(err < 0){
   11ebd:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   11ec1:	0f 88 d9 00 00 00    	js     11fa0 <sys_execve+0x176>
        goto exec_failed;
    }
    
    int argc=string_count(argv);
   11ec7:	83 ec 0c             	sub    $0xc,%esp
   11eca:	ff 75 0c             	pushl  0xc(%ebp)
   11ecd:	e8 16 31 00 00       	call   14fe8 <string_count>
   11ed2:	83 c4 10             	add    $0x10,%esp
   11ed5:	89 45 dc             	mov    %eax,-0x24(%ebp)
    err=copy_args((char*)stack_top,new_page_dir,argc,argv);
   11ed8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11edb:	ff 75 0c             	pushl  0xc(%ebp)
   11ede:	ff 75 dc             	pushl  -0x24(%ebp)
   11ee1:	ff 75 ec             	pushl  -0x14(%ebp)
   11ee4:	50                   	push   %eax
   11ee5:	e8 4d fe ff ff       	call   11d37 <copy_args>
   11eea:	83 c4 10             	add    $0x10,%esp
   11eed:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(err<0){
   11ef0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   11ef4:	0f 88 a9 00 00 00    	js     11fa3 <sys_execve+0x179>
        goto exec_failed;
    }

    syscall_frame_t* frame=(syscall_frame_t*)(task->tss.esp0-sizeof(syscall_frame_t));
   11efa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11efd:	8b 80 5c 02 00 00    	mov    0x25c(%eax),%eax
   11f03:	83 e8 58             	sub    $0x58,%eax
   11f06:	89 45 d8             	mov    %eax,-0x28(%ebp)
    frame->eip=entry;
   11f09:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f0c:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11f0f:	89 50 34             	mov    %edx,0x34(%eax)
    frame->eax=frame->ebx=frame->edx=0;
   11f12:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f15:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
   11f1c:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f1f:	8b 50 28             	mov    0x28(%eax),%edx
   11f22:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f25:	89 50 24             	mov    %edx,0x24(%eax)
   11f28:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f2b:	8b 50 24             	mov    0x24(%eax),%edx
   11f2e:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f31:	89 50 30             	mov    %edx,0x30(%eax)
    frame->esi=frame->edi=frame->ebp=0;
   11f34:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f37:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
   11f3e:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f41:	8b 50 1c             	mov    0x1c(%eax),%edx
   11f44:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f47:	89 50 14             	mov    %edx,0x14(%eax)
   11f4a:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f4d:	8b 50 14             	mov    0x14(%eax),%edx
   11f50:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f53:	89 50 18             	mov    %edx,0x18(%eax)
    frame->eflags=EFLAGS_DEFAULT|EFLAGS_IF;
   11f56:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f59:	c7 00 02 02 00 00    	movl   $0x202,(%eax)

    frame->esp=stack_top-sizeof(uint32_t)*SYSCALL_PARAM_COUNT;
   11f5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11f62:	8d 50 ec             	lea    -0x14(%eax),%edx
   11f65:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f68:	89 50 50             	mov    %edx,0x50(%eax)

    task->tss.cr3=new_page_dir;
   11f6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11f6e:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11f71:	89 90 74 02 00 00    	mov    %edx,0x274(%eax)
    mmu_set_page_dir(new_page_dir);
   11f77:	83 ec 0c             	sub    $0xc,%esp
   11f7a:	ff 75 ec             	pushl  -0x14(%ebp)
   11f7d:	e8 de ef ff ff       	call   10f60 <mmu_set_page_dir>
   11f82:	83 c4 10             	add    $0x10,%esp

    memory_destroy_uvm(old_page_dir);
   11f85:	83 ec 0c             	sub    $0xc,%esp
   11f88:	ff 75 f0             	pushl  -0x10(%ebp)
   11f8b:	e8 62 ea ff ff       	call   109f2 <memory_destroy_uvm>
   11f90:	83 c4 10             	add    $0x10,%esp

    return 0;
   11f93:	b8 00 00 00 00       	mov    $0x0,%eax
   11f98:	eb 3d                	jmp    11fd7 <sys_execve+0x1ad>
        goto exec_failed;
   11f9a:	90                   	nop
   11f9b:	eb 07                	jmp    11fa4 <sys_execve+0x17a>
        goto exec_failed;
   11f9d:	90                   	nop
   11f9e:	eb 04                	jmp    11fa4 <sys_execve+0x17a>
        goto exec_failed;
   11fa0:	90                   	nop
   11fa1:	eb 01                	jmp    11fa4 <sys_execve+0x17a>
        goto exec_failed;
   11fa3:	90                   	nop

exec_failed:
    if(new_page_dir){
   11fa4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11fa8:	74 28                	je     11fd2 <sys_execve+0x1a8>
        task->tss.cr3=old_page_dir;
   11faa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11fad:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11fb0:	89 90 74 02 00 00    	mov    %edx,0x274(%eax)
        mmu_set_page_dir(old_page_dir);
   11fb6:	83 ec 0c             	sub    $0xc,%esp
   11fb9:	ff 75 f0             	pushl  -0x10(%ebp)
   11fbc:	e8 9f ef ff ff       	call   10f60 <mmu_set_page_dir>
   11fc1:	83 c4 10             	add    $0x10,%esp

        memory_destroy_uvm(new_page_dir);
   11fc4:	83 ec 0c             	sub    $0xc,%esp
   11fc7:	ff 75 ec             	pushl  -0x14(%ebp)
   11fca:	e8 23 ea ff ff       	call   109f2 <memory_destroy_uvm>
   11fcf:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   11fd2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   11fd7:	c9                   	leave  
   11fd8:	c3                   	ret    

00011fd9 <task_file>:

file_t* task_file(int fd){
   11fd9:	55                   	push   %ebp
   11fda:	89 e5                	mov    %esp,%ebp
   11fdc:	83 ec 10             	sub    $0x10,%esp
    if((fd>=0) && (fd<TASK_OFILE_NR)){
   11fdf:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11fe3:	78 19                	js     11ffe <task_file+0x25>
   11fe5:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   11fe9:	7f 13                	jg     11ffe <task_file+0x25>
        file_t* file=task_current()->file_table[fd];
   11feb:	e8 f5 f5 ff ff       	call   115e5 <task_current>
   11ff0:	89 c2                	mov    %eax,%edx
   11ff2:	8b 45 08             	mov    0x8(%ebp),%eax
   11ff5:	83 c0 10             	add    $0x10,%eax
   11ff8:	8b 04 82             	mov    (%edx,%eax,4),%eax
   11ffb:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    return (file_t*)0;
   11ffe:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12003:	c9                   	leave  
   12004:	c3                   	ret    

00012005 <task_alloc_fd>:

int task_alloc_fd(file_t* file){
   12005:	55                   	push   %ebp
   12006:	89 e5                	mov    %esp,%ebp
   12008:	83 ec 10             	sub    $0x10,%esp
    task_t* task=task_current();
   1200b:	e8 d5 f5 ff ff       	call   115e5 <task_current>
   12010:	89 45 f8             	mov    %eax,-0x8(%ebp)

    for(int i=0;i<TASK_OFILE_NR;i++){
   12013:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1201a:	eb 2d                	jmp    12049 <task_alloc_fd+0x44>
        file_t* p=task->file_table[i];
   1201c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1201f:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12022:	83 c2 10             	add    $0x10,%edx
   12025:	8b 04 90             	mov    (%eax,%edx,4),%eax
   12028:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(p==(file_t*)0){
   1202b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1202f:	75 14                	jne    12045 <task_alloc_fd+0x40>
            task->file_table[i]=file;
   12031:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12034:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12037:	8d 4a 10             	lea    0x10(%edx),%ecx
   1203a:	8b 55 08             	mov    0x8(%ebp),%edx
   1203d:	89 14 88             	mov    %edx,(%eax,%ecx,4)
            return i;
   12040:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12043:	eb 0f                	jmp    12054 <task_alloc_fd+0x4f>
    for(int i=0;i<TASK_OFILE_NR;i++){
   12045:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12049:	83 7d fc 7f          	cmpl   $0x7f,-0x4(%ebp)
   1204d:	7e cd                	jle    1201c <task_alloc_fd+0x17>
        }
    }

    return -1;
   1204f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   12054:	c9                   	leave  
   12055:	c3                   	ret    

00012056 <task_remove_fd>:

void task_remove_fd(int fd){
   12056:	55                   	push   %ebp
   12057:	89 e5                	mov    %esp,%ebp
   if((fd>=0) && (fd<TASK_OFILE_NR)){
   12059:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1205d:	78 1a                	js     12079 <task_remove_fd+0x23>
   1205f:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   12063:	7f 14                	jg     12079 <task_remove_fd+0x23>
       task_current()->file_table[fd]=(file_t*)0;
   12065:	e8 7b f5 ff ff       	call   115e5 <task_current>
   1206a:	89 c2                	mov    %eax,%edx
   1206c:	8b 45 08             	mov    0x8(%ebp),%eax
   1206f:	83 c0 10             	add    $0x10,%eax
   12072:	c7 04 82 00 00 00 00 	movl   $0x0,(%edx,%eax,4)
    }
}
   12079:	90                   	nop
   1207a:	5d                   	pop    %ebp
   1207b:	c3                   	ret    

0001207c <lgdt>:
static inline void lgdt(uint32_t start,uint32_t size){
   1207c:	55                   	push   %ebp
   1207d:	89 e5                	mov    %esp,%ebp
   1207f:	83 ec 10             	sub    $0x10,%esp
    gdt.start31_16=start>>16;
   12082:	8b 45 08             	mov    0x8(%ebp),%eax
   12085:	c1 e8 10             	shr    $0x10,%eax
   12088:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    gdt.start15_0=start&0xFFFF;
   1208c:	8b 45 08             	mov    0x8(%ebp),%eax
   1208f:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    gdt.limit=size-1;
   12093:	8b 45 0c             	mov    0xc(%ebp),%eax
   12096:	83 e8 01             	sub    $0x1,%eax
   12099:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    __asm__ __volatile__(
   1209d:	0f 01 55 fa          	lgdtl  -0x6(%ebp)
}
   120a1:	90                   	nop
   120a2:	c9                   	leave  
   120a3:	c3                   	ret    

000120a4 <far_jump>:
static inline void far_jump(uint32_t selector,uint32_t offset){
   120a4:	55                   	push   %ebp
   120a5:	89 e5                	mov    %esp,%ebp
   120a7:	83 ec 10             	sub    $0x10,%esp
    uint32_t addr[]={offset,selector};
   120aa:	8b 45 0c             	mov    0xc(%ebp),%eax
   120ad:	89 45 f8             	mov    %eax,-0x8(%ebp)
   120b0:	8b 45 08             	mov    0x8(%ebp),%eax
   120b3:	89 45 fc             	mov    %eax,-0x4(%ebp)
    __asm__ __volatile__(
   120b6:	8d 45 f8             	lea    -0x8(%ebp),%eax
   120b9:	ff 28                	ljmp   *(%eax)
}
   120bb:	90                   	nop
   120bc:	c9                   	leave  
   120bd:	c3                   	ret    

000120be <segment_desc_set>:
#include "cpu/irq.h"

static segment_desc_t gdt_table[GDT_TABLE_SIZE];
static mutex_t mutex;
// 设置gdt段，selector gdt表的索引，base是段基址，limit是段界限，attr段属性
void segment_desc_set(int selector,uint32_t base,uint32_t limit,uint16_t attr){
   120be:	55                   	push   %ebp
   120bf:	89 e5                	mov    %esp,%ebp
   120c1:	83 ec 14             	sub    $0x14,%esp
   120c4:	8b 45 14             	mov    0x14(%ebp),%eax
   120c7:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    segment_desc_t* desc=gdt_table+(selector >> 3);
   120cb:	8b 45 08             	mov    0x8(%ebp),%eax
   120ce:	c1 f8 03             	sar    $0x3,%eax
   120d1:	c1 e0 03             	shl    $0x3,%eax
   120d4:	05 e0 07 03 00       	add    $0x307e0,%eax
   120d9:	89 45 fc             	mov    %eax,-0x4(%ebp)

    // 设置G标志位决定粒度4kb or 1B
    if(limit > 0xFFFFF){
   120dc:	81 7d 10 ff ff 0f 00 	cmpl   $0xfffff,0x10(%ebp)
   120e3:	76 0f                	jbe    120f4 <segment_desc_set+0x36>
        attr|=0x8000;
   120e5:	66 81 4d ec 00 80    	orw    $0x8000,-0x14(%ebp)
        limit/=0x1000;
   120eb:	8b 45 10             	mov    0x10(%ebp),%eax
   120ee:	c1 e8 0c             	shr    $0xc,%eax
   120f1:	89 45 10             	mov    %eax,0x10(%ebp)
    }
    desc->limit15_0=limit&0xFFFF;
   120f4:	8b 45 10             	mov    0x10(%ebp),%eax
   120f7:	89 c2                	mov    %eax,%edx
   120f9:	8b 45 fc             	mov    -0x4(%ebp),%eax
   120fc:	66 89 10             	mov    %dx,(%eax)
    desc->base15_0=base&0xFFFF;
   120ff:	8b 45 0c             	mov    0xc(%ebp),%eax
   12102:	89 c2                	mov    %eax,%edx
   12104:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12107:	66 89 50 02          	mov    %dx,0x2(%eax)
    desc->base23_16=(base>>16)&0xFF;
   1210b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1210e:	c1 e8 10             	shr    $0x10,%eax
   12111:	89 c2                	mov    %eax,%edx
   12113:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12116:	88 50 04             	mov    %dl,0x4(%eax)
    desc->attr=attr|(((limit>>16)&0xF)<<8);
   12119:	8b 45 10             	mov    0x10(%ebp),%eax
   1211c:	c1 e8 10             	shr    $0x10,%eax
   1211f:	c1 e0 08             	shl    $0x8,%eax
   12122:	66 25 00 0f          	and    $0xf00,%ax
   12126:	66 0b 45 ec          	or     -0x14(%ebp),%ax
   1212a:	89 c2                	mov    %eax,%edx
   1212c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1212f:	66 89 50 05          	mov    %dx,0x5(%eax)
    desc->base31_24=(base>>24)&0xFF;
   12133:	8b 45 0c             	mov    0xc(%ebp),%eax
   12136:	c1 e8 18             	shr    $0x18,%eax
   12139:	89 c2                	mov    %eax,%edx
   1213b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1213e:	88 50 07             	mov    %dl,0x7(%eax)

}
   12141:	90                   	nop
   12142:	c9                   	leave  
   12143:	c3                   	ret    

00012144 <init_gdt>:

// 初始化gdt表
void init_gdt(void){
   12144:	55                   	push   %ebp
   12145:	89 e5                	mov    %esp,%ebp
   12147:	83 ec 18             	sub    $0x18,%esp
    for(int i=0;i<GDT_TABLE_SIZE;i++){
   1214a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12151:	eb 19                	jmp    1216c <init_gdt+0x28>
        segment_desc_set(i<<3,0,0,0);
   12153:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12156:	c1 e0 03             	shl    $0x3,%eax
   12159:	6a 00                	push   $0x0
   1215b:	6a 00                	push   $0x0
   1215d:	6a 00                	push   $0x0
   1215f:	50                   	push   %eax
   12160:	e8 59 ff ff ff       	call   120be <segment_desc_set>
   12165:	83 c4 10             	add    $0x10,%esp
    for(int i=0;i<GDT_TABLE_SIZE;i++){
   12168:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1216c:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   12173:	7e de                	jle    12153 <init_gdt+0xf>
    }
    segment_desc_set(KERNEL_SELECTOR_DS,0,0xFFFFFFFF,
   12175:	68 92 40 00 00       	push   $0x4092
   1217a:	6a ff                	push   $0xffffffff
   1217c:	6a 00                	push   $0x0
   1217e:	6a 10                	push   $0x10
   12180:	e8 39 ff ff ff       	call   120be <segment_desc_set>
   12185:	83 c4 10             	add    $0x10,%esp
        SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_DATA | SEG_TYPE_RW
        | SEG_D
    );
    segment_desc_set(KERNEL_SELECTOR_CS, 0x00000000, 0xFFFFFFFF,
   12188:	68 9a c0 00 00       	push   $0xc09a
   1218d:	6a ff                	push   $0xffffffff
   1218f:	6a 00                	push   $0x0
   12191:	6a 08                	push   $0x8
   12193:	e8 26 ff ff ff       	call   120be <segment_desc_set>
   12198:	83 c4 10             	add    $0x10,%esp
        SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_CODE
        | SEG_TYPE_RW | SEG_D | SEG_G);
    gate_desc_set((gate_desc_t*)(gdt_table+(SELECTOR_SYSCALL >> 3)),
   1219b:	ba c7 02 01 00       	mov    $0x102c7,%edx
   121a0:	b8 f8 07 03 00       	mov    $0x307f8,%eax
   121a5:	68 05 ec 00 00       	push   $0xec05
   121aa:	52                   	push   %edx
   121ab:	6a 08                	push   $0x8
   121ad:	50                   	push   %eax
   121ae:	e8 1c 00 00 00       	call   121cf <gate_desc_set>
   121b3:	83 c4 10             	add    $0x10,%esp
        KERNEL_SELECTOR_CS,(uint32_t)exception_handler_syscall,
        GATE_P_PRESENT | GATE_DPL3 | GATE_TYPE_SYSCALL | SYSCALL_PARAM_COUNT
    );
    lgdt((uint32_t)gdt_table,sizeof(gdt_table));
   121b6:	b8 e0 07 03 00       	mov    $0x307e0,%eax
   121bb:	83 ec 08             	sub    $0x8,%esp
   121be:	68 00 08 00 00       	push   $0x800
   121c3:	50                   	push   %eax
   121c4:	e8 b3 fe ff ff       	call   1207c <lgdt>
   121c9:	83 c4 10             	add    $0x10,%esp
}
   121cc:	90                   	nop
   121cd:	c9                   	leave  
   121ce:	c3                   	ret    

000121cf <gate_desc_set>:

// 设置idt表项
void gate_desc_set(gate_desc_t* desc,uint16_t selector,uint32_t offset,uint16_t attr){
   121cf:	55                   	push   %ebp
   121d0:	89 e5                	mov    %esp,%ebp
   121d2:	83 ec 08             	sub    $0x8,%esp
   121d5:	8b 55 0c             	mov    0xc(%ebp),%edx
   121d8:	8b 45 14             	mov    0x14(%ebp),%eax
   121db:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   121df:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    desc->offset15_0=offset&0xFFFF;
   121e3:	8b 45 10             	mov    0x10(%ebp),%eax
   121e6:	89 c2                	mov    %eax,%edx
   121e8:	8b 45 08             	mov    0x8(%ebp),%eax
   121eb:	66 89 10             	mov    %dx,(%eax)
    desc->selector=selector;
   121ee:	8b 45 08             	mov    0x8(%ebp),%eax
   121f1:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   121f5:	66 89 50 02          	mov    %dx,0x2(%eax)
    desc->attr=attr;
   121f9:	8b 45 08             	mov    0x8(%ebp),%eax
   121fc:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
   12200:	66 89 50 04          	mov    %dx,0x4(%eax)
    desc->offset31_16=(offset>>16)&0xFFFF;
   12204:	8b 45 10             	mov    0x10(%ebp),%eax
   12207:	c1 e8 10             	shr    $0x10,%eax
   1220a:	89 c2                	mov    %eax,%edx
   1220c:	8b 45 08             	mov    0x8(%ebp),%eax
   1220f:	66 89 50 06          	mov    %dx,0x6(%eax)
}
   12213:	90                   	nop
   12214:	c9                   	leave  
   12215:	c3                   	ret    

00012216 <cpu_init>:


void cpu_init(void){
   12216:	55                   	push   %ebp
   12217:	89 e5                	mov    %esp,%ebp
   12219:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&mutex);
   1221c:	83 ec 0c             	sub    $0xc,%esp
   1221f:	68 e0 0f 03 00       	push   $0x30fe0
   12224:	e8 3e 23 00 00       	call   14567 <mutex_init>
   12229:	83 c4 10             	add    $0x10,%esp
    init_gdt();
   1222c:	e8 13 ff ff ff       	call   12144 <init_gdt>
}
   12231:	90                   	nop
   12232:	c9                   	leave  
   12233:	c3                   	ret    

00012234 <gdt_alloc_desc>:

int gdt_alloc_desc(){
   12234:	55                   	push   %ebp
   12235:	89 e5                	mov    %esp,%ebp
   12237:	83 ec 18             	sub    $0x18,%esp
    mutex_lock(&mutex);
   1223a:	83 ec 0c             	sub    $0xc,%esp
   1223d:	68 e0 0f 03 00       	push   $0x30fe0
   12242:	e8 4e 23 00 00       	call   14595 <mutex_lock>
   12247:	83 c4 10             	add    $0x10,%esp
    for(int i=1;i<GDT_TABLE_SIZE;i++){
   1224a:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
   12251:	eb 36                	jmp    12289 <gdt_alloc_desc+0x55>
        segment_desc_t* desc=gdt_table+i;
   12253:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12256:	c1 e0 03             	shl    $0x3,%eax
   12259:	05 e0 07 03 00       	add    $0x307e0,%eax
   1225e:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(desc->attr==0){
   12261:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12264:	0f b7 40 05          	movzwl 0x5(%eax),%eax
   12268:	66 85 c0             	test   %ax,%ax
   1226b:	75 18                	jne    12285 <gdt_alloc_desc+0x51>
            mutex_unlock(&mutex);
   1226d:	83 ec 0c             	sub    $0xc,%esp
   12270:	68 e0 0f 03 00       	push   $0x30fe0
   12275:	e8 aa 23 00 00       	call   14624 <mutex_unlock>
   1227a:	83 c4 10             	add    $0x10,%esp
            return i*sizeof(segment_desc_t);
   1227d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12280:	c1 e0 03             	shl    $0x3,%eax
   12283:	eb 22                	jmp    122a7 <gdt_alloc_desc+0x73>
    for(int i=1;i<GDT_TABLE_SIZE;i++){
   12285:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12289:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   12290:	7e c1                	jle    12253 <gdt_alloc_desc+0x1f>
        }
    }
    mutex_unlock(&mutex);
   12292:	83 ec 0c             	sub    $0xc,%esp
   12295:	68 e0 0f 03 00       	push   $0x30fe0
   1229a:	e8 85 23 00 00       	call   14624 <mutex_unlock>
   1229f:	83 c4 10             	add    $0x10,%esp
    return -1;
   122a2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   122a7:	c9                   	leave  
   122a8:	c3                   	ret    

000122a9 <switch_to_tss>:

void switch_to_tss(int tss_sel){
   122a9:	55                   	push   %ebp
   122aa:	89 e5                	mov    %esp,%ebp
    far_jump(tss_sel,0);
   122ac:	8b 45 08             	mov    0x8(%ebp),%eax
   122af:	6a 00                	push   $0x0
   122b1:	50                   	push   %eax
   122b2:	e8 ed fd ff ff       	call   120a4 <far_jump>
   122b7:	83 c4 08             	add    $0x8,%esp
}
   122ba:	90                   	nop
   122bb:	c9                   	leave  
   122bc:	c3                   	ret    

000122bd <gdt_free_sel>:

void gdt_free_sel(int sel){
   122bd:	55                   	push   %ebp
   122be:	89 e5                	mov    %esp,%ebp
   122c0:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&mutex);
   122c3:	83 ec 0c             	sub    $0xc,%esp
   122c6:	68 e0 0f 03 00       	push   $0x30fe0
   122cb:	e8 c5 22 00 00       	call   14595 <mutex_lock>
   122d0:	83 c4 10             	add    $0x10,%esp
    gdt_table[sel/sizeof(segment_desc_set)].attr=0;
   122d3:	8b 45 08             	mov    0x8(%ebp),%eax
   122d6:	66 c7 04 c5 e5 07 03 	movw   $0x0,0x307e5(,%eax,8)
   122dd:	00 00 00 
    mutex_unlock(&mutex);
   122e0:	83 ec 0c             	sub    $0xc,%esp
   122e3:	68 e0 0f 03 00       	push   $0x30fe0
   122e8:	e8 37 23 00 00       	call   14624 <mutex_unlock>
   122ed:	83 c4 10             	add    $0x10,%esp
   122f0:	90                   	nop
   122f1:	c9                   	leave  
   122f2:	c3                   	ret    

000122f3 <cli>:
static inline void cli(void){
   122f3:	55                   	push   %ebp
   122f4:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("cli");
   122f6:	fa                   	cli    
}
   122f7:	90                   	nop
   122f8:	5d                   	pop    %ebp
   122f9:	c3                   	ret    

000122fa <sti>:
static inline void sti(void){
   122fa:	55                   	push   %ebp
   122fb:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("sti");
   122fd:	fb                   	sti    
}
   122fe:	90                   	nop
   122ff:	5d                   	pop    %ebp
   12300:	c3                   	ret    

00012301 <inb>:
static inline uint8_t inb(uint16_t port){
   12301:	55                   	push   %ebp
   12302:	89 e5                	mov    %esp,%ebp
   12304:	83 ec 14             	sub    $0x14,%esp
   12307:	8b 45 08             	mov    0x8(%ebp),%eax
   1230a:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__(
   1230e:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   12312:	89 c2                	mov    %eax,%edx
   12314:	ec                   	in     (%dx),%al
   12315:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   12318:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   1231c:	c9                   	leave  
   1231d:	c3                   	ret    

0001231e <outb>:
static inline void outb(uint16_t port,uint8_t data){
   1231e:	55                   	push   %ebp
   1231f:	89 e5                	mov    %esp,%ebp
   12321:	83 ec 08             	sub    $0x8,%esp
   12324:	8b 55 08             	mov    0x8(%ebp),%edx
   12327:	8b 45 0c             	mov    0xc(%ebp),%eax
   1232a:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   1232e:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile(
   12331:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   12335:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   12339:	ee                   	out    %al,(%dx)
}
   1233a:	90                   	nop
   1233b:	c9                   	leave  
   1233c:	c3                   	ret    

0001233d <lidt>:
static inline void lidt(uint32_t start,uint32_t size){
   1233d:	55                   	push   %ebp
   1233e:	89 e5                	mov    %esp,%ebp
   12340:	83 ec 10             	sub    $0x10,%esp
    idt.start31_16=start>>16;
   12343:	8b 45 08             	mov    0x8(%ebp),%eax
   12346:	c1 e8 10             	shr    $0x10,%eax
   12349:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    idt.start15_0=start&0xFFFF;
   1234d:	8b 45 08             	mov    0x8(%ebp),%eax
   12350:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    idt.limit=size-1;
   12354:	8b 45 0c             	mov    0xc(%ebp),%eax
   12357:	83 e8 01             	sub    $0x1,%eax
   1235a:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    __asm__ __volatile__(
   1235e:	0f 01 5d fa          	lidtl  -0x6(%ebp)
}
   12362:	90                   	nop
   12363:	c9                   	leave  
   12364:	c3                   	ret    

00012365 <hlt>:
static inline void hlt(void){
   12365:	55                   	push   %ebp
   12366:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile("hlt");
   12368:	f4                   	hlt    
}
   12369:	90                   	nop
   1236a:	5d                   	pop    %ebp
   1236b:	c3                   	ret    

0001236c <read_eflags>:
static inline uint32_t read_eflags(void){
   1236c:	55                   	push   %ebp
   1236d:	89 e5                	mov    %esp,%ebp
   1236f:	83 ec 10             	sub    $0x10,%esp
    __asm__ __volatile__(
   12372:	9c                   	pushf  
   12373:	58                   	pop    %eax
   12374:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return eflags;
   12377:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   1237a:	c9                   	leave  
   1237b:	c3                   	ret    

0001237c <write_eflags>:
static inline void write_eflags(uint32_t eflags){
   1237c:	55                   	push   %ebp
   1237d:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   1237f:	8b 45 08             	mov    0x8(%ebp),%eax
   12382:	50                   	push   %eax
   12383:	9d                   	popf   
}
   12384:	90                   	nop
   12385:	5d                   	pop    %ebp
   12386:	c3                   	ret    

00012387 <read_cr2>:
        :
        :[v]"r"(v)
    );
}

static inline uint32_t read_cr2(void){
   12387:	55                   	push   %ebp
   12388:	89 e5                	mov    %esp,%ebp
   1238a:	83 ec 10             	sub    $0x10,%esp
    uint32_t cr2;
    __asm__ __volatile__(
   1238d:	0f 20 e0             	mov    %cr4,%eax
   12390:	89 45 fc             	mov    %eax,-0x4(%ebp)
        "mov %%cr4,%[v]"
        :[v]"=r"(cr2)
        :
    );
    return cr2;
   12393:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   12396:	c9                   	leave  
   12397:	c3                   	ret    

00012398 <init_pic>:
#include "cpu/irq.h"

// 初始化8259，开启中断
static void init_pic(void){
   12398:	55                   	push   %ebp
   12399:	89 e5                	mov    %esp,%ebp
	outb(PIC0_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);
   1239b:	6a 11                	push   $0x11
   1239d:	6a 20                	push   $0x20
   1239f:	e8 7a ff ff ff       	call   1231e <outb>
   123a4:	83 c4 08             	add    $0x8,%esp
	outb(PIC0_ICW2, IRQ_PIC_START);
   123a7:	6a 20                	push   $0x20
   123a9:	6a 21                	push   $0x21
   123ab:	e8 6e ff ff ff       	call   1231e <outb>
   123b0:	83 c4 08             	add    $0x8,%esp
	outb(PIC0_ICW3, 1 << 2);
   123b3:	6a 04                	push   $0x4
   123b5:	6a 21                	push   $0x21
   123b7:	e8 62 ff ff ff       	call   1231e <outb>
   123bc:	83 c4 08             	add    $0x8,%esp
	outb(PIC0_ICW4, PIC_ICW4_8086);
   123bf:	6a 01                	push   $0x1
   123c1:	6a 21                	push   $0x21
   123c3:	e8 56 ff ff ff       	call   1231e <outb>
   123c8:	83 c4 08             	add    $0x8,%esp

	outb(PIC1_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);
   123cb:	6a 11                	push   $0x11
   123cd:	68 a0 00 00 00       	push   $0xa0
   123d2:	e8 47 ff ff ff       	call   1231e <outb>
   123d7:	83 c4 08             	add    $0x8,%esp
	outb(PIC1_ICW2, IRQ_PIC_START+8);
   123da:	6a 28                	push   $0x28
   123dc:	68 a1 00 00 00       	push   $0xa1
   123e1:	e8 38 ff ff ff       	call   1231e <outb>
   123e6:	83 c4 08             	add    $0x8,%esp
	outb(PIC1_ICW3, 2);
   123e9:	6a 02                	push   $0x2
   123eb:	68 a1 00 00 00       	push   $0xa1
   123f0:	e8 29 ff ff ff       	call   1231e <outb>
   123f5:	83 c4 08             	add    $0x8,%esp
	outb(PIC1_ICW4, PIC_ICW4_8086);
   123f8:	6a 01                	push   $0x1
   123fa:	68 a1 00 00 00       	push   $0xa1
   123ff:	e8 1a ff ff ff       	call   1231e <outb>
   12404:	83 c4 08             	add    $0x8,%esp

	outb(PIC0_IMR,0xFF & ~(1 << 2));
   12407:	68 fb 00 00 00       	push   $0xfb
   1240c:	6a 21                	push   $0x21
   1240e:	e8 0b ff ff ff       	call   1231e <outb>
   12413:	83 c4 08             	add    $0x8,%esp
	outb(PIC1_IMR, 0xFF);
   12416:	68 ff 00 00 00       	push   $0xff
   1241b:	68 a1 00 00 00       	push   $0xa1
   12420:	e8 f9 fe ff ff       	call   1231e <outb>
   12425:	83 c4 08             	add    $0x8,%esp
}
   12428:	90                   	nop
   12429:	c9                   	leave  
   1242a:	c3                   	ret    

0001242b <irq_disable_global>:

// 关中断
void irq_disable_global(void){
   1242b:	55                   	push   %ebp
   1242c:	89 e5                	mov    %esp,%ebp
	cli();
   1242e:	e8 c0 fe ff ff       	call   122f3 <cli>
}
   12433:	90                   	nop
   12434:	5d                   	pop    %ebp
   12435:	c3                   	ret    

00012436 <irq_enable_global>:

// 开中断
void irq_enable_global(void){
   12436:	55                   	push   %ebp
   12437:	89 e5                	mov    %esp,%ebp
	sti();
   12439:	e8 bc fe ff ff       	call   122fa <sti>
}
   1243e:	90                   	nop
   1243f:	5d                   	pop    %ebp
   12440:	c3                   	ret    

00012441 <irq_enable>:

// 开启特定中断
void irq_enable(int irq_num){
   12441:	55                   	push   %ebp
   12442:	89 e5                	mov    %esp,%ebp
   12444:	53                   	push   %ebx
   12445:	83 ec 10             	sub    $0x10,%esp
	if(irq_num < IRQ_PIC_START){
   12448:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
   1244c:	7e 78                	jle    124c6 <irq_enable+0x85>
		return;
	}
	irq_num-=IRQ_PIC_START;
   1244e:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
	if(irq_num<8){
   12452:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   12456:	7f 32                	jg     1248a <irq_enable+0x49>
		uint8_t mask=inb(PIC0_IMR) & ~(1<<irq_num);
   12458:	6a 21                	push   $0x21
   1245a:	e8 a2 fe ff ff       	call   12301 <inb>
   1245f:	83 c4 04             	add    $0x4,%esp
   12462:	89 c2                	mov    %eax,%edx
   12464:	8b 45 08             	mov    0x8(%ebp),%eax
   12467:	bb 01 00 00 00       	mov    $0x1,%ebx
   1246c:	89 c1                	mov    %eax,%ecx
   1246e:	d3 e3                	shl    %cl,%ebx
   12470:	89 d8                	mov    %ebx,%eax
   12472:	f7 d0                	not    %eax
   12474:	21 d0                	and    %edx,%eax
   12476:	88 45 fa             	mov    %al,-0x6(%ebp)
		outb(PIC0_IMR,mask);
   12479:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   1247d:	50                   	push   %eax
   1247e:	6a 21                	push   $0x21
   12480:	e8 99 fe ff ff       	call   1231e <outb>
   12485:	83 c4 08             	add    $0x8,%esp
   12488:	eb 3d                	jmp    124c7 <irq_enable+0x86>
	}
	else{
		irq_num-=8;
   1248a:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
		uint8_t mask=inb(PIC1_IMR) & ~(1<<irq_num);
   1248e:	68 a1 00 00 00       	push   $0xa1
   12493:	e8 69 fe ff ff       	call   12301 <inb>
   12498:	83 c4 04             	add    $0x4,%esp
   1249b:	89 c2                	mov    %eax,%edx
   1249d:	8b 45 08             	mov    0x8(%ebp),%eax
   124a0:	bb 01 00 00 00       	mov    $0x1,%ebx
   124a5:	89 c1                	mov    %eax,%ecx
   124a7:	d3 e3                	shl    %cl,%ebx
   124a9:	89 d8                	mov    %ebx,%eax
   124ab:	f7 d0                	not    %eax
   124ad:	21 d0                	and    %edx,%eax
   124af:	88 45 fb             	mov    %al,-0x5(%ebp)
		outb(PIC1_IMR,mask);
   124b2:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   124b6:	50                   	push   %eax
   124b7:	68 a1 00 00 00       	push   $0xa1
   124bc:	e8 5d fe ff ff       	call   1231e <outb>
   124c1:	83 c4 08             	add    $0x8,%esp
   124c4:	eb 01                	jmp    124c7 <irq_enable+0x86>
		return;
   124c6:	90                   	nop
	}
}
   124c7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   124ca:	c9                   	leave  
   124cb:	c3                   	ret    

000124cc <irq_disable>:

// 关闭特定中断
void irq_disable(int irq_num){
   124cc:	55                   	push   %ebp
   124cd:	89 e5                	mov    %esp,%ebp
   124cf:	53                   	push   %ebx
   124d0:	83 ec 10             	sub    $0x10,%esp
	if(irq_num < IRQ_PIC_START){
   124d3:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
   124d7:	7e 74                	jle    1254d <irq_disable+0x81>
		return;
	}
	irq_num-=IRQ_PIC_START;
   124d9:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
	if(irq_num<8){
   124dd:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   124e1:	7f 30                	jg     12513 <irq_disable+0x47>
		uint8_t mask=inb(PIC0_IMR) | (1<<irq_num);
   124e3:	6a 21                	push   $0x21
   124e5:	e8 17 fe ff ff       	call   12301 <inb>
   124ea:	83 c4 04             	add    $0x4,%esp
   124ed:	89 c3                	mov    %eax,%ebx
   124ef:	8b 45 08             	mov    0x8(%ebp),%eax
   124f2:	ba 01 00 00 00       	mov    $0x1,%edx
   124f7:	89 c1                	mov    %eax,%ecx
   124f9:	d3 e2                	shl    %cl,%edx
   124fb:	89 d0                	mov    %edx,%eax
   124fd:	09 d8                	or     %ebx,%eax
   124ff:	88 45 fa             	mov    %al,-0x6(%ebp)
		outb(PIC0_IMR,mask);
   12502:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   12506:	50                   	push   %eax
   12507:	6a 21                	push   $0x21
   12509:	e8 10 fe ff ff       	call   1231e <outb>
   1250e:	83 c4 08             	add    $0x8,%esp
   12511:	eb 3b                	jmp    1254e <irq_disable+0x82>
	}
	else{
		irq_num-=8;
   12513:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
		uint8_t mask=inb(PIC1_IMR) | (1<<irq_num);
   12517:	68 a1 00 00 00       	push   $0xa1
   1251c:	e8 e0 fd ff ff       	call   12301 <inb>
   12521:	83 c4 04             	add    $0x4,%esp
   12524:	89 c3                	mov    %eax,%ebx
   12526:	8b 45 08             	mov    0x8(%ebp),%eax
   12529:	ba 01 00 00 00       	mov    $0x1,%edx
   1252e:	89 c1                	mov    %eax,%ecx
   12530:	d3 e2                	shl    %cl,%edx
   12532:	89 d0                	mov    %edx,%eax
   12534:	09 d8                	or     %ebx,%eax
   12536:	88 45 fb             	mov    %al,-0x5(%ebp)
		outb(PIC1_IMR,mask);
   12539:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   1253d:	50                   	push   %eax
   1253e:	68 a1 00 00 00       	push   $0xa1
   12543:	e8 d6 fd ff ff       	call   1231e <outb>
   12548:	83 c4 08             	add    $0x8,%esp
   1254b:	eb 01                	jmp    1254e <irq_disable+0x82>
		return;
   1254d:	90                   	nop
	}
}
   1254e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   12551:	c9                   	leave  
   12552:	c3                   	ret    

00012553 <irq_init>:

// 定义中断向量表
static gate_desc_t idt_table[IDT_TABLE_NR];
void irq_init(void){
   12553:	55                   	push   %ebp
   12554:	89 e5                	mov    %esp,%ebp
   12556:	83 ec 18             	sub    $0x18,%esp
    for(uint32_t i=0;i<IDT_TABLE_NR;i++){
   12559:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12560:	eb 25                	jmp    12587 <irq_init+0x34>
        gate_desc_set(idt_table+i,KERNEL_SELECTOR_CS,(uint32_t)exception_handler_unknown,
   12562:	ba 2b 00 01 00       	mov    $0x1002b,%edx
   12567:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1256a:	c1 e0 03             	shl    $0x3,%eax
   1256d:	05 00 10 03 00       	add    $0x31000,%eax
   12572:	68 00 8e 00 00       	push   $0x8e00
   12577:	52                   	push   %edx
   12578:	6a 08                	push   $0x8
   1257a:	50                   	push   %eax
   1257b:	e8 4f fc ff ff       	call   121cf <gate_desc_set>
   12580:	83 c4 10             	add    $0x10,%esp
    for(uint32_t i=0;i<IDT_TABLE_NR;i++){
   12583:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12587:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
   1258b:	76 d5                	jbe    12562 <irq_init+0xf>
        GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_INT);
    }

    
    irq_install(IRQ0_DE, (irq_handler_t)exception_handler_divider);
   1258d:	83 ec 08             	sub    $0x8,%esp
   12590:	68 4a 00 01 00       	push   $0x1004a
   12595:	6a 00                	push   $0x0
   12597:	e8 65 01 00 00       	call   12701 <irq_install>
   1259c:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ1_DB, (irq_handler_t)exception_handler_Debug);
   1259f:	83 ec 08             	sub    $0x8,%esp
   125a2:	68 69 00 01 00       	push   $0x10069
   125a7:	6a 01                	push   $0x1
   125a9:	e8 53 01 00 00       	call   12701 <irq_install>
   125ae:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ2_NMI, (irq_handler_t)exception_handler_NMI);
   125b1:	83 ec 08             	sub    $0x8,%esp
   125b4:	68 88 00 01 00       	push   $0x10088
   125b9:	6a 02                	push   $0x2
   125bb:	e8 41 01 00 00       	call   12701 <irq_install>
   125c0:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ3_BP, (irq_handler_t)exception_handler_breakpoint);
   125c3:	83 ec 08             	sub    $0x8,%esp
   125c6:	68 a7 00 01 00       	push   $0x100a7
   125cb:	6a 03                	push   $0x3
   125cd:	e8 2f 01 00 00       	call   12701 <irq_install>
   125d2:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ4_OF, (irq_handler_t)exception_handler_overflow);
   125d5:	83 ec 08             	sub    $0x8,%esp
   125d8:	68 c6 00 01 00       	push   $0x100c6
   125dd:	6a 04                	push   $0x4
   125df:	e8 1d 01 00 00       	call   12701 <irq_install>
   125e4:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ5_BR, (irq_handler_t)exception_handler_bound_range);
   125e7:	83 ec 08             	sub    $0x8,%esp
   125ea:	68 e5 00 01 00       	push   $0x100e5
   125ef:	6a 05                	push   $0x5
   125f1:	e8 0b 01 00 00       	call   12701 <irq_install>
   125f6:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ6_UD, (irq_handler_t)exception_handler_invalid_opcode);
   125f9:	83 ec 08             	sub    $0x8,%esp
   125fc:	68 04 01 01 00       	push   $0x10104
   12601:	6a 06                	push   $0x6
   12603:	e8 f9 00 00 00       	call   12701 <irq_install>
   12608:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ7_NM, (irq_handler_t)exception_handler_device_unavailable);
   1260b:	83 ec 08             	sub    $0x8,%esp
   1260e:	68 23 01 01 00       	push   $0x10123
   12613:	6a 07                	push   $0x7
   12615:	e8 e7 00 00 00       	call   12701 <irq_install>
   1261a:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ8_DF, (irq_handler_t)exception_handler_double_fault);
   1261d:	83 ec 08             	sub    $0x8,%esp
   12620:	68 42 01 01 00       	push   $0x10142
   12625:	6a 08                	push   $0x8
   12627:	e8 d5 00 00 00       	call   12701 <irq_install>
   1262c:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ10_TS, (irq_handler_t)exception_handler_invalid_tss);
   1262f:	83 ec 08             	sub    $0x8,%esp
   12632:	68 5f 01 01 00       	push   $0x1015f
   12637:	6a 0a                	push   $0xa
   12639:	e8 c3 00 00 00       	call   12701 <irq_install>
   1263e:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ11_NP, (irq_handler_t)exception_handler_segment_not_present);
   12641:	83 ec 08             	sub    $0x8,%esp
   12644:	68 7c 01 01 00       	push   $0x1017c
   12649:	6a 0b                	push   $0xb
   1264b:	e8 b1 00 00 00       	call   12701 <irq_install>
   12650:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ12_SS, (irq_handler_t)exception_handler_stack_segment_fault);
   12653:	83 ec 08             	sub    $0x8,%esp
   12656:	68 99 01 01 00       	push   $0x10199
   1265b:	6a 0c                	push   $0xc
   1265d:	e8 9f 00 00 00       	call   12701 <irq_install>
   12662:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ13_GP, (irq_handler_t)exception_handler_general_protection);
   12665:	83 ec 08             	sub    $0x8,%esp
   12668:	68 b6 01 01 00       	push   $0x101b6
   1266d:	6a 0d                	push   $0xd
   1266f:	e8 8d 00 00 00       	call   12701 <irq_install>
   12674:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ14_PF, (irq_handler_t)exception_handler_page_fault);
   12677:	83 ec 08             	sub    $0x8,%esp
   1267a:	68 d3 01 01 00       	push   $0x101d3
   1267f:	6a 0e                	push   $0xe
   12681:	e8 7b 00 00 00       	call   12701 <irq_install>
   12686:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ16_MF, (irq_handler_t)exception_handler_fpu_error);
   12689:	83 ec 08             	sub    $0x8,%esp
   1268c:	68 f0 01 01 00       	push   $0x101f0
   12691:	6a 10                	push   $0x10
   12693:	e8 69 00 00 00       	call   12701 <irq_install>
   12698:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ17_AC, (irq_handler_t)exception_handler_alignment_check);
   1269b:	83 ec 08             	sub    $0x8,%esp
   1269e:	68 0f 02 01 00       	push   $0x1020f
   126a3:	6a 11                	push   $0x11
   126a5:	e8 57 00 00 00       	call   12701 <irq_install>
   126aa:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ18_MC, (irq_handler_t)exception_handler_machine_check);
   126ad:	83 ec 08             	sub    $0x8,%esp
   126b0:	68 2c 02 01 00       	push   $0x1022c
   126b5:	6a 12                	push   $0x12
   126b7:	e8 45 00 00 00       	call   12701 <irq_install>
   126bc:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ19_XM, (irq_handler_t)exception_handler_smd_exception);
   126bf:	83 ec 08             	sub    $0x8,%esp
   126c2:	68 4b 02 01 00       	push   $0x1024b
   126c7:	6a 13                	push   $0x13
   126c9:	e8 33 00 00 00       	call   12701 <irq_install>
   126ce:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ20_VE, (irq_handler_t)exception_handler_virtual_exception);
   126d1:	83 ec 08             	sub    $0x8,%esp
   126d4:	68 6a 02 01 00       	push   $0x1026a
   126d9:	6a 14                	push   $0x14
   126db:	e8 21 00 00 00       	call   12701 <irq_install>
   126e0:	83 c4 10             	add    $0x10,%esp

    lidt((uint32_t)idt_table,sizeof(idt_table));
   126e3:	b8 00 10 03 00       	mov    $0x31000,%eax
   126e8:	83 ec 08             	sub    $0x8,%esp
   126eb:	68 00 04 00 00       	push   $0x400
   126f0:	50                   	push   %eax
   126f1:	e8 47 fc ff ff       	call   1233d <lidt>
   126f6:	83 c4 10             	add    $0x10,%esp

	// 初始化8259用于开启中断
	init_pic();
   126f9:	e8 9a fc ff ff       	call   12398 <init_pic>

}
   126fe:	90                   	nop
   126ff:	c9                   	leave  
   12700:	c3                   	ret    

00012701 <irq_install>:

// 将对应的中断添加到idt表中
int irq_install(int irq_num,irq_handler_t handler){
   12701:	55                   	push   %ebp
   12702:	89 e5                	mov    %esp,%ebp
   12704:	83 ec 08             	sub    $0x8,%esp
    if(irq_num >= IDT_TABLE_NR){
   12707:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   1270b:	7e 07                	jle    12714 <irq_install+0x13>
        return -1;
   1270d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   12712:	eb 25                	jmp    12739 <irq_install+0x38>
    }
    gate_desc_set(idt_table+irq_num,KERNEL_SELECTOR_CS,(uint32_t)handler,
   12714:	8b 45 0c             	mov    0xc(%ebp),%eax
   12717:	8b 55 08             	mov    0x8(%ebp),%edx
   1271a:	c1 e2 03             	shl    $0x3,%edx
   1271d:	81 c2 00 10 03 00    	add    $0x31000,%edx
   12723:	68 00 8e 00 00       	push   $0x8e00
   12728:	50                   	push   %eax
   12729:	6a 08                	push   $0x8
   1272b:	52                   	push   %edx
   1272c:	e8 9e fa ff ff       	call   121cf <gate_desc_set>
   12731:	83 c4 10             	add    $0x10,%esp
     GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_INT);
    return 0;
   12734:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12739:	c9                   	leave  
   1273a:	c3                   	ret    

0001273b <dump_core_regs>:


static void dump_core_regs(exception_frame_t*frame){
   1273b:	55                   	push   %ebp
   1273c:	89 e5                	mov    %esp,%ebp
   1273e:	57                   	push   %edi
   1273f:	56                   	push   %esi
   12740:	53                   	push   %ebx
   12741:	83 ec 2c             	sub    $0x2c,%esp
	log_printf("IRQ: %d, error code: %d",frame->num,frame->error_code);
   12744:	8b 45 08             	mov    0x8(%ebp),%eax
   12747:	8b 50 34             	mov    0x34(%eax),%edx
   1274a:	8b 45 08             	mov    0x8(%ebp),%eax
   1274d:	8b 40 30             	mov    0x30(%eax),%eax
   12750:	83 ec 04             	sub    $0x4,%esp
   12753:	52                   	push   %edx
   12754:	50                   	push   %eax
   12755:	68 c0 57 01 00       	push   $0x157c0
   1275a:	e8 23 2b 00 00       	call   15282 <log_printf>
   1275f:	83 c4 10             	add    $0x10,%esp
	uint32_t ss,esp;
	if(frame->cs & 0x3){
   12762:	8b 45 08             	mov    0x8(%ebp),%eax
   12765:	8b 40 3c             	mov    0x3c(%eax),%eax
   12768:	83 e0 03             	and    $0x3,%eax
   1276b:	85 c0                	test   %eax,%eax
   1276d:	74 14                	je     12783 <dump_core_regs+0x48>
		ss=frame->ss3;
   1276f:	8b 45 08             	mov    0x8(%ebp),%eax
   12772:	8b 40 48             	mov    0x48(%eax),%eax
   12775:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		esp=frame->esp3;
   12778:	8b 45 08             	mov    0x8(%ebp),%eax
   1277b:	8b 40 44             	mov    0x44(%eax),%eax
   1277e:	89 45 e0             	mov    %eax,-0x20(%ebp)
   12781:	eb 12                	jmp    12795 <dump_core_regs+0x5a>
	}else{
		ss=frame->ds;
   12783:	8b 45 08             	mov    0x8(%ebp),%eax
   12786:	8b 40 0c             	mov    0xc(%eax),%eax
   12789:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		esp=frame->esp;
   1278c:	8b 45 08             	mov    0x8(%ebp),%eax
   1278f:	8b 40 1c             	mov    0x1c(%eax),%eax
   12792:	89 45 e0             	mov    %eax,-0x20(%ebp)
	}
	log_printf("CS: %d\nDS: %d\nES: %d\nSS: %d\nFS: %d\nGS: %d",
   12795:	8b 45 08             	mov    0x8(%ebp),%eax
   12798:	8b 18                	mov    (%eax),%ebx
   1279a:	8b 45 08             	mov    0x8(%ebp),%eax
   1279d:	8b 48 08             	mov    0x8(%eax),%ecx
   127a0:	8b 45 08             	mov    0x8(%ebp),%eax
   127a3:	8b 50 0c             	mov    0xc(%eax),%edx
   127a6:	8b 45 08             	mov    0x8(%ebp),%eax
   127a9:	8b 40 3c             	mov    0x3c(%eax),%eax
   127ac:	83 ec 08             	sub    $0x8,%esp
   127af:	53                   	push   %ebx
   127b0:	ff 75 e4             	pushl  -0x1c(%ebp)
   127b3:	51                   	push   %ecx
   127b4:	52                   	push   %edx
   127b5:	50                   	push   %eax
   127b6:	68 d8 57 01 00       	push   $0x157d8
   127bb:	e8 c2 2a 00 00       	call   15282 <log_printf>
   127c0:	83 c4 20             	add    $0x20,%esp
		frame->cs,frame->ds,frame->es,ss,frame->gs
	);
	log_printf("EAX: 0x%x\nEBX: 0x%x\nECX: 0x%x\nEDX: 0x%x\nEDI: 0x%x\nESI: 0x%x\n"
   127c3:	8b 45 08             	mov    0x8(%ebp),%eax
   127c6:	8b 40 18             	mov    0x18(%eax),%eax
   127c9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   127cc:	8b 45 08             	mov    0x8(%ebp),%eax
   127cf:	8b 78 14             	mov    0x14(%eax),%edi
   127d2:	8b 45 08             	mov    0x8(%ebp),%eax
   127d5:	8b 70 10             	mov    0x10(%eax),%esi
   127d8:	8b 45 08             	mov    0x8(%ebp),%eax
   127db:	8b 58 24             	mov    0x24(%eax),%ebx
   127de:	8b 45 08             	mov    0x8(%ebp),%eax
   127e1:	8b 48 28             	mov    0x28(%eax),%ecx
   127e4:	8b 45 08             	mov    0x8(%ebp),%eax
   127e7:	8b 50 20             	mov    0x20(%eax),%edx
   127ea:	8b 45 08             	mov    0x8(%ebp),%eax
   127ed:	8b 40 2c             	mov    0x2c(%eax),%eax
   127f0:	83 ec 0c             	sub    $0xc,%esp
   127f3:	ff 75 e0             	pushl  -0x20(%ebp)
   127f6:	ff 75 d4             	pushl  -0x2c(%ebp)
   127f9:	57                   	push   %edi
   127fa:	56                   	push   %esi
   127fb:	53                   	push   %ebx
   127fc:	51                   	push   %ecx
   127fd:	52                   	push   %edx
   127fe:	50                   	push   %eax
   127ff:	68 04 58 01 00       	push   $0x15804
   12804:	e8 79 2a 00 00       	call   15282 <log_printf>
   12809:	83 c4 30             	add    $0x30,%esp
	"EBP: 0x%x\nESP: 0x%x",
		frame->eax,frame->ebx,frame->ecx,frame->edx,
		frame->edi,frame->esi,frame->ebp,esp
	);
	log_printf("EIP: 0x%x\nEFLAGS:0x%x\n",frame->eip,frame->eflags);
   1280c:	8b 45 08             	mov    0x8(%ebp),%eax
   1280f:	8b 50 40             	mov    0x40(%eax),%edx
   12812:	8b 45 08             	mov    0x8(%ebp),%eax
   12815:	8b 40 38             	mov    0x38(%eax),%eax
   12818:	83 ec 04             	sub    $0x4,%esp
   1281b:	52                   	push   %edx
   1281c:	50                   	push   %eax
   1281d:	68 54 58 01 00       	push   $0x15854
   12822:	e8 5b 2a 00 00       	call   15282 <log_printf>
   12827:	83 c4 10             	add    $0x10,%esp
}
   1282a:	90                   	nop
   1282b:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1282e:	5b                   	pop    %ebx
   1282f:	5e                   	pop    %esi
   12830:	5f                   	pop    %edi
   12831:	5d                   	pop    %ebp
   12832:	c3                   	ret    

00012833 <do_default_handler>:

static void do_default_handler(exception_frame_t* frame,char* message){
   12833:	55                   	push   %ebp
   12834:	89 e5                	mov    %esp,%ebp
   12836:	83 ec 08             	sub    $0x8,%esp
	log_printf("---------------");
   12839:	83 ec 0c             	sub    $0xc,%esp
   1283c:	68 6b 58 01 00       	push   $0x1586b
   12841:	e8 3c 2a 00 00       	call   15282 <log_printf>
   12846:	83 c4 10             	add    $0x10,%esp
	log_printf("IRQ/Exception happened: %s",message);
   12849:	83 ec 08             	sub    $0x8,%esp
   1284c:	ff 75 0c             	pushl  0xc(%ebp)
   1284f:	68 7b 58 01 00       	push   $0x1587b
   12854:	e8 29 2a 00 00       	call   15282 <log_printf>
   12859:	83 c4 10             	add    $0x10,%esp
	dump_core_regs(frame);
   1285c:	83 ec 0c             	sub    $0xc,%esp
   1285f:	ff 75 08             	pushl  0x8(%ebp)
   12862:	e8 d4 fe ff ff       	call   1273b <dump_core_regs>
   12867:	83 c4 10             	add    $0x10,%esp
    hlt();
   1286a:	e8 f6 fa ff ff       	call   12365 <hlt>
}
   1286f:	90                   	nop
   12870:	c9                   	leave  
   12871:	c3                   	ret    

00012872 <do_handler_unknown>:

// 会被对应exception_handler的call调用
void do_handler_unknown(exception_frame_t* frame){
   12872:	55                   	push   %ebp
   12873:	89 e5                	mov    %esp,%ebp
   12875:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"unknown exception");
   12878:	83 ec 08             	sub    $0x8,%esp
   1287b:	68 96 58 01 00       	push   $0x15896
   12880:	ff 75 08             	pushl  0x8(%ebp)
   12883:	e8 ab ff ff ff       	call   12833 <do_default_handler>
   12888:	83 c4 10             	add    $0x10,%esp
}
   1288b:	90                   	nop
   1288c:	c9                   	leave  
   1288d:	c3                   	ret    

0001288e <do_handler_divider>:

void do_handler_divider(exception_frame_t* frame){
   1288e:	55                   	push   %ebp
   1288f:	89 e5                	mov    %esp,%ebp
   12891:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"Divider exception");
   12894:	83 ec 08             	sub    $0x8,%esp
   12897:	68 a8 58 01 00       	push   $0x158a8
   1289c:	ff 75 08             	pushl  0x8(%ebp)
   1289f:	e8 8f ff ff ff       	call   12833 <do_default_handler>
   128a4:	83 c4 10             	add    $0x10,%esp
}
   128a7:	90                   	nop
   128a8:	c9                   	leave  
   128a9:	c3                   	ret    

000128aa <do_handler_Debug>:

void do_handler_Debug(exception_frame_t * frame) {
   128aa:	55                   	push   %ebp
   128ab:	89 e5                	mov    %esp,%ebp
   128ad:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Debug Exception");
   128b0:	83 ec 08             	sub    $0x8,%esp
   128b3:	68 ba 58 01 00       	push   $0x158ba
   128b8:	ff 75 08             	pushl  0x8(%ebp)
   128bb:	e8 73 ff ff ff       	call   12833 <do_default_handler>
   128c0:	83 c4 10             	add    $0x10,%esp
}
   128c3:	90                   	nop
   128c4:	c9                   	leave  
   128c5:	c3                   	ret    

000128c6 <do_handler_NMI>:

void do_handler_NMI(exception_frame_t * frame) {
   128c6:	55                   	push   %ebp
   128c7:	89 e5                	mov    %esp,%ebp
   128c9:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "NMI Interrupt.");
   128cc:	83 ec 08             	sub    $0x8,%esp
   128cf:	68 ca 58 01 00       	push   $0x158ca
   128d4:	ff 75 08             	pushl  0x8(%ebp)
   128d7:	e8 57 ff ff ff       	call   12833 <do_default_handler>
   128dc:	83 c4 10             	add    $0x10,%esp
}
   128df:	90                   	nop
   128e0:	c9                   	leave  
   128e1:	c3                   	ret    

000128e2 <do_handler_breakpoint>:

void do_handler_breakpoint(exception_frame_t * frame) {
   128e2:	55                   	push   %ebp
   128e3:	89 e5                	mov    %esp,%ebp
   128e5:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Breakpoint.");
   128e8:	83 ec 08             	sub    $0x8,%esp
   128eb:	68 d9 58 01 00       	push   $0x158d9
   128f0:	ff 75 08             	pushl  0x8(%ebp)
   128f3:	e8 3b ff ff ff       	call   12833 <do_default_handler>
   128f8:	83 c4 10             	add    $0x10,%esp
}
   128fb:	90                   	nop
   128fc:	c9                   	leave  
   128fd:	c3                   	ret    

000128fe <do_handler_overflow>:

void do_handler_overflow(exception_frame_t * frame) {
   128fe:	55                   	push   %ebp
   128ff:	89 e5                	mov    %esp,%ebp
   12901:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Overflow.");
   12904:	83 ec 08             	sub    $0x8,%esp
   12907:	68 e5 58 01 00       	push   $0x158e5
   1290c:	ff 75 08             	pushl  0x8(%ebp)
   1290f:	e8 1f ff ff ff       	call   12833 <do_default_handler>
   12914:	83 c4 10             	add    $0x10,%esp
}
   12917:	90                   	nop
   12918:	c9                   	leave  
   12919:	c3                   	ret    

0001291a <do_handler_bound_range>:

void do_handler_bound_range(exception_frame_t * frame) {
   1291a:	55                   	push   %ebp
   1291b:	89 e5                	mov    %esp,%ebp
   1291d:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "BOUND Range Exceeded.");
   12920:	83 ec 08             	sub    $0x8,%esp
   12923:	68 ef 58 01 00       	push   $0x158ef
   12928:	ff 75 08             	pushl  0x8(%ebp)
   1292b:	e8 03 ff ff ff       	call   12833 <do_default_handler>
   12930:	83 c4 10             	add    $0x10,%esp
}
   12933:	90                   	nop
   12934:	c9                   	leave  
   12935:	c3                   	ret    

00012936 <do_handler_invalid_opcode>:

void do_handler_invalid_opcode(exception_frame_t * frame) {
   12936:	55                   	push   %ebp
   12937:	89 e5                	mov    %esp,%ebp
   12939:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Invalid Opcode.");
   1293c:	83 ec 08             	sub    $0x8,%esp
   1293f:	68 05 59 01 00       	push   $0x15905
   12944:	ff 75 08             	pushl  0x8(%ebp)
   12947:	e8 e7 fe ff ff       	call   12833 <do_default_handler>
   1294c:	83 c4 10             	add    $0x10,%esp
}
   1294f:	90                   	nop
   12950:	c9                   	leave  
   12951:	c3                   	ret    

00012952 <do_handler_device_unavailable>:

void do_handler_device_unavailable(exception_frame_t * frame) {
   12952:	55                   	push   %ebp
   12953:	89 e5                	mov    %esp,%ebp
   12955:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Device Not Available.");
   12958:	83 ec 08             	sub    $0x8,%esp
   1295b:	68 15 59 01 00       	push   $0x15915
   12960:	ff 75 08             	pushl  0x8(%ebp)
   12963:	e8 cb fe ff ff       	call   12833 <do_default_handler>
   12968:	83 c4 10             	add    $0x10,%esp
}
   1296b:	90                   	nop
   1296c:	c9                   	leave  
   1296d:	c3                   	ret    

0001296e <do_handler_double_fault>:

void do_handler_double_fault(exception_frame_t * frame) {
   1296e:	55                   	push   %ebp
   1296f:	89 e5                	mov    %esp,%ebp
   12971:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Double Fault.");
   12974:	83 ec 08             	sub    $0x8,%esp
   12977:	68 2b 59 01 00       	push   $0x1592b
   1297c:	ff 75 08             	pushl  0x8(%ebp)
   1297f:	e8 af fe ff ff       	call   12833 <do_default_handler>
   12984:	83 c4 10             	add    $0x10,%esp
}
   12987:	90                   	nop
   12988:	c9                   	leave  
   12989:	c3                   	ret    

0001298a <do_handler_invalid_tss>:

void do_handler_invalid_tss(exception_frame_t * frame) {
   1298a:	55                   	push   %ebp
   1298b:	89 e5                	mov    %esp,%ebp
   1298d:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Invalid TSS");
   12990:	83 ec 08             	sub    $0x8,%esp
   12993:	68 39 59 01 00       	push   $0x15939
   12998:	ff 75 08             	pushl  0x8(%ebp)
   1299b:	e8 93 fe ff ff       	call   12833 <do_default_handler>
   129a0:	83 c4 10             	add    $0x10,%esp
}
   129a3:	90                   	nop
   129a4:	c9                   	leave  
   129a5:	c3                   	ret    

000129a6 <do_handler_segment_not_present>:

void do_handler_segment_not_present(exception_frame_t * frame) {
   129a6:	55                   	push   %ebp
   129a7:	89 e5                	mov    %esp,%ebp
   129a9:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Segment Not Present.");
   129ac:	83 ec 08             	sub    $0x8,%esp
   129af:	68 45 59 01 00       	push   $0x15945
   129b4:	ff 75 08             	pushl  0x8(%ebp)
   129b7:	e8 77 fe ff ff       	call   12833 <do_default_handler>
   129bc:	83 c4 10             	add    $0x10,%esp
}
   129bf:	90                   	nop
   129c0:	c9                   	leave  
   129c1:	c3                   	ret    

000129c2 <do_handler_stack_segment_fault>:

void do_handler_stack_segment_fault(exception_frame_t * frame) {
   129c2:	55                   	push   %ebp
   129c3:	89 e5                	mov    %esp,%ebp
   129c5:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Stack-Segment Fault.");
   129c8:	83 ec 08             	sub    $0x8,%esp
   129cb:	68 5a 59 01 00       	push   $0x1595a
   129d0:	ff 75 08             	pushl  0x8(%ebp)
   129d3:	e8 5b fe ff ff       	call   12833 <do_default_handler>
   129d8:	83 c4 10             	add    $0x10,%esp
}
   129db:	90                   	nop
   129dc:	c9                   	leave  
   129dd:	c3                   	ret    

000129de <do_handler_general_protection>:

void do_handler_general_protection(exception_frame_t * frame) {
   129de:	55                   	push   %ebp
   129df:	89 e5                	mov    %esp,%ebp
   129e1:	83 ec 08             	sub    $0x8,%esp
	log_printf("--------------------------------");
   129e4:	83 ec 0c             	sub    $0xc,%esp
   129e7:	68 70 59 01 00       	push   $0x15970
   129ec:	e8 91 28 00 00       	call   15282 <log_printf>
   129f1:	83 c4 10             	add    $0x10,%esp
    log_printf("IRQ/Exception happend: General Protection.");
   129f4:	83 ec 0c             	sub    $0xc,%esp
   129f7:	68 94 59 01 00       	push   $0x15994
   129fc:	e8 81 28 00 00       	call   15282 <log_printf>
   12a01:	83 c4 10             	add    $0x10,%esp
    if (frame->error_code & ERR_EXT) {
   12a04:	8b 45 08             	mov    0x8(%ebp),%eax
   12a07:	8b 40 34             	mov    0x34(%eax),%eax
   12a0a:	83 e0 01             	and    $0x1,%eax
   12a0d:	85 c0                	test   %eax,%eax
   12a0f:	74 12                	je     12a23 <do_handler_general_protection+0x45>
        log_printf("the exception occurred during delivery of an "
   12a11:	83 ec 0c             	sub    $0xc,%esp
   12a14:	68 c0 59 01 00       	push   $0x159c0
   12a19:	e8 64 28 00 00       	call   15282 <log_printf>
   12a1e:	83 c4 10             	add    $0x10,%esp
   12a21:	eb 10                	jmp    12a33 <do_handler_general_protection+0x55>
                "event external to the program, such as an interrupt"
                "or an earlier exception.");
    } else {
        log_printf("the exception occurred during delivery of a"
   12a23:	83 ec 0c             	sub    $0xc,%esp
   12a26:	68 3c 5a 01 00       	push   $0x15a3c
   12a2b:	e8 52 28 00 00       	call   15282 <log_printf>
   12a30:	83 c4 10             	add    $0x10,%esp
                    "software interrupt (INT n, INT3, or INTO).");
    }
    
    if (frame->error_code & ERR_IDT) {
   12a33:	8b 45 08             	mov    0x8(%ebp),%eax
   12a36:	8b 40 34             	mov    0x34(%eax),%eax
   12a39:	83 e0 02             	and    $0x2,%eax
   12a3c:	85 c0                	test   %eax,%eax
   12a3e:	74 12                	je     12a52 <do_handler_general_protection+0x74>
        log_printf("the index portion of the error code refers "
   12a40:	83 ec 0c             	sub    $0xc,%esp
   12a43:	68 94 5a 01 00       	push   $0x15a94
   12a48:	e8 35 28 00 00       	call   15282 <log_printf>
   12a4d:	83 c4 10             	add    $0x10,%esp
   12a50:	eb 10                	jmp    12a62 <do_handler_general_protection+0x84>
                    "to a gate descriptor in the IDT");
    } else {
        log_printf("the index refers to a descriptor in the GDT");
   12a52:	83 ec 0c             	sub    $0xc,%esp
   12a55:	68 e0 5a 01 00       	push   $0x15ae0
   12a5a:	e8 23 28 00 00       	call   15282 <log_printf>
   12a5f:	83 c4 10             	add    $0x10,%esp
    }
    
    log_printf("segment index: %d", frame->error_code & 0xFFF8);
   12a62:	8b 45 08             	mov    0x8(%ebp),%eax
   12a65:	8b 40 34             	mov    0x34(%eax),%eax
   12a68:	25 f8 ff 00 00       	and    $0xfff8,%eax
   12a6d:	83 ec 08             	sub    $0x8,%esp
   12a70:	50                   	push   %eax
   12a71:	68 0c 5b 01 00       	push   $0x15b0c
   12a76:	e8 07 28 00 00       	call   15282 <log_printf>
   12a7b:	83 c4 10             	add    $0x10,%esp

    dump_core_regs(frame);
   12a7e:	83 ec 0c             	sub    $0xc,%esp
   12a81:	ff 75 08             	pushl  0x8(%ebp)
   12a84:	e8 b2 fc ff ff       	call   1273b <dump_core_regs>
   12a89:	83 c4 10             	add    $0x10,%esp
    while (1) {
        hlt();
   12a8c:	e8 d4 f8 ff ff       	call   12365 <hlt>
   12a91:	eb f9                	jmp    12a8c <do_handler_general_protection+0xae>

00012a93 <do_handler_page_fault>:
    }	
}

void do_handler_page_fault(exception_frame_t * frame) {
   12a93:	55                   	push   %ebp
   12a94:	89 e5                	mov    %esp,%ebp
   12a96:	83 ec 08             	sub    $0x8,%esp
	log_printf("--------------------------------");
   12a99:	83 ec 0c             	sub    $0xc,%esp
   12a9c:	68 70 59 01 00       	push   $0x15970
   12aa1:	e8 dc 27 00 00       	call   15282 <log_printf>
   12aa6:	83 c4 10             	add    $0x10,%esp
    log_printf("IRQ/Exception happend: Page fault.");
   12aa9:	83 ec 0c             	sub    $0xc,%esp
   12aac:	68 20 5b 01 00       	push   $0x15b20
   12ab1:	e8 cc 27 00 00       	call   15282 <log_printf>
   12ab6:	83 c4 10             	add    $0x10,%esp
    if (frame->error_code & ERR_PAGE_P) {
   12ab9:	8b 45 08             	mov    0x8(%ebp),%eax
   12abc:	8b 40 34             	mov    0x34(%eax),%eax
   12abf:	83 e0 01             	and    $0x1,%eax
   12ac2:	85 c0                	test   %eax,%eax
   12ac4:	74 18                	je     12ade <do_handler_page_fault+0x4b>
        log_printf("\tpage-level protection violation: 0x%x.", read_cr2());
   12ac6:	e8 bc f8 ff ff       	call   12387 <read_cr2>
   12acb:	83 ec 08             	sub    $0x8,%esp
   12ace:	50                   	push   %eax
   12acf:	68 44 5b 01 00       	push   $0x15b44
   12ad4:	e8 a9 27 00 00       	call   15282 <log_printf>
   12ad9:	83 c4 10             	add    $0x10,%esp
   12adc:	eb 16                	jmp    12af4 <do_handler_page_fault+0x61>
    } else {
         log_printf("\tPage doesn't present 0x%x", read_cr2());
   12ade:	e8 a4 f8 ff ff       	call   12387 <read_cr2>
   12ae3:	83 ec 08             	sub    $0x8,%esp
   12ae6:	50                   	push   %eax
   12ae7:	68 6c 5b 01 00       	push   $0x15b6c
   12aec:	e8 91 27 00 00       	call   15282 <log_printf>
   12af1:	83 c4 10             	add    $0x10,%esp
   }
    
    if (frame->error_code & ERR_PAGE_WR) {
   12af4:	8b 45 08             	mov    0x8(%ebp),%eax
   12af7:	8b 40 34             	mov    0x34(%eax),%eax
   12afa:	83 e0 02             	and    $0x2,%eax
   12afd:	85 c0                	test   %eax,%eax
   12aff:	74 12                	je     12b13 <do_handler_page_fault+0x80>
        log_printf("\tThe access causing the fault was a read.");
   12b01:	83 ec 0c             	sub    $0xc,%esp
   12b04:	68 88 5b 01 00       	push   $0x15b88
   12b09:	e8 74 27 00 00       	call   15282 <log_printf>
   12b0e:	83 c4 10             	add    $0x10,%esp
   12b11:	eb 10                	jmp    12b23 <do_handler_page_fault+0x90>
    } else {
        log_printf("\tThe access causing the fault was a write.");
   12b13:	83 ec 0c             	sub    $0xc,%esp
   12b16:	68 b4 5b 01 00       	push   $0x15bb4
   12b1b:	e8 62 27 00 00       	call   15282 <log_printf>
   12b20:	83 c4 10             	add    $0x10,%esp
    }
    
    if (frame->error_code & ERR_PAGE_US) {
   12b23:	8b 45 08             	mov    0x8(%ebp),%eax
   12b26:	8b 40 34             	mov    0x34(%eax),%eax
   12b29:	83 e0 02             	and    $0x2,%eax
   12b2c:	85 c0                	test   %eax,%eax
   12b2e:	74 12                	je     12b42 <do_handler_page_fault+0xaf>
        log_printf("\tA supervisor-mode access caused the fault.");
   12b30:	83 ec 0c             	sub    $0xc,%esp
   12b33:	68 e0 5b 01 00       	push   $0x15be0
   12b38:	e8 45 27 00 00       	call   15282 <log_printf>
   12b3d:	83 c4 10             	add    $0x10,%esp
   12b40:	eb 10                	jmp    12b52 <do_handler_page_fault+0xbf>
    } else {
        log_printf("\tA user-mode access caused the fault.");
   12b42:	83 ec 0c             	sub    $0xc,%esp
   12b45:	68 0c 5c 01 00       	push   $0x15c0c
   12b4a:	e8 33 27 00 00       	call   15282 <log_printf>
   12b4f:	83 c4 10             	add    $0x10,%esp
    }

    dump_core_regs(frame);
   12b52:	83 ec 0c             	sub    $0xc,%esp
   12b55:	ff 75 08             	pushl  0x8(%ebp)
   12b58:	e8 de fb ff ff       	call   1273b <dump_core_regs>
   12b5d:	83 c4 10             	add    $0x10,%esp
    while (1) {
        hlt();
   12b60:	e8 00 f8 ff ff       	call   12365 <hlt>
   12b65:	eb f9                	jmp    12b60 <do_handler_page_fault+0xcd>

00012b67 <do_handler_fpu_error>:
    }
}

void do_handler_fpu_error(exception_frame_t * frame) {
   12b67:	55                   	push   %ebp
   12b68:	89 e5                	mov    %esp,%ebp
   12b6a:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "X87 FPU Floating Point Error.");
   12b6d:	83 ec 08             	sub    $0x8,%esp
   12b70:	68 32 5c 01 00       	push   $0x15c32
   12b75:	ff 75 08             	pushl  0x8(%ebp)
   12b78:	e8 b6 fc ff ff       	call   12833 <do_default_handler>
   12b7d:	83 c4 10             	add    $0x10,%esp
}
   12b80:	90                   	nop
   12b81:	c9                   	leave  
   12b82:	c3                   	ret    

00012b83 <do_handler_alignment_check>:

void do_handler_alignment_check(exception_frame_t * frame) {
   12b83:	55                   	push   %ebp
   12b84:	89 e5                	mov    %esp,%ebp
   12b86:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Alignment Check.");
   12b89:	83 ec 08             	sub    $0x8,%esp
   12b8c:	68 50 5c 01 00       	push   $0x15c50
   12b91:	ff 75 08             	pushl  0x8(%ebp)
   12b94:	e8 9a fc ff ff       	call   12833 <do_default_handler>
   12b99:	83 c4 10             	add    $0x10,%esp
}
   12b9c:	90                   	nop
   12b9d:	c9                   	leave  
   12b9e:	c3                   	ret    

00012b9f <do_handler_machine_check>:

void do_handler_machine_check(exception_frame_t * frame) {
   12b9f:	55                   	push   %ebp
   12ba0:	89 e5                	mov    %esp,%ebp
   12ba2:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Machine Check.");
   12ba5:	83 ec 08             	sub    $0x8,%esp
   12ba8:	68 61 5c 01 00       	push   $0x15c61
   12bad:	ff 75 08             	pushl  0x8(%ebp)
   12bb0:	e8 7e fc ff ff       	call   12833 <do_default_handler>
   12bb5:	83 c4 10             	add    $0x10,%esp
}
   12bb8:	90                   	nop
   12bb9:	c9                   	leave  
   12bba:	c3                   	ret    

00012bbb <do_handler_smd_exception>:

void do_handler_smd_exception(exception_frame_t * frame) {
   12bbb:	55                   	push   %ebp
   12bbc:	89 e5                	mov    %esp,%ebp
   12bbe:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "SIMD Floating Point Exception.");
   12bc1:	83 ec 08             	sub    $0x8,%esp
   12bc4:	68 70 5c 01 00       	push   $0x15c70
   12bc9:	ff 75 08             	pushl  0x8(%ebp)
   12bcc:	e8 62 fc ff ff       	call   12833 <do_default_handler>
   12bd1:	83 c4 10             	add    $0x10,%esp
}
   12bd4:	90                   	nop
   12bd5:	c9                   	leave  
   12bd6:	c3                   	ret    

00012bd7 <do_handler_virtual_exception>:

void do_handler_virtual_exception(exception_frame_t * frame) {
   12bd7:	55                   	push   %ebp
   12bd8:	89 e5                	mov    %esp,%ebp
   12bda:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Virtualization Exception.");
   12bdd:	83 ec 08             	sub    $0x8,%esp
   12be0:	68 8f 5c 01 00       	push   $0x15c8f
   12be5:	ff 75 08             	pushl  0x8(%ebp)
   12be8:	e8 46 fc ff ff       	call   12833 <do_default_handler>
   12bed:	83 c4 10             	add    $0x10,%esp
}
   12bf0:	90                   	nop
   12bf1:	c9                   	leave  
   12bf2:	c3                   	ret    

00012bf3 <pic_send_eoi>:

void pic_send_eoi(int irq_num){
   12bf3:	55                   	push   %ebp
   12bf4:	89 e5                	mov    %esp,%ebp
	irq_num-=IRQ_PIC_START;
   12bf6:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
	if(irq_num >=8){
   12bfa:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   12bfe:	7e 0f                	jle    12c0f <pic_send_eoi+0x1c>
		outb(PIC1_OCW2,PIC_OCW2_EOI);
   12c00:	6a 20                	push   $0x20
   12c02:	68 a0 00 00 00       	push   $0xa0
   12c07:	e8 12 f7 ff ff       	call   1231e <outb>
   12c0c:	83 c4 08             	add    $0x8,%esp
	}
	outb(PIC0_OCW2,PIC_OCW2_EOI);
   12c0f:	6a 20                	push   $0x20
   12c11:	6a 20                	push   $0x20
   12c13:	e8 06 f7 ff ff       	call   1231e <outb>
   12c18:	83 c4 08             	add    $0x8,%esp
}
   12c1b:	90                   	nop
   12c1c:	c9                   	leave  
   12c1d:	c3                   	ret    

00012c1e <irq_enter_protection>:

// 进入临界区
irq_state_t irq_enter_protection(void){
   12c1e:	55                   	push   %ebp
   12c1f:	89 e5                	mov    %esp,%ebp
   12c21:	83 ec 10             	sub    $0x10,%esp
	irq_state_t state=read_eflags();
   12c24:	e8 43 f7 ff ff       	call   1236c <read_eflags>
   12c29:	89 45 fc             	mov    %eax,-0x4(%ebp)
	irq_disable_global();
   12c2c:	e8 fa f7 ff ff       	call   1242b <irq_disable_global>
	return state;
   12c31:	8b 45 fc             	mov    -0x4(%ebp),%eax
	
}
   12c34:	c9                   	leave  
   12c35:	c3                   	ret    

00012c36 <irq_leave_protection>:

// 退出临界区
void irq_leave_protection(irq_state_t state){
   12c36:	55                   	push   %ebp
   12c37:	89 e5                	mov    %esp,%ebp
	write_eflags(state);
   12c39:	ff 75 08             	pushl  0x8(%ebp)
   12c3c:	e8 3b f7 ff ff       	call   1237c <write_eflags>
   12c41:	83 c4 04             	add    $0x4,%esp
}
   12c44:	90                   	nop
   12c45:	c9                   	leave  
   12c46:	c3                   	ret    

00012c47 <inb>:
static inline uint8_t inb(uint16_t port){
   12c47:	55                   	push   %ebp
   12c48:	89 e5                	mov    %esp,%ebp
   12c4a:	83 ec 14             	sub    $0x14,%esp
   12c4d:	8b 45 08             	mov    0x8(%ebp),%eax
   12c50:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__(
   12c54:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   12c58:	89 c2                	mov    %eax,%edx
   12c5a:	ec                   	in     (%dx),%al
   12c5b:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   12c5e:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   12c62:	c9                   	leave  
   12c63:	c3                   	ret    

00012c64 <outb>:
static inline void outb(uint16_t port,uint8_t data){
   12c64:	55                   	push   %ebp
   12c65:	89 e5                	mov    %esp,%ebp
   12c67:	83 ec 08             	sub    $0x8,%esp
   12c6a:	8b 55 08             	mov    0x8(%ebp),%edx
   12c6d:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c70:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   12c74:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile(
   12c77:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   12c7b:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   12c7f:	ee                   	out    %al,(%dx)
}
   12c80:	90                   	nop
   12c81:	c9                   	leave  
   12c82:	c3                   	ret    

00012c83 <read_cursor_pos>:

#define CONSOLE_NR  8

static console_t console_buf[CONSOLE_NR];

static int read_cursor_pos(void){
   12c83:	55                   	push   %ebp
   12c84:	89 e5                	mov    %esp,%ebp
   12c86:	83 ec 10             	sub    $0x10,%esp
    int pos;

    outb(0x3D4,0xF);
   12c89:	6a 0f                	push   $0xf
   12c8b:	68 d4 03 00 00       	push   $0x3d4
   12c90:	e8 cf ff ff ff       	call   12c64 <outb>
   12c95:	83 c4 08             	add    $0x8,%esp
    pos=inb(0x3d5);
   12c98:	68 d5 03 00 00       	push   $0x3d5
   12c9d:	e8 a5 ff ff ff       	call   12c47 <inb>
   12ca2:	83 c4 04             	add    $0x4,%esp
   12ca5:	0f b6 c0             	movzbl %al,%eax
   12ca8:	89 45 fc             	mov    %eax,-0x4(%ebp)
    outb(0x3D4,0xE);
   12cab:	6a 0e                	push   $0xe
   12cad:	68 d4 03 00 00       	push   $0x3d4
   12cb2:	e8 ad ff ff ff       	call   12c64 <outb>
   12cb7:	83 c4 08             	add    $0x8,%esp
    pos |= inb(0x3d5) << 8;
   12cba:	68 d5 03 00 00       	push   $0x3d5
   12cbf:	e8 83 ff ff ff       	call   12c47 <inb>
   12cc4:	83 c4 04             	add    $0x4,%esp
   12cc7:	0f b6 c0             	movzbl %al,%eax
   12cca:	c1 e0 08             	shl    $0x8,%eax
   12ccd:	09 45 fc             	or     %eax,-0x4(%ebp)
    return pos;
   12cd0:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   12cd3:	c9                   	leave  
   12cd4:	c3                   	ret    

00012cd5 <update_cursor_pos>:

static int update_cursor_pos(console_t* console){
   12cd5:	55                   	push   %ebp
   12cd6:	89 e5                	mov    %esp,%ebp
   12cd8:	83 ec 10             	sub    $0x10,%esp
    uint16_t pos=console->cursor_row*console->display_cols+console->cursor_col;
   12cdb:	8b 45 08             	mov    0x8(%ebp),%eax
   12cde:	8b 40 08             	mov    0x8(%eax),%eax
   12ce1:	89 c2                	mov    %eax,%edx
   12ce3:	8b 45 08             	mov    0x8(%ebp),%eax
   12ce6:	8b 40 14             	mov    0x14(%eax),%eax
   12ce9:	0f af d0             	imul   %eax,%edx
   12cec:	8b 45 08             	mov    0x8(%ebp),%eax
   12cef:	8b 40 0c             	mov    0xc(%eax),%eax
   12cf2:	01 d0                	add    %edx,%eax
   12cf4:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

    // 获取低八位和高八位
    outb(0x3D4,0xF);
   12cf8:	6a 0f                	push   $0xf
   12cfa:	68 d4 03 00 00       	push   $0x3d4
   12cff:	e8 60 ff ff ff       	call   12c64 <outb>
   12d04:	83 c4 08             	add    $0x8,%esp
    outb(0x3D5,(uint8_t)(pos & 0xFF));
   12d07:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
   12d0b:	0f b6 c0             	movzbl %al,%eax
   12d0e:	50                   	push   %eax
   12d0f:	68 d5 03 00 00       	push   $0x3d5
   12d14:	e8 4b ff ff ff       	call   12c64 <outb>
   12d19:	83 c4 08             	add    $0x8,%esp
    outb(0x3D4,0xE);
   12d1c:	6a 0e                	push   $0xe
   12d1e:	68 d4 03 00 00       	push   $0x3d4
   12d23:	e8 3c ff ff ff       	call   12c64 <outb>
   12d28:	83 c4 08             	add    $0x8,%esp
    outb(0x3D5,(uint8_t)((pos >> 8) & 0xFF));
   12d2b:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
   12d2f:	66 c1 e8 08          	shr    $0x8,%ax
   12d33:	0f b6 c0             	movzbl %al,%eax
   12d36:	50                   	push   %eax
   12d37:	68 d5 03 00 00       	push   $0x3d5
   12d3c:	e8 23 ff ff ff       	call   12c64 <outb>
   12d41:	83 c4 08             	add    $0x8,%esp

    return pos;
   12d44:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
}
   12d48:	c9                   	leave  
   12d49:	c3                   	ret    

00012d4a <erase_rows>:

static void erase_rows(console_t*console,int start,int end){
   12d4a:	55                   	push   %ebp
   12d4b:	89 e5                	mov    %esp,%ebp
   12d4d:	83 ec 10             	sub    $0x10,%esp
    disp_char_t* disp_start=console->disp_base+console->display_cols*start;
   12d50:	8b 45 08             	mov    0x8(%ebp),%eax
   12d53:	8b 50 04             	mov    0x4(%eax),%edx
   12d56:	8b 45 08             	mov    0x8(%ebp),%eax
   12d59:	8b 40 14             	mov    0x14(%eax),%eax
   12d5c:	0f af 45 0c          	imul   0xc(%ebp),%eax
   12d60:	01 c0                	add    %eax,%eax
   12d62:	01 d0                	add    %edx,%eax
   12d64:	89 45 fc             	mov    %eax,-0x4(%ebp)
    disp_char_t* disp_end=console->disp_base+console->display_cols*(end+1);
   12d67:	8b 45 08             	mov    0x8(%ebp),%eax
   12d6a:	8b 50 04             	mov    0x4(%eax),%edx
   12d6d:	8b 45 08             	mov    0x8(%ebp),%eax
   12d70:	8b 40 14             	mov    0x14(%eax),%eax
   12d73:	8b 4d 10             	mov    0x10(%ebp),%ecx
   12d76:	83 c1 01             	add    $0x1,%ecx
   12d79:	0f af c1             	imul   %ecx,%eax
   12d7c:	01 c0                	add    %eax,%eax
   12d7e:	01 d0                	add    %edx,%eax
   12d80:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while(disp_start < disp_end){
   12d83:	eb 4d                	jmp    12dd2 <erase_rows+0x88>
        disp_start->c=' ';
   12d85:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12d88:	c6 00 20             	movb   $0x20,(%eax)
        disp_start->foreground=console->foreground;
   12d8b:	8b 45 08             	mov    0x8(%ebp),%eax
   12d8e:	8b 40 18             	mov    0x18(%eax),%eax
   12d91:	c1 e0 04             	shl    $0x4,%eax
   12d94:	c0 f8 04             	sar    $0x4,%al
   12d97:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12d9a:	83 e0 0f             	and    $0xf,%eax
   12d9d:	89 c1                	mov    %eax,%ecx
   12d9f:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   12da3:	83 e0 f0             	and    $0xfffffff0,%eax
   12da6:	09 c8                	or     %ecx,%eax
   12da8:	88 42 01             	mov    %al,0x1(%edx)
        disp_start->background=console->background;
   12dab:	8b 45 08             	mov    0x8(%ebp),%eax
   12dae:	8b 40 1c             	mov    0x1c(%eax),%eax
   12db1:	c1 e0 05             	shl    $0x5,%eax
   12db4:	c0 f8 05             	sar    $0x5,%al
   12db7:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12dba:	83 e0 07             	and    $0x7,%eax
   12dbd:	c1 e0 04             	shl    $0x4,%eax
   12dc0:	89 c1                	mov    %eax,%ecx
   12dc2:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   12dc6:	83 e0 8f             	and    $0xffffff8f,%eax
   12dc9:	09 c8                	or     %ecx,%eax
   12dcb:	88 42 01             	mov    %al,0x1(%edx)

        disp_start++;
   12dce:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
    while(disp_start < disp_end){
   12dd2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12dd5:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   12dd8:	72 ab                	jb     12d85 <erase_rows+0x3b>
    }
}
   12dda:	90                   	nop
   12ddb:	c9                   	leave  
   12ddc:	c3                   	ret    

00012ddd <scroll_up>:

static void scroll_up(console_t* console,int lines){
   12ddd:	55                   	push   %ebp
   12dde:	89 e5                	mov    %esp,%ebp
   12de0:	83 ec 18             	sub    $0x18,%esp
    disp_char_t* dest=console->disp_base;
   12de3:	8b 45 08             	mov    0x8(%ebp),%eax
   12de6:	8b 40 04             	mov    0x4(%eax),%eax
   12de9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    disp_char_t* src=console->disp_base+console->display_cols*lines;
   12dec:	8b 45 08             	mov    0x8(%ebp),%eax
   12def:	8b 50 04             	mov    0x4(%eax),%edx
   12df2:	8b 45 08             	mov    0x8(%ebp),%eax
   12df5:	8b 40 14             	mov    0x14(%eax),%eax
   12df8:	0f af 45 0c          	imul   0xc(%ebp),%eax
   12dfc:	01 c0                	add    %eax,%eax
   12dfe:	01 d0                	add    %edx,%eax
   12e00:	89 45 f0             	mov    %eax,-0x10(%ebp)

    uint32_t size=(console->display_rows-lines)*console->display_cols*sizeof(disp_char_t);
   12e03:	8b 45 08             	mov    0x8(%ebp),%eax
   12e06:	8b 40 10             	mov    0x10(%eax),%eax
   12e09:	2b 45 0c             	sub    0xc(%ebp),%eax
   12e0c:	89 c2                	mov    %eax,%edx
   12e0e:	8b 45 08             	mov    0x8(%ebp),%eax
   12e11:	8b 40 14             	mov    0x14(%eax),%eax
   12e14:	0f af c2             	imul   %edx,%eax
   12e17:	01 c0                	add    %eax,%eax
   12e19:	89 45 ec             	mov    %eax,-0x14(%ebp)
    kernel_memcpy(dest,src,size);
   12e1c:	83 ec 04             	sub    $0x4,%esp
   12e1f:	ff 75 ec             	pushl  -0x14(%ebp)
   12e22:	ff 75 f0             	pushl  -0x10(%ebp)
   12e25:	ff 75 f4             	pushl  -0xc(%ebp)
   12e28:	e8 e3 1d 00 00       	call   14c10 <kernel_memcpy>
   12e2d:	83 c4 10             	add    $0x10,%esp

    erase_rows(console,console->display_rows-lines,console->display_rows-1);
   12e30:	8b 45 08             	mov    0x8(%ebp),%eax
   12e33:	8b 40 10             	mov    0x10(%eax),%eax
   12e36:	8d 50 ff             	lea    -0x1(%eax),%edx
   12e39:	8b 45 08             	mov    0x8(%ebp),%eax
   12e3c:	8b 40 10             	mov    0x10(%eax),%eax
   12e3f:	2b 45 0c             	sub    0xc(%ebp),%eax
   12e42:	83 ec 04             	sub    $0x4,%esp
   12e45:	52                   	push   %edx
   12e46:	50                   	push   %eax
   12e47:	ff 75 08             	pushl  0x8(%ebp)
   12e4a:	e8 fb fe ff ff       	call   12d4a <erase_rows>
   12e4f:	83 c4 10             	add    $0x10,%esp
    console->cursor_row-=lines;
   12e52:	8b 45 08             	mov    0x8(%ebp),%eax
   12e55:	8b 40 08             	mov    0x8(%eax),%eax
   12e58:	2b 45 0c             	sub    0xc(%ebp),%eax
   12e5b:	89 c2                	mov    %eax,%edx
   12e5d:	8b 45 08             	mov    0x8(%ebp),%eax
   12e60:	89 50 08             	mov    %edx,0x8(%eax)
}
   12e63:	90                   	nop
   12e64:	c9                   	leave  
   12e65:	c3                   	ret    

00012e66 <clear_display>:

static void clear_display(console_t*console){
   12e66:	55                   	push   %ebp
   12e67:	89 e5                	mov    %esp,%ebp
   12e69:	83 ec 10             	sub    $0x10,%esp
    int size=console->display_cols*console->display_rows;
   12e6c:	8b 45 08             	mov    0x8(%ebp),%eax
   12e6f:	8b 50 14             	mov    0x14(%eax),%edx
   12e72:	8b 45 08             	mov    0x8(%ebp),%eax
   12e75:	8b 40 10             	mov    0x10(%eax),%eax
   12e78:	0f af c2             	imul   %edx,%eax
   12e7b:	89 45 f4             	mov    %eax,-0xc(%ebp)

    disp_char_t* start=console->disp_base;
   12e7e:	8b 45 08             	mov    0x8(%ebp),%eax
   12e81:	8b 40 04             	mov    0x4(%eax),%eax
   12e84:	89 45 fc             	mov    %eax,-0x4(%ebp)
    for(int i=0;i<size;i++,start++){
   12e87:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   12e8e:	eb 51                	jmp    12ee1 <clear_display+0x7b>
        start->c=' ';
   12e90:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12e93:	c6 00 20             	movb   $0x20,(%eax)
        start->foreground=console->foreground;
   12e96:	8b 45 08             	mov    0x8(%ebp),%eax
   12e99:	8b 40 18             	mov    0x18(%eax),%eax
   12e9c:	c1 e0 04             	shl    $0x4,%eax
   12e9f:	c0 f8 04             	sar    $0x4,%al
   12ea2:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12ea5:	83 e0 0f             	and    $0xf,%eax
   12ea8:	89 c1                	mov    %eax,%ecx
   12eaa:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   12eae:	83 e0 f0             	and    $0xfffffff0,%eax
   12eb1:	09 c8                	or     %ecx,%eax
   12eb3:	88 42 01             	mov    %al,0x1(%edx)
        start->background=console->background; 
   12eb6:	8b 45 08             	mov    0x8(%ebp),%eax
   12eb9:	8b 40 1c             	mov    0x1c(%eax),%eax
   12ebc:	c1 e0 05             	shl    $0x5,%eax
   12ebf:	c0 f8 05             	sar    $0x5,%al
   12ec2:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12ec5:	83 e0 07             	and    $0x7,%eax
   12ec8:	c1 e0 04             	shl    $0x4,%eax
   12ecb:	89 c1                	mov    %eax,%ecx
   12ecd:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   12ed1:	83 e0 8f             	and    $0xffffff8f,%eax
   12ed4:	09 c8                	or     %ecx,%eax
   12ed6:	88 42 01             	mov    %al,0x1(%edx)
    for(int i=0;i<size;i++,start++){
   12ed9:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   12edd:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
   12ee1:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12ee4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   12ee7:	7c a7                	jl     12e90 <clear_display+0x2a>
    }
}
   12ee9:	90                   	nop
   12eea:	c9                   	leave  
   12eeb:	c3                   	ret    

00012eec <move_to_col0>:

static void move_to_col0(console_t* console){
   12eec:	55                   	push   %ebp
   12eed:	89 e5                	mov    %esp,%ebp
    console->cursor_col=0;
   12eef:	8b 45 08             	mov    0x8(%ebp),%eax
   12ef2:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
   12ef9:	90                   	nop
   12efa:	5d                   	pop    %ebp
   12efb:	c3                   	ret    

00012efc <move_next_line>:

static void move_next_line(console_t*console){
   12efc:	55                   	push   %ebp
   12efd:	89 e5                	mov    %esp,%ebp
   12eff:	83 ec 08             	sub    $0x8,%esp
    console->cursor_row++;
   12f02:	8b 45 08             	mov    0x8(%ebp),%eax
   12f05:	8b 40 08             	mov    0x8(%eax),%eax
   12f08:	8d 50 01             	lea    0x1(%eax),%edx
   12f0b:	8b 45 08             	mov    0x8(%ebp),%eax
   12f0e:	89 50 08             	mov    %edx,0x8(%eax)
    if(console->cursor_row >= console->display_rows){
   12f11:	8b 45 08             	mov    0x8(%ebp),%eax
   12f14:	8b 50 08             	mov    0x8(%eax),%edx
   12f17:	8b 45 08             	mov    0x8(%ebp),%eax
   12f1a:	8b 40 10             	mov    0x10(%eax),%eax
   12f1d:	39 c2                	cmp    %eax,%edx
   12f1f:	7c 10                	jl     12f31 <move_next_line+0x35>
        scroll_up(console,1);
   12f21:	83 ec 08             	sub    $0x8,%esp
   12f24:	6a 01                	push   $0x1
   12f26:	ff 75 08             	pushl  0x8(%ebp)
   12f29:	e8 af fe ff ff       	call   12ddd <scroll_up>
   12f2e:	83 c4 10             	add    $0x10,%esp
    }
}
   12f31:	90                   	nop
   12f32:	c9                   	leave  
   12f33:	c3                   	ret    

00012f34 <move_forward>:

static void move_forward(console_t* console,int n){
   12f34:	55                   	push   %ebp
   12f35:	89 e5                	mov    %esp,%ebp
   12f37:	83 ec 18             	sub    $0x18,%esp
    for(int i=0;i<n;i++){
   12f3a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12f41:	eb 5c                	jmp    12f9f <move_forward+0x6b>
        if(++console->cursor_col >= console->display_cols){
   12f43:	8b 45 08             	mov    0x8(%ebp),%eax
   12f46:	8b 40 0c             	mov    0xc(%eax),%eax
   12f49:	8d 50 01             	lea    0x1(%eax),%edx
   12f4c:	8b 45 08             	mov    0x8(%ebp),%eax
   12f4f:	89 50 0c             	mov    %edx,0xc(%eax)
   12f52:	8b 45 08             	mov    0x8(%ebp),%eax
   12f55:	8b 50 0c             	mov    0xc(%eax),%edx
   12f58:	8b 45 08             	mov    0x8(%ebp),%eax
   12f5b:	8b 40 14             	mov    0x14(%eax),%eax
   12f5e:	39 c2                	cmp    %eax,%edx
   12f60:	7c 39                	jl     12f9b <move_forward+0x67>
            console->cursor_row++;
   12f62:	8b 45 08             	mov    0x8(%ebp),%eax
   12f65:	8b 40 08             	mov    0x8(%eax),%eax
   12f68:	8d 50 01             	lea    0x1(%eax),%edx
   12f6b:	8b 45 08             	mov    0x8(%ebp),%eax
   12f6e:	89 50 08             	mov    %edx,0x8(%eax)
            console->cursor_col=0;
   12f71:	8b 45 08             	mov    0x8(%ebp),%eax
   12f74:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
            
            if(console->cursor_row >= console->display_rows){
   12f7b:	8b 45 08             	mov    0x8(%ebp),%eax
   12f7e:	8b 50 08             	mov    0x8(%eax),%edx
   12f81:	8b 45 08             	mov    0x8(%ebp),%eax
   12f84:	8b 40 10             	mov    0x10(%eax),%eax
   12f87:	39 c2                	cmp    %eax,%edx
   12f89:	7c 10                	jl     12f9b <move_forward+0x67>
                scroll_up(console,1);
   12f8b:	83 ec 08             	sub    $0x8,%esp
   12f8e:	6a 01                	push   $0x1
   12f90:	ff 75 08             	pushl  0x8(%ebp)
   12f93:	e8 45 fe ff ff       	call   12ddd <scroll_up>
   12f98:	83 c4 10             	add    $0x10,%esp
    for(int i=0;i<n;i++){
   12f9b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12f9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12fa2:	3b 45 0c             	cmp    0xc(%ebp),%eax
   12fa5:	7c 9c                	jl     12f43 <move_forward+0xf>
            }
        }
    }
}
   12fa7:	90                   	nop
   12fa8:	c9                   	leave  
   12fa9:	c3                   	ret    

00012faa <move_backword>:

static int move_backword(console_t* console,int n){
   12faa:	55                   	push   %ebp
   12fab:	89 e5                	mov    %esp,%ebp
   12fad:	83 ec 10             	sub    $0x10,%esp
    int status=-1;
   12fb0:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
    for(int i=0;i<n;i++){
   12fb7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   12fbe:	eb 55                	jmp    13015 <move_backword+0x6b>
        if(console->cursor_col > 0){
   12fc0:	8b 45 08             	mov    0x8(%ebp),%eax
   12fc3:	8b 40 0c             	mov    0xc(%eax),%eax
   12fc6:	85 c0                	test   %eax,%eax
   12fc8:	7e 18                	jle    12fe2 <move_backword+0x38>
            console->cursor_col--;
   12fca:	8b 45 08             	mov    0x8(%ebp),%eax
   12fcd:	8b 40 0c             	mov    0xc(%eax),%eax
   12fd0:	8d 50 ff             	lea    -0x1(%eax),%edx
   12fd3:	8b 45 08             	mov    0x8(%ebp),%eax
   12fd6:	89 50 0c             	mov    %edx,0xc(%eax)
            status=0;
   12fd9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12fe0:	eb 2f                	jmp    13011 <move_backword+0x67>
        }
        else if(console->cursor_row > 0){
   12fe2:	8b 45 08             	mov    0x8(%ebp),%eax
   12fe5:	8b 40 08             	mov    0x8(%eax),%eax
   12fe8:	85 c0                	test   %eax,%eax
   12fea:	7e 25                	jle    13011 <move_backword+0x67>
            console->cursor_row--;
   12fec:	8b 45 08             	mov    0x8(%ebp),%eax
   12fef:	8b 40 08             	mov    0x8(%eax),%eax
   12ff2:	8d 50 ff             	lea    -0x1(%eax),%edx
   12ff5:	8b 45 08             	mov    0x8(%ebp),%eax
   12ff8:	89 50 08             	mov    %edx,0x8(%eax)
            console->cursor_col=console->display_cols-1;
   12ffb:	8b 45 08             	mov    0x8(%ebp),%eax
   12ffe:	8b 40 14             	mov    0x14(%eax),%eax
   13001:	8d 50 ff             	lea    -0x1(%eax),%edx
   13004:	8b 45 08             	mov    0x8(%ebp),%eax
   13007:	89 50 0c             	mov    %edx,0xc(%eax)
            status=0;
   1300a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    for(int i=0;i<n;i++){
   13011:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   13015:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13018:	3b 45 0c             	cmp    0xc(%ebp),%eax
   1301b:	7c a3                	jl     12fc0 <move_backword+0x16>
        }

    }
    
    return status;
   1301d:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   13020:	c9                   	leave  
   13021:	c3                   	ret    

00013022 <console_init>:


int console_init(int idx){
   13022:	55                   	push   %ebp
   13023:	89 e5                	mov    %esp,%ebp
   13025:	83 ec 10             	sub    $0x10,%esp

    console_t* console=console_buf+idx;
   13028:	8b 45 08             	mov    0x8(%ebp),%eax
   1302b:	6b c0 54             	imul   $0x54,%eax,%eax
   1302e:	05 00 14 03 00       	add    $0x31400,%eax
   13033:	89 45 fc             	mov    %eax,-0x4(%ebp)

    console->display_cols=CONSOLE_COL_MAX;
   13036:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13039:	c7 40 14 50 00 00 00 	movl   $0x50,0x14(%eax)
    console->display_rows=CONSOLE_ROW_MAX;
   13040:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13043:	c7 40 10 19 00 00 00 	movl   $0x19,0x10(%eax)
    console->disp_base=(disp_char_t*)CONSOLE_DISP_ADDR+idx*(CONSOLE_COL_MAX*CONSOLE_ROW_MAX);
   1304a:	8b 45 08             	mov    0x8(%ebp),%eax
   1304d:	69 c0 a0 0f 00 00    	imul   $0xfa0,%eax,%eax
   13053:	8d 90 00 80 0b 00    	lea    0xb8000(%eax),%edx
   13059:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1305c:	89 50 04             	mov    %edx,0x4(%eax)

    console->foreground=WHITE;
   1305f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13062:	c7 40 18 0f 00 00 00 	movl   $0xf,0x18(%eax)
    console->background=BLACK;
   13069:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1306c:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)

    if(idx==0){
   13073:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13077:	75 30                	jne    130a9 <console_init+0x87>
        int cursor_pos=read_cursor_pos();
   13079:	e8 05 fc ff ff       	call   12c83 <read_cursor_pos>
   1307e:	89 45 f8             	mov    %eax,-0x8(%ebp)
        console->cursor_row=cursor_pos / console->display_cols;        
   13081:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13084:	8b 48 14             	mov    0x14(%eax),%ecx
   13087:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1308a:	99                   	cltd   
   1308b:	f7 f9                	idiv   %ecx
   1308d:	89 c2                	mov    %eax,%edx
   1308f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13092:	89 50 08             	mov    %edx,0x8(%eax)
        console->cursor_col=cursor_pos % console->display_cols;
   13095:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13098:	8b 48 14             	mov    0x14(%eax),%ecx
   1309b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1309e:	99                   	cltd   
   1309f:	f7 f9                	idiv   %ecx
   130a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
   130a4:	89 50 0c             	mov    %edx,0xc(%eax)
   130a7:	eb 2a                	jmp    130d3 <console_init+0xb1>
    }
    else{
        console->cursor_row=0;
   130a9:	8b 45 fc             	mov    -0x4(%ebp),%eax
   130ac:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        console->cursor_col=0;
   130b3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   130b6:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
        clear_display(console);
   130bd:	ff 75 fc             	pushl  -0x4(%ebp)
   130c0:	e8 a1 fd ff ff       	call   12e66 <clear_display>
   130c5:	83 c4 04             	add    $0x4,%esp
        update_cursor_pos(console);
   130c8:	ff 75 fc             	pushl  -0x4(%ebp)
   130cb:	e8 05 fc ff ff       	call   12cd5 <update_cursor_pos>
   130d0:	83 c4 04             	add    $0x4,%esp
    }

    console->old_cursor_col=console->cursor_col;
   130d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   130d6:	8b 50 0c             	mov    0xc(%eax),%edx
   130d9:	8b 45 fc             	mov    -0x4(%ebp),%eax
   130dc:	89 50 20             	mov    %edx,0x20(%eax)
    console->old_cursor_row=console->cursor_row;
   130df:	8b 45 fc             	mov    -0x4(%ebp),%eax
   130e2:	8b 50 08             	mov    0x8(%eax),%edx
   130e5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   130e8:	89 50 24             	mov    %edx,0x24(%eax)

    console->write_state=CONSOLE_WRITE_NORMAL; 
   130eb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   130ee:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    // clear_display(console);
    return 0;
   130f4:	b8 00 00 00 00       	mov    $0x0,%eax
}
   130f9:	c9                   	leave  
   130fa:	c3                   	ret    

000130fb <show_char>:

static void show_char(console_t* console,char c){
   130fb:	55                   	push   %ebp
   130fc:	89 e5                	mov    %esp,%ebp
   130fe:	83 ec 28             	sub    $0x28,%esp
   13101:	8b 45 0c             	mov    0xc(%ebp),%eax
   13104:	88 45 e4             	mov    %al,-0x1c(%ebp)
    int offset=console->cursor_col+console->cursor_row*console->display_cols;
   13107:	8b 45 08             	mov    0x8(%ebp),%eax
   1310a:	8b 50 0c             	mov    0xc(%eax),%edx
   1310d:	8b 45 08             	mov    0x8(%ebp),%eax
   13110:	8b 48 08             	mov    0x8(%eax),%ecx
   13113:	8b 45 08             	mov    0x8(%ebp),%eax
   13116:	8b 40 14             	mov    0x14(%eax),%eax
   13119:	0f af c1             	imul   %ecx,%eax
   1311c:	01 d0                	add    %edx,%eax
   1311e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    disp_char_t* p=console->disp_base+offset;
   13121:	8b 45 08             	mov    0x8(%ebp),%eax
   13124:	8b 40 04             	mov    0x4(%eax),%eax
   13127:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1312a:	01 d2                	add    %edx,%edx
   1312c:	01 d0                	add    %edx,%eax
   1312e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    p->c=c;
   13131:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13134:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
   13138:	88 10                	mov    %dl,(%eax)
    p->foreground=console->foreground;
   1313a:	8b 45 08             	mov    0x8(%ebp),%eax
   1313d:	8b 40 18             	mov    0x18(%eax),%eax
   13140:	c1 e0 04             	shl    $0x4,%eax
   13143:	c0 f8 04             	sar    $0x4,%al
   13146:	8b 55 f0             	mov    -0x10(%ebp),%edx
   13149:	83 e0 0f             	and    $0xf,%eax
   1314c:	89 c1                	mov    %eax,%ecx
   1314e:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   13152:	83 e0 f0             	and    $0xfffffff0,%eax
   13155:	09 c8                	or     %ecx,%eax
   13157:	88 42 01             	mov    %al,0x1(%edx)
    p->background=console->background;
   1315a:	8b 45 08             	mov    0x8(%ebp),%eax
   1315d:	8b 40 1c             	mov    0x1c(%eax),%eax
   13160:	c1 e0 05             	shl    $0x5,%eax
   13163:	c0 f8 05             	sar    $0x5,%al
   13166:	8b 55 f0             	mov    -0x10(%ebp),%edx
   13169:	83 e0 07             	and    $0x7,%eax
   1316c:	c1 e0 04             	shl    $0x4,%eax
   1316f:	89 c1                	mov    %eax,%ecx
   13171:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   13175:	83 e0 8f             	and    $0xffffff8f,%eax
   13178:	09 c8                	or     %ecx,%eax
   1317a:	88 42 01             	mov    %al,0x1(%edx)
    move_forward(console,1);
   1317d:	83 ec 08             	sub    $0x8,%esp
   13180:	6a 01                	push   $0x1
   13182:	ff 75 08             	pushl  0x8(%ebp)
   13185:	e8 aa fd ff ff       	call   12f34 <move_forward>
   1318a:	83 c4 10             	add    $0x10,%esp
}
   1318d:	90                   	nop
   1318e:	c9                   	leave  
   1318f:	c3                   	ret    

00013190 <erase_backword>:

static void erase_backword(console_t*console){
   13190:	55                   	push   %ebp
   13191:	89 e5                	mov    %esp,%ebp
   13193:	83 ec 08             	sub    $0x8,%esp
    if(move_backword(console,1)==0){
   13196:	6a 01                	push   $0x1
   13198:	ff 75 08             	pushl  0x8(%ebp)
   1319b:	e8 0a fe ff ff       	call   12faa <move_backword>
   131a0:	83 c4 08             	add    $0x8,%esp
   131a3:	85 c0                	test   %eax,%eax
   131a5:	75 20                	jne    131c7 <erase_backword+0x37>
        show_char(console,' ');
   131a7:	83 ec 08             	sub    $0x8,%esp
   131aa:	6a 20                	push   $0x20
   131ac:	ff 75 08             	pushl  0x8(%ebp)
   131af:	e8 47 ff ff ff       	call   130fb <show_char>
   131b4:	83 c4 10             	add    $0x10,%esp
        move_backword(console,1);
   131b7:	83 ec 08             	sub    $0x8,%esp
   131ba:	6a 01                	push   $0x1
   131bc:	ff 75 08             	pushl  0x8(%ebp)
   131bf:	e8 e6 fd ff ff       	call   12faa <move_backword>
   131c4:	83 c4 10             	add    $0x10,%esp
    }

}
   131c7:	90                   	nop
   131c8:	c9                   	leave  
   131c9:	c3                   	ret    

000131ca <save_cursor>:

static void save_cursor(console_t* console){
   131ca:	55                   	push   %ebp
   131cb:	89 e5                	mov    %esp,%ebp
    console->old_cursor_col=console->cursor_col;
   131cd:	8b 45 08             	mov    0x8(%ebp),%eax
   131d0:	8b 50 0c             	mov    0xc(%eax),%edx
   131d3:	8b 45 08             	mov    0x8(%ebp),%eax
   131d6:	89 50 20             	mov    %edx,0x20(%eax)
    console->old_cursor_row=console->cursor_row;
   131d9:	8b 45 08             	mov    0x8(%ebp),%eax
   131dc:	8b 50 08             	mov    0x8(%eax),%edx
   131df:	8b 45 08             	mov    0x8(%ebp),%eax
   131e2:	89 50 24             	mov    %edx,0x24(%eax)
}
   131e5:	90                   	nop
   131e6:	5d                   	pop    %ebp
   131e7:	c3                   	ret    

000131e8 <restore_cursor>:

static void restore_cursor(console_t* console){
   131e8:	55                   	push   %ebp
   131e9:	89 e5                	mov    %esp,%ebp
    console->cursor_col=console->old_cursor_col;
   131eb:	8b 45 08             	mov    0x8(%ebp),%eax
   131ee:	8b 50 20             	mov    0x20(%eax),%edx
   131f1:	8b 45 08             	mov    0x8(%ebp),%eax
   131f4:	89 50 0c             	mov    %edx,0xc(%eax)
    console->cursor_row=console->old_cursor_row;
   131f7:	8b 45 08             	mov    0x8(%ebp),%eax
   131fa:	8b 50 24             	mov    0x24(%eax),%edx
   131fd:	8b 45 08             	mov    0x8(%ebp),%eax
   13200:	89 50 08             	mov    %edx,0x8(%eax)
}
   13203:	90                   	nop
   13204:	5d                   	pop    %ebp
   13205:	c3                   	ret    

00013206 <clear_esc_param>:

static void clear_esc_param(console_t* console){
   13206:	55                   	push   %ebp
   13207:	89 e5                	mov    %esp,%ebp
   13209:	83 ec 08             	sub    $0x8,%esp
    kernel_memset(console->esc_param,0,sizeof(console->esc_param));
   1320c:	8b 45 08             	mov    0x8(%ebp),%eax
   1320f:	83 c0 28             	add    $0x28,%eax
   13212:	83 ec 04             	sub    $0x4,%esp
   13215:	6a 28                	push   $0x28
   13217:	6a 00                	push   $0x0
   13219:	50                   	push   %eax
   1321a:	e8 40 1a 00 00       	call   14c5f <kernel_memset>
   1321f:	83 c4 10             	add    $0x10,%esp
    console->curr_param_index=0;
   13222:	8b 45 08             	mov    0x8(%ebp),%eax
   13225:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
}
   1322c:	90                   	nop
   1322d:	c9                   	leave  
   1322e:	c3                   	ret    

0001322f <write_esc>:

static void write_esc(console_t* console,char c){
   1322f:	55                   	push   %ebp
   13230:	89 e5                	mov    %esp,%ebp
   13232:	83 ec 18             	sub    $0x18,%esp
   13235:	8b 45 0c             	mov    0xc(%ebp),%eax
   13238:	88 45 f4             	mov    %al,-0xc(%ebp)
    switch (c)
   1323b:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
   1323f:	83 f8 38             	cmp    $0x38,%eax
   13242:	74 20                	je     13264 <write_esc+0x35>
   13244:	83 f8 5b             	cmp    $0x5b,%eax
   13247:	74 31                	je     1327a <write_esc+0x4b>
   13249:	83 f8 37             	cmp    $0x37,%eax
   1324c:	75 45                	jne    13293 <write_esc+0x64>
    {
    case '7':
        save_cursor(console);
   1324e:	ff 75 08             	pushl  0x8(%ebp)
   13251:	e8 74 ff ff ff       	call   131ca <save_cursor>
   13256:	83 c4 04             	add    $0x4,%esp
        console->write_state=CONSOLE_WRITE_NORMAL;
   13259:	8b 45 08             	mov    0x8(%ebp),%eax
   1325c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        break;
   13262:	eb 39                	jmp    1329d <write_esc+0x6e>
    case '8':
        restore_cursor(console);
   13264:	ff 75 08             	pushl  0x8(%ebp)
   13267:	e8 7c ff ff ff       	call   131e8 <restore_cursor>
   1326c:	83 c4 04             	add    $0x4,%esp
        console->write_state=CONSOLE_WRITE_NORMAL;
   1326f:	8b 45 08             	mov    0x8(%ebp),%eax
   13272:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        break;
   13278:	eb 23                	jmp    1329d <write_esc+0x6e>
    case '[':
        clear_esc_param(console);
   1327a:	83 ec 0c             	sub    $0xc,%esp
   1327d:	ff 75 08             	pushl  0x8(%ebp)
   13280:	e8 81 ff ff ff       	call   13206 <clear_esc_param>
   13285:	83 c4 10             	add    $0x10,%esp
        console->write_state=CONSOLE_WRITE_SQUARE;
   13288:	8b 45 08             	mov    0x8(%ebp),%eax
   1328b:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        break;
   13291:	eb 0a                	jmp    1329d <write_esc+0x6e>
    default:
        console->write_state=CONSOLE_WRITE_NORMAL;
   13293:	8b 45 08             	mov    0x8(%ebp),%eax
   13296:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        break;
   1329c:	90                   	nop
    }
}
   1329d:	90                   	nop
   1329e:	c9                   	leave  
   1329f:	c3                   	ret    

000132a0 <set_font_style>:

static void set_font_style(console_t* console){
   132a0:	55                   	push   %ebp
   132a1:	89 e5                	mov    %esp,%ebp
   132a3:	83 ec 10             	sub    $0x10,%esp
    static const color_t color_table[]={
        BLACK,RED,GREEN,YELLOW,BLUE,
        MAGENTA,CYAN,WHITE
    };

    for(int i=0;i<=console->curr_param_index;i++){
   132a6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   132ad:	eb 78                	jmp    13327 <set_font_style+0x87>
        int param=console->esc_param[i];
   132af:	8b 45 08             	mov    0x8(%ebp),%eax
   132b2:	8b 55 fc             	mov    -0x4(%ebp),%edx
   132b5:	83 c2 08             	add    $0x8,%edx
   132b8:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
   132bc:	89 45 f8             	mov    %eax,-0x8(%ebp)
        if((param>=30) && (param <= 37)){
   132bf:	83 7d f8 1d          	cmpl   $0x1d,-0x8(%ebp)
   132c3:	7e 1b                	jle    132e0 <set_font_style+0x40>
   132c5:	83 7d f8 25          	cmpl   $0x25,-0x8(%ebp)
   132c9:	7f 15                	jg     132e0 <set_font_style+0x40>
            console->foreground=color_table[param-30];
   132cb:	8b 45 f8             	mov    -0x8(%ebp),%eax
   132ce:	83 e8 1e             	sub    $0x1e,%eax
   132d1:	8b 14 85 80 5d 01 00 	mov    0x15d80(,%eax,4),%edx
   132d8:	8b 45 08             	mov    0x8(%ebp),%eax
   132db:	89 50 18             	mov    %edx,0x18(%eax)
   132de:	eb 43                	jmp    13323 <set_font_style+0x83>
        }
        else if((param >= 40)&&(param <= 47)){
   132e0:	83 7d f8 27          	cmpl   $0x27,-0x8(%ebp)
   132e4:	7e 1b                	jle    13301 <set_font_style+0x61>
   132e6:	83 7d f8 2f          	cmpl   $0x2f,-0x8(%ebp)
   132ea:	7f 15                	jg     13301 <set_font_style+0x61>
            console->background=color_table[param-40];
   132ec:	8b 45 f8             	mov    -0x8(%ebp),%eax
   132ef:	83 e8 28             	sub    $0x28,%eax
   132f2:	8b 14 85 80 5d 01 00 	mov    0x15d80(,%eax,4),%edx
   132f9:	8b 45 08             	mov    0x8(%ebp),%eax
   132fc:	89 50 1c             	mov    %edx,0x1c(%eax)
   132ff:	eb 22                	jmp    13323 <set_font_style+0x83>
        }
        else if(param == 39){
   13301:	83 7d f8 27          	cmpl   $0x27,-0x8(%ebp)
   13305:	75 0c                	jne    13313 <set_font_style+0x73>
            console->foreground=WHITE;
   13307:	8b 45 08             	mov    0x8(%ebp),%eax
   1330a:	c7 40 18 0f 00 00 00 	movl   $0xf,0x18(%eax)
   13311:	eb 10                	jmp    13323 <set_font_style+0x83>
        }
        else if(param == 49){
   13313:	83 7d f8 31          	cmpl   $0x31,-0x8(%ebp)
   13317:	75 0a                	jne    13323 <set_font_style+0x83>
            console->background=BLACK;
   13319:	8b 45 08             	mov    0x8(%ebp),%eax
   1331c:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    for(int i=0;i<=console->curr_param_index;i++){
   13323:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   13327:	8b 45 08             	mov    0x8(%ebp),%eax
   1332a:	8b 40 50             	mov    0x50(%eax),%eax
   1332d:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   13330:	0f 8e 79 ff ff ff    	jle    132af <set_font_style+0xf>
        }
    }

}
   13336:	90                   	nop
   13337:	c9                   	leave  
   13338:	c3                   	ret    

00013339 <erase_in_display>:

static void erase_in_display(console_t* console){
   13339:	55                   	push   %ebp
   1333a:	89 e5                	mov    %esp,%ebp
   1333c:	83 ec 10             	sub    $0x10,%esp
    if(console->curr_param_index < 0){
   1333f:	8b 45 08             	mov    0x8(%ebp),%eax
   13342:	8b 40 50             	mov    0x50(%eax),%eax
   13345:	85 c0                	test   %eax,%eax
   13347:	78 3e                	js     13387 <erase_in_display+0x4e>
        return;
    }

    int param=console->esc_param[0];
   13349:	8b 45 08             	mov    0x8(%ebp),%eax
   1334c:	8b 40 28             	mov    0x28(%eax),%eax
   1334f:	89 45 fc             	mov    %eax,-0x4(%ebp)

    if(param==2){
   13352:	83 7d fc 02          	cmpl   $0x2,-0x4(%ebp)
   13356:	75 30                	jne    13388 <erase_in_display+0x4f>
        erase_rows(console,0,console->display_cols-1);
   13358:	8b 45 08             	mov    0x8(%ebp),%eax
   1335b:	8b 40 14             	mov    0x14(%eax),%eax
   1335e:	83 e8 01             	sub    $0x1,%eax
   13361:	50                   	push   %eax
   13362:	6a 00                	push   $0x0
   13364:	ff 75 08             	pushl  0x8(%ebp)
   13367:	e8 de f9 ff ff       	call   12d4a <erase_rows>
   1336c:	83 c4 0c             	add    $0xc,%esp
        console->cursor_col=console->cursor_row=0;
   1336f:	8b 45 08             	mov    0x8(%ebp),%eax
   13372:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   13379:	8b 45 08             	mov    0x8(%ebp),%eax
   1337c:	8b 50 08             	mov    0x8(%eax),%edx
   1337f:	8b 45 08             	mov    0x8(%ebp),%eax
   13382:	89 50 0c             	mov    %edx,0xc(%eax)
   13385:	eb 01                	jmp    13388 <erase_in_display+0x4f>
        return;
   13387:	90                   	nop
    }

}
   13388:	c9                   	leave  
   13389:	c3                   	ret    

0001338a <move_cursor>:

static void move_cursor(console_t* console){
   1338a:	55                   	push   %ebp
   1338b:	89 e5                	mov    %esp,%ebp
    console->cursor_row=console->esc_param[0];
   1338d:	8b 45 08             	mov    0x8(%ebp),%eax
   13390:	8b 50 28             	mov    0x28(%eax),%edx
   13393:	8b 45 08             	mov    0x8(%ebp),%eax
   13396:	89 50 08             	mov    %edx,0x8(%eax)
    console->cursor_col=console->esc_param[1];
   13399:	8b 45 08             	mov    0x8(%ebp),%eax
   1339c:	8b 50 2c             	mov    0x2c(%eax),%edx
   1339f:	8b 45 08             	mov    0x8(%ebp),%eax
   133a2:	89 50 0c             	mov    %edx,0xc(%eax)
}
   133a5:	90                   	nop
   133a6:	5d                   	pop    %ebp
   133a7:	c3                   	ret    

000133a8 <move_left>:

static void move_left(console_t* console,int n){
   133a8:	55                   	push   %ebp
   133a9:	89 e5                	mov    %esp,%ebp
   133ab:	83 ec 10             	sub    $0x10,%esp
    if(n==0){
   133ae:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   133b2:	75 07                	jne    133bb <move_left+0x13>
        n=1;
   133b4:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)
    }

    int col=console->cursor_col-n;
   133bb:	8b 45 08             	mov    0x8(%ebp),%eax
   133be:	8b 40 0c             	mov    0xc(%eax),%eax
   133c1:	2b 45 0c             	sub    0xc(%ebp),%eax
   133c4:	89 45 fc             	mov    %eax,-0x4(%ebp)

    console->cursor_col=(col>=0)?col:0;
   133c7:	b8 00 00 00 00       	mov    $0x0,%eax
   133cc:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   133d0:	0f 49 45 fc          	cmovns -0x4(%ebp),%eax
   133d4:	89 c2                	mov    %eax,%edx
   133d6:	8b 45 08             	mov    0x8(%ebp),%eax
   133d9:	89 50 0c             	mov    %edx,0xc(%eax)
}
   133dc:	90                   	nop
   133dd:	c9                   	leave  
   133de:	c3                   	ret    

000133df <move_right>:

static void move_right(console_t* console,int n){
   133df:	55                   	push   %ebp
   133e0:	89 e5                	mov    %esp,%ebp
   133e2:	83 ec 10             	sub    $0x10,%esp
    if(n==0){
   133e5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   133e9:	75 07                	jne    133f2 <move_right+0x13>
        n=1;
   133eb:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)
    }

    int col=console->cursor_col+n;
   133f2:	8b 45 08             	mov    0x8(%ebp),%eax
   133f5:	8b 50 0c             	mov    0xc(%eax),%edx
   133f8:	8b 45 0c             	mov    0xc(%ebp),%eax
   133fb:	01 d0                	add    %edx,%eax
   133fd:	89 45 fc             	mov    %eax,-0x4(%ebp)

    if(col >= console->display_cols){
   13400:	8b 45 08             	mov    0x8(%ebp),%eax
   13403:	8b 40 14             	mov    0x14(%eax),%eax
   13406:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   13409:	7c 11                	jl     1341c <move_right+0x3d>
        console->cursor_col=console->display_cols-1;
   1340b:	8b 45 08             	mov    0x8(%ebp),%eax
   1340e:	8b 40 14             	mov    0x14(%eax),%eax
   13411:	8d 50 ff             	lea    -0x1(%eax),%edx
   13414:	8b 45 08             	mov    0x8(%ebp),%eax
   13417:	89 50 0c             	mov    %edx,0xc(%eax)
    }
    else{
        console->cursor_col=col;
    }
}
   1341a:	eb 09                	jmp    13425 <move_right+0x46>
        console->cursor_col=col;
   1341c:	8b 45 08             	mov    0x8(%ebp),%eax
   1341f:	8b 55 fc             	mov    -0x4(%ebp),%edx
   13422:	89 50 0c             	mov    %edx,0xc(%eax)
}
   13425:	90                   	nop
   13426:	c9                   	leave  
   13427:	c3                   	ret    

00013428 <write_esc_square>:

static void write_esc_square(console_t* console,char c){
   13428:	55                   	push   %ebp
   13429:	89 e5                	mov    %esp,%ebp
   1342b:	83 ec 14             	sub    $0x14,%esp
   1342e:	8b 45 0c             	mov    0xc(%ebp),%eax
   13431:	88 45 ec             	mov    %al,-0x14(%ebp)
    if((c>='0') && (c<='9')){
   13434:	80 7d ec 2f          	cmpb   $0x2f,-0x14(%ebp)
   13438:	7e 44                	jle    1347e <write_esc_square+0x56>
   1343a:	80 7d ec 39          	cmpb   $0x39,-0x14(%ebp)
   1343e:	7f 3e                	jg     1347e <write_esc_square+0x56>
        int *param=&console->esc_param[console->curr_param_index];
   13440:	8b 45 08             	mov    0x8(%ebp),%eax
   13443:	8b 40 50             	mov    0x50(%eax),%eax
   13446:	83 c0 08             	add    $0x8,%eax
   13449:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   13450:	8b 45 08             	mov    0x8(%ebp),%eax
   13453:	01 d0                	add    %edx,%eax
   13455:	83 c0 08             	add    $0x8,%eax
   13458:	89 45 fc             	mov    %eax,-0x4(%ebp)
        *param=*param*10+c-'0';
   1345b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1345e:	8b 10                	mov    (%eax),%edx
   13460:	89 d0                	mov    %edx,%eax
   13462:	c1 e0 02             	shl    $0x2,%eax
   13465:	01 d0                	add    %edx,%eax
   13467:	01 c0                	add    %eax,%eax
   13469:	89 c2                	mov    %eax,%edx
   1346b:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
   1346f:	01 d0                	add    %edx,%eax
   13471:	8d 50 d0             	lea    -0x30(%eax),%edx
   13474:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13477:	89 10                	mov    %edx,(%eax)
    if((c>='0') && (c<='9')){
   13479:	e9 9b 00 00 00       	jmp    13519 <write_esc_square+0xf1>
    }
    else if((c==';') && (console->curr_param_index < ESC_PARAM_MAX)){
   1347e:	80 7d ec 3b          	cmpb   $0x3b,-0x14(%ebp)
   13482:	75 1c                	jne    134a0 <write_esc_square+0x78>
   13484:	8b 45 08             	mov    0x8(%ebp),%eax
   13487:	8b 40 50             	mov    0x50(%eax),%eax
   1348a:	83 f8 09             	cmp    $0x9,%eax
   1348d:	7f 11                	jg     134a0 <write_esc_square+0x78>
        console->curr_param_index++;
   1348f:	8b 45 08             	mov    0x8(%ebp),%eax
   13492:	8b 40 50             	mov    0x50(%eax),%eax
   13495:	8d 50 01             	lea    0x1(%eax),%edx
   13498:	8b 45 08             	mov    0x8(%ebp),%eax
   1349b:	89 50 50             	mov    %edx,0x50(%eax)
   1349e:	eb 79                	jmp    13519 <write_esc_square+0xf1>
    }
    else{
        switch(c){
   134a0:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
   134a4:	83 e8 43             	sub    $0x43,%eax
   134a7:	83 f8 2a             	cmp    $0x2a,%eax
   134aa:	77 63                	ja     1350f <write_esc_square+0xe7>
   134ac:	8b 04 85 c0 5c 01 00 	mov    0x15cc0(,%eax,4),%eax
   134b3:	ff e0                	jmp    *%eax
            case 'm':
                set_font_style(console);
   134b5:	ff 75 08             	pushl  0x8(%ebp)
   134b8:	e8 e3 fd ff ff       	call   132a0 <set_font_style>
   134bd:	83 c4 04             	add    $0x4,%esp
                break;
   134c0:	eb 4e                	jmp    13510 <write_esc_square+0xe8>
            case 'D':
                move_left(console,console->esc_param[0]);
   134c2:	8b 45 08             	mov    0x8(%ebp),%eax
   134c5:	8b 40 28             	mov    0x28(%eax),%eax
   134c8:	50                   	push   %eax
   134c9:	ff 75 08             	pushl  0x8(%ebp)
   134cc:	e8 d7 fe ff ff       	call   133a8 <move_left>
   134d1:	83 c4 08             	add    $0x8,%esp
                break;
   134d4:	eb 3a                	jmp    13510 <write_esc_square+0xe8>
            case 'C':
                move_right(console,console->esc_param[0]);
   134d6:	8b 45 08             	mov    0x8(%ebp),%eax
   134d9:	8b 40 28             	mov    0x28(%eax),%eax
   134dc:	50                   	push   %eax
   134dd:	ff 75 08             	pushl  0x8(%ebp)
   134e0:	e8 fa fe ff ff       	call   133df <move_right>
   134e5:	83 c4 08             	add    $0x8,%esp
                break;
   134e8:	eb 26                	jmp    13510 <write_esc_square+0xe8>
            case 'H':
                move_cursor(console);
   134ea:	ff 75 08             	pushl  0x8(%ebp)
   134ed:	e8 98 fe ff ff       	call   1338a <move_cursor>
   134f2:	83 c4 04             	add    $0x4,%esp
                break;
   134f5:	eb 19                	jmp    13510 <write_esc_square+0xe8>
            case 'f':
                 move_cursor(console);
   134f7:	ff 75 08             	pushl  0x8(%ebp)
   134fa:	e8 8b fe ff ff       	call   1338a <move_cursor>
   134ff:	83 c4 04             	add    $0x4,%esp
                break;
   13502:	eb 0c                	jmp    13510 <write_esc_square+0xe8>
            case 'J':
                erase_in_display(console);
   13504:	ff 75 08             	pushl  0x8(%ebp)
   13507:	e8 2d fe ff ff       	call   13339 <erase_in_display>
   1350c:	83 c4 04             	add    $0x4,%esp
            default:
                break;
   1350f:	90                   	nop
        }
        console->write_state=CONSOLE_WRITE_NORMAL;
   13510:	8b 45 08             	mov    0x8(%ebp),%eax
   13513:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
}
   13519:	90                   	nop
   1351a:	c9                   	leave  
   1351b:	c3                   	ret    

0001351c <write_normal>:

static void write_normal(console_t* console,char c){
   1351c:	55                   	push   %ebp
   1351d:	89 e5                	mov    %esp,%ebp
   1351f:	83 ec 18             	sub    $0x18,%esp
   13522:	8b 45 0c             	mov    0xc(%ebp),%eax
   13525:	88 45 f4             	mov    %al,-0xc(%ebp)
    switch (c)
   13528:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
   1352c:	83 f8 0d             	cmp    $0xd,%eax
   1352f:	74 4a                	je     1357b <write_normal+0x5f>
   13531:	83 f8 0d             	cmp    $0xd,%eax
   13534:	7f 0c                	jg     13542 <write_normal+0x26>
   13536:	83 f8 08             	cmp    $0x8,%eax
   13539:	74 2e                	je     13569 <write_normal+0x4d>
   1353b:	83 f8 0a             	cmp    $0xa,%eax
   1353e:	74 4b                	je     1358b <write_normal+0x6f>
   13540:	eb 59                	jmp    1359b <write_normal+0x7f>
   13542:	83 f8 1b             	cmp    $0x1b,%eax
   13545:	74 07                	je     1354e <write_normal+0x32>
   13547:	83 f8 7f             	cmp    $0x7f,%eax
   1354a:	74 0d                	je     13559 <write_normal+0x3d>
   1354c:	eb 4d                	jmp    1359b <write_normal+0x7f>
    {
        case ASCII_ESC:
            console->write_state=CONSOLE_WRITE_ESC;
   1354e:	8b 45 08             	mov    0x8(%ebp),%eax
   13551:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
            break;
   13557:	eb 62                	jmp    135bb <write_normal+0x9f>
        case 0x7F:
            erase_backword(console);
   13559:	83 ec 0c             	sub    $0xc,%esp
   1355c:	ff 75 08             	pushl  0x8(%ebp)
   1355f:	e8 2c fc ff ff       	call   13190 <erase_backword>
   13564:	83 c4 10             	add    $0x10,%esp
            break;
   13567:	eb 52                	jmp    135bb <write_normal+0x9f>
        case '\b':
            move_backword(console,1);
   13569:	83 ec 08             	sub    $0x8,%esp
   1356c:	6a 01                	push   $0x1
   1356e:	ff 75 08             	pushl  0x8(%ebp)
   13571:	e8 34 fa ff ff       	call   12faa <move_backword>
   13576:	83 c4 10             	add    $0x10,%esp
            break;
   13579:	eb 40                	jmp    135bb <write_normal+0x9f>
        case '\r':
            move_to_col0(console);
   1357b:	83 ec 0c             	sub    $0xc,%esp
   1357e:	ff 75 08             	pushl  0x8(%ebp)
   13581:	e8 66 f9 ff ff       	call   12eec <move_to_col0>
   13586:	83 c4 10             	add    $0x10,%esp
            break;
   13589:	eb 30                	jmp    135bb <write_normal+0x9f>
        case '\n':  
            move_next_line(console);
   1358b:	83 ec 0c             	sub    $0xc,%esp
   1358e:	ff 75 08             	pushl  0x8(%ebp)
   13591:	e8 66 f9 ff ff       	call   12efc <move_next_line>
   13596:	83 c4 10             	add    $0x10,%esp
            break;
   13599:	eb 20                	jmp    135bb <write_normal+0x9f>
        default:
            if((c >= ' ') && (c <= '~')){
   1359b:	80 7d f4 1f          	cmpb   $0x1f,-0xc(%ebp)
   1359f:	7e 19                	jle    135ba <write_normal+0x9e>
   135a1:	80 7d f4 7f          	cmpb   $0x7f,-0xc(%ebp)
   135a5:	74 13                	je     135ba <write_normal+0x9e>
                show_char(console,c);
   135a7:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
   135ab:	83 ec 08             	sub    $0x8,%esp
   135ae:	50                   	push   %eax
   135af:	ff 75 08             	pushl  0x8(%ebp)
   135b2:	e8 44 fb ff ff       	call   130fb <show_char>
   135b7:	83 c4 10             	add    $0x10,%esp
            }
            break;
   135ba:	90                   	nop
    }
}
   135bb:	90                   	nop
   135bc:	c9                   	leave  
   135bd:	c3                   	ret    

000135be <console_write>:

int console_write(tty_t* tty){
   135be:	55                   	push   %ebp
   135bf:	89 e5                	mov    %esp,%ebp
   135c1:	83 ec 18             	sub    $0x18,%esp
    console_t* console=console_buf+tty->console_index;
   135c4:	8b 45 08             	mov    0x8(%ebp),%eax
   135c7:	8b 80 28 04 00 00    	mov    0x428(%eax),%eax
   135cd:	6b c0 54             	imul   $0x54,%eax,%eax
   135d0:	05 00 14 03 00       	add    $0x31400,%eax
   135d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int len=0;
   135d8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    do{
        char c;
        int err=tty_fifo_get(&tty->ofifo,&c);
   135df:	8b 45 08             	mov    0x8(%ebp),%eax
   135e2:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
   135e8:	83 ec 08             	sub    $0x8,%esp
   135eb:	8d 45 eb             	lea    -0x15(%ebp),%eax
   135ee:	50                   	push   %eax
   135ef:	52                   	push   %edx
   135f0:	e8 d4 08 00 00       	call   13ec9 <tty_fifo_get>
   135f5:	83 c4 10             	add    $0x10,%esp
   135f8:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(err<0){
   135fb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   135ff:	79 13                	jns    13614 <console_write+0x56>
        }
        
        len++;
    }while(1);

    update_cursor_pos(console);
   13601:	83 ec 0c             	sub    $0xc,%esp
   13604:	ff 75 f0             	pushl  -0x10(%ebp)
   13607:	e8 c9 f6 ff ff       	call   12cd5 <update_cursor_pos>
   1360c:	83 c4 10             	add    $0x10,%esp

    return len;
   1360f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13612:	eb 7a                	jmp    1368e <console_write+0xd0>
        sem_notify(&tty->osem);
   13614:	8b 45 08             	mov    0x8(%ebp),%eax
   13617:	05 2c 04 00 00       	add    $0x42c,%eax
   1361c:	83 ec 0c             	sub    $0xc,%esp
   1361f:	50                   	push   %eax
   13620:	e8 5a 11 00 00       	call   1477f <sem_notify>
   13625:	83 c4 10             	add    $0x10,%esp
        switch(console->write_state){
   13628:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1362b:	8b 00                	mov    (%eax),%eax
   1362d:	83 f8 01             	cmp    $0x1,%eax
   13630:	74 24                	je     13656 <console_write+0x98>
   13632:	83 f8 01             	cmp    $0x1,%eax
   13635:	72 07                	jb     1363e <console_write+0x80>
   13637:	83 f8 02             	cmp    $0x2,%eax
   1363a:	74 32                	je     1366e <console_write+0xb0>
                break;
   1363c:	eb 47                	jmp    13685 <console_write+0xc7>
                write_normal(console,c);
   1363e:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   13642:	0f be c0             	movsbl %al,%eax
   13645:	83 ec 08             	sub    $0x8,%esp
   13648:	50                   	push   %eax
   13649:	ff 75 f0             	pushl  -0x10(%ebp)
   1364c:	e8 cb fe ff ff       	call   1351c <write_normal>
   13651:	83 c4 10             	add    $0x10,%esp
                break;
   13654:	eb 2f                	jmp    13685 <console_write+0xc7>
                write_esc(console,c);
   13656:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   1365a:	0f be c0             	movsbl %al,%eax
   1365d:	83 ec 08             	sub    $0x8,%esp
   13660:	50                   	push   %eax
   13661:	ff 75 f0             	pushl  -0x10(%ebp)
   13664:	e8 c6 fb ff ff       	call   1322f <write_esc>
   13669:	83 c4 10             	add    $0x10,%esp
                break;
   1366c:	eb 17                	jmp    13685 <console_write+0xc7>
                write_esc_square(console,c);
   1366e:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   13672:	0f be c0             	movsbl %al,%eax
   13675:	83 ec 08             	sub    $0x8,%esp
   13678:	50                   	push   %eax
   13679:	ff 75 f0             	pushl  -0x10(%ebp)
   1367c:	e8 a7 fd ff ff       	call   13428 <write_esc_square>
   13681:	83 c4 10             	add    $0x10,%esp
                break;
   13684:	90                   	nop
        len++;
   13685:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    do{
   13689:	e9 51 ff ff ff       	jmp    135df <console_write+0x21>
}
   1368e:	c9                   	leave  
   1368f:	c3                   	ret    

00013690 <console_close>:

void console_close(int console){
   13690:	55                   	push   %ebp
   13691:	89 e5                	mov    %esp,%ebp
    
}
   13693:	90                   	nop
   13694:	5d                   	pop    %ebp
   13695:	c3                   	ret    

00013696 <is_devid_bad>:
    &dev_tty_desc,
};

static device_t dev_tb[DEV_TABLE_SIZE];

static int is_devid_bad(int dev_id){
   13696:	55                   	push   %ebp
   13697:	89 e5                	mov    %esp,%ebp
    if((dev_id<0) || (dev_id>=DEV_TABLE_SIZE)){
   13699:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1369d:	78 06                	js     136a5 <is_devid_bad+0xf>
   1369f:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   136a3:	7e 07                	jle    136ac <is_devid_bad+0x16>
        return 1;
   136a5:	b8 01 00 00 00       	mov    $0x1,%eax
   136aa:	eb 24                	jmp    136d0 <is_devid_bad+0x3a>
    }

    if(dev_tb[dev_id].desc==(dev_desc_t*)0){
   136ac:	8b 55 08             	mov    0x8(%ebp),%edx
   136af:	89 d0                	mov    %edx,%eax
   136b1:	c1 e0 02             	shl    $0x2,%eax
   136b4:	01 d0                	add    %edx,%eax
   136b6:	c1 e0 02             	shl    $0x2,%eax
   136b9:	05 a0 16 03 00       	add    $0x316a0,%eax
   136be:	8b 00                	mov    (%eax),%eax
   136c0:	85 c0                	test   %eax,%eax
   136c2:	75 07                	jne    136cb <is_devid_bad+0x35>
        return 1;
   136c4:	b8 01 00 00 00       	mov    $0x1,%eax
   136c9:	eb 05                	jmp    136d0 <is_devid_bad+0x3a>
    }

    return 0;
   136cb:	b8 00 00 00 00       	mov    $0x0,%eax
}
   136d0:	5d                   	pop    %ebp
   136d1:	c3                   	ret    

000136d2 <dev_open>:

// major打开的主设备号，minor从设备号，data向设备传入的参数
int dev_open(int major,int minor,void* data){
   136d2:	55                   	push   %ebp
   136d3:	89 e5                	mov    %esp,%ebp
   136d5:	83 ec 28             	sub    $0x28,%esp
    irq_state_t state=irq_enter_protection();
   136d8:	e8 41 f5 ff ff       	call   12c1e <irq_enter_protection>
   136dd:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    device_t* free_dev=(device_t*)0;
   136e0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    for(int i=0;i<sizeof(dev_tb)/sizeof(dev_tb[0]);i++){
   136e7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   136ee:	eb 68                	jmp    13758 <dev_open+0x86>
        device_t* dev=dev_tb+i;
   136f0:	8b 55 f0             	mov    -0x10(%ebp),%edx
   136f3:	89 d0                	mov    %edx,%eax
   136f5:	c1 e0 02             	shl    $0x2,%eax
   136f8:	01 d0                	add    %edx,%eax
   136fa:	c1 e0 02             	shl    $0x2,%eax
   136fd:	05 a0 16 03 00       	add    $0x316a0,%eax
   13702:	89 45 dc             	mov    %eax,-0x24(%ebp)
        if(dev->open_count == 0){
   13705:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13708:	8b 40 10             	mov    0x10(%eax),%eax
   1370b:	85 c0                	test   %eax,%eax
   1370d:	75 08                	jne    13717 <dev_open+0x45>
            free_dev=dev;
   1370f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13712:	89 45 f4             	mov    %eax,-0xc(%ebp)
   13715:	eb 3d                	jmp    13754 <dev_open+0x82>
        }
        else if((dev->desc->major == major) && (dev->minor == minor)){
   13717:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1371a:	8b 00                	mov    (%eax),%eax
   1371c:	8b 40 20             	mov    0x20(%eax),%eax
   1371f:	39 45 08             	cmp    %eax,0x8(%ebp)
   13722:	75 30                	jne    13754 <dev_open+0x82>
   13724:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13727:	8b 40 08             	mov    0x8(%eax),%eax
   1372a:	39 45 0c             	cmp    %eax,0xc(%ebp)
   1372d:	75 25                	jne    13754 <dev_open+0x82>
            dev->open_count++;
   1372f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13732:	8b 40 10             	mov    0x10(%eax),%eax
   13735:	8d 50 01             	lea    0x1(%eax),%edx
   13738:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1373b:	89 50 10             	mov    %edx,0x10(%eax)
            irq_leave_protection(state);
   1373e:	83 ec 0c             	sub    $0xc,%esp
   13741:	ff 75 e4             	pushl  -0x1c(%ebp)
   13744:	e8 ed f4 ff ff       	call   12c36 <irq_leave_protection>
   13749:	83 c4 10             	add    $0x10,%esp
            return i;
   1374c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1374f:	e9 cc 00 00 00       	jmp    13820 <dev_open+0x14e>
    for(int i=0;i<sizeof(dev_tb)/sizeof(dev_tb[0]);i++){
   13754:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   13758:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1375b:	83 f8 7f             	cmp    $0x7f,%eax
   1375e:	76 90                	jbe    136f0 <dev_open+0x1e>
        }
    }

    dev_desc_t* desc=(dev_desc_t*)0;
   13760:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(int i=0;i<sizeof(dev_desc_tbl)/sizeof(dev_desc_tbl[0]);i++){
   13767:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   1376e:	eb 25                	jmp    13795 <dev_open+0xc3>
        if(dev_desc_tbl[i]->major == major){
   13770:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13773:	8b 04 85 50 60 01 00 	mov    0x16050(,%eax,4),%eax
   1377a:	8b 40 20             	mov    0x20(%eax),%eax
   1377d:	39 45 08             	cmp    %eax,0x8(%ebp)
   13780:	75 0f                	jne    13791 <dev_open+0xbf>
            desc=dev_desc_tbl[i];
   13782:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13785:	8b 04 85 50 60 01 00 	mov    0x16050(,%eax,4),%eax
   1378c:	89 45 ec             	mov    %eax,-0x14(%ebp)
            break;
   1378f:	eb 0a                	jmp    1379b <dev_open+0xc9>
    for(int i=0;i<sizeof(dev_desc_tbl)/sizeof(dev_desc_tbl[0]);i++){
   13791:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   13795:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   13799:	74 d5                	je     13770 <dev_open+0x9e>
        }
    }

    if(desc && free_dev){
   1379b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1379f:	74 6c                	je     1380d <dev_open+0x13b>
   137a1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   137a5:	74 66                	je     1380d <dev_open+0x13b>
       free_dev->minor=minor;
   137a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   137aa:	8b 55 0c             	mov    0xc(%ebp),%edx
   137ad:	89 50 08             	mov    %edx,0x8(%eax)
       free_dev->desc=desc;
   137b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   137b3:	8b 55 ec             	mov    -0x14(%ebp),%edx
   137b6:	89 10                	mov    %edx,(%eax)
       free_dev->data=data;
   137b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   137bb:	8b 55 10             	mov    0x10(%ebp),%edx
   137be:	89 50 0c             	mov    %edx,0xc(%eax)

       int err=desc->open(free_dev);
   137c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   137c4:	8b 40 24             	mov    0x24(%eax),%eax
   137c7:	83 ec 0c             	sub    $0xc,%esp
   137ca:	ff 75 f4             	pushl  -0xc(%ebp)
   137cd:	ff d0                	call   *%eax
   137cf:	83 c4 10             	add    $0x10,%esp
   137d2:	89 45 e0             	mov    %eax,-0x20(%ebp)
       if(err==0){
   137d5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   137d9:	75 32                	jne    1380d <dev_open+0x13b>
           free_dev->open_count++;
   137db:	8b 45 f4             	mov    -0xc(%ebp),%eax
   137de:	8b 40 10             	mov    0x10(%eax),%eax
   137e1:	8d 50 01             	lea    0x1(%eax),%edx
   137e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   137e7:	89 50 10             	mov    %edx,0x10(%eax)
           irq_leave_protection(state);
   137ea:	83 ec 0c             	sub    $0xc,%esp
   137ed:	ff 75 e4             	pushl  -0x1c(%ebp)
   137f0:	e8 41 f4 ff ff       	call   12c36 <irq_leave_protection>
   137f5:	83 c4 10             	add    $0x10,%esp

           // dev_tb是起始位置，free_dev是当前位置，两者相减得到当前位置的偏移量
           return free_dev-dev_tb;
   137f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   137fb:	ba a0 16 03 00       	mov    $0x316a0,%edx
   13800:	29 d0                	sub    %edx,%eax
   13802:	c1 f8 02             	sar    $0x2,%eax
   13805:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
   1380b:	eb 13                	jmp    13820 <dev_open+0x14e>
       }
    }

    irq_leave_protection(state);
   1380d:	83 ec 0c             	sub    $0xc,%esp
   13810:	ff 75 e4             	pushl  -0x1c(%ebp)
   13813:	e8 1e f4 ff ff       	call   12c36 <irq_leave_protection>
   13818:	83 c4 10             	add    $0x10,%esp
    return -1;
   1381b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   13820:	c9                   	leave  
   13821:	c3                   	ret    

00013822 <dev_read>:

// dev_id:设备id，addr:从哪里开始读取
int dev_read(int dev_id,int addr,char* buf,int size){
   13822:	55                   	push   %ebp
   13823:	89 e5                	mov    %esp,%ebp
   13825:	83 ec 18             	sub    $0x18,%esp
    if(is_devid_bad(dev_id)){
   13828:	ff 75 08             	pushl  0x8(%ebp)
   1382b:	e8 66 fe ff ff       	call   13696 <is_devid_bad>
   13830:	83 c4 04             	add    $0x4,%esp
   13833:	85 c0                	test   %eax,%eax
   13835:	74 07                	je     1383e <dev_read+0x1c>
        return -1;
   13837:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1383c:	eb 2e                	jmp    1386c <dev_read+0x4a>
    }

    device_t* dev=dev_tb+dev_id;
   1383e:	8b 55 08             	mov    0x8(%ebp),%edx
   13841:	89 d0                	mov    %edx,%eax
   13843:	c1 e0 02             	shl    $0x2,%eax
   13846:	01 d0                	add    %edx,%eax
   13848:	c1 e0 02             	shl    $0x2,%eax
   1384b:	05 a0 16 03 00       	add    $0x316a0,%eax
   13850:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return dev->desc->read(dev,addr,buf,size);
   13853:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13856:	8b 00                	mov    (%eax),%eax
   13858:	8b 40 28             	mov    0x28(%eax),%eax
   1385b:	ff 75 14             	pushl  0x14(%ebp)
   1385e:	ff 75 10             	pushl  0x10(%ebp)
   13861:	ff 75 0c             	pushl  0xc(%ebp)
   13864:	ff 75 f4             	pushl  -0xc(%ebp)
   13867:	ff d0                	call   *%eax
   13869:	83 c4 10             	add    $0x10,%esp
}
   1386c:	c9                   	leave  
   1386d:	c3                   	ret    

0001386e <dev_write>:

int dev_write(int dev_id,int addr,char* buf,int size){
   1386e:	55                   	push   %ebp
   1386f:	89 e5                	mov    %esp,%ebp
   13871:	83 ec 18             	sub    $0x18,%esp
    if(is_devid_bad(dev_id)){
   13874:	ff 75 08             	pushl  0x8(%ebp)
   13877:	e8 1a fe ff ff       	call   13696 <is_devid_bad>
   1387c:	83 c4 04             	add    $0x4,%esp
   1387f:	85 c0                	test   %eax,%eax
   13881:	74 07                	je     1388a <dev_write+0x1c>
        return -1;
   13883:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13888:	eb 2e                	jmp    138b8 <dev_write+0x4a>
    }

    device_t* dev=dev_tb+dev_id;
   1388a:	8b 55 08             	mov    0x8(%ebp),%edx
   1388d:	89 d0                	mov    %edx,%eax
   1388f:	c1 e0 02             	shl    $0x2,%eax
   13892:	01 d0                	add    %edx,%eax
   13894:	c1 e0 02             	shl    $0x2,%eax
   13897:	05 a0 16 03 00       	add    $0x316a0,%eax
   1389c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return dev->desc->write(dev,addr,buf,size);
   1389f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   138a2:	8b 00                	mov    (%eax),%eax
   138a4:	8b 40 2c             	mov    0x2c(%eax),%eax
   138a7:	ff 75 14             	pushl  0x14(%ebp)
   138aa:	ff 75 10             	pushl  0x10(%ebp)
   138ad:	ff 75 0c             	pushl  0xc(%ebp)
   138b0:	ff 75 f4             	pushl  -0xc(%ebp)
   138b3:	ff d0                	call   *%eax
   138b5:	83 c4 10             	add    $0x10,%esp
}
   138b8:	c9                   	leave  
   138b9:	c3                   	ret    

000138ba <dev_control>:

int dev_control(int dev_id,int cmd,int arg0,int arg1){
   138ba:	55                   	push   %ebp
   138bb:	89 e5                	mov    %esp,%ebp
   138bd:	83 ec 18             	sub    $0x18,%esp
    if(is_devid_bad(dev_id)){
   138c0:	ff 75 08             	pushl  0x8(%ebp)
   138c3:	e8 ce fd ff ff       	call   13696 <is_devid_bad>
   138c8:	83 c4 04             	add    $0x4,%esp
   138cb:	85 c0                	test   %eax,%eax
   138cd:	74 07                	je     138d6 <dev_control+0x1c>
        return -1;
   138cf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   138d4:	eb 2e                	jmp    13904 <dev_control+0x4a>
    }

    device_t* dev=dev_tb+dev_id;
   138d6:	8b 55 08             	mov    0x8(%ebp),%edx
   138d9:	89 d0                	mov    %edx,%eax
   138db:	c1 e0 02             	shl    $0x2,%eax
   138de:	01 d0                	add    %edx,%eax
   138e0:	c1 e0 02             	shl    $0x2,%eax
   138e3:	05 a0 16 03 00       	add    $0x316a0,%eax
   138e8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return dev->desc->control(dev,cmd,arg0,arg1);
   138eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   138ee:	8b 00                	mov    (%eax),%eax
   138f0:	8b 40 30             	mov    0x30(%eax),%eax
   138f3:	ff 75 14             	pushl  0x14(%ebp)
   138f6:	ff 75 10             	pushl  0x10(%ebp)
   138f9:	ff 75 0c             	pushl  0xc(%ebp)
   138fc:	ff 75 f4             	pushl  -0xc(%ebp)
   138ff:	ff d0                	call   *%eax
   13901:	83 c4 10             	add    $0x10,%esp
}
   13904:	c9                   	leave  
   13905:	c3                   	ret    

00013906 <dev_close>:

void dev_close(int dev_id){
   13906:	55                   	push   %ebp
   13907:	89 e5                	mov    %esp,%ebp
   13909:	83 ec 18             	sub    $0x18,%esp
    if(is_devid_bad(dev_id)){
   1390c:	ff 75 08             	pushl  0x8(%ebp)
   1390f:	e8 82 fd ff ff       	call   13696 <is_devid_bad>
   13914:	83 c4 04             	add    $0x4,%esp
   13917:	85 c0                	test   %eax,%eax
   13919:	75 6c                	jne    13987 <dev_close+0x81>
        return;
    }
    
    device_t* dev=dev_tb+dev_id;
   1391b:	8b 55 08             	mov    0x8(%ebp),%edx
   1391e:	89 d0                	mov    %edx,%eax
   13920:	c1 e0 02             	shl    $0x2,%eax
   13923:	01 d0                	add    %edx,%eax
   13925:	c1 e0 02             	shl    $0x2,%eax
   13928:	05 a0 16 03 00       	add    $0x316a0,%eax
   1392d:	89 45 f4             	mov    %eax,-0xc(%ebp)

    irq_state_t state=irq_enter_protection();
   13930:	e8 e9 f2 ff ff       	call   12c1e <irq_enter_protection>
   13935:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if(--dev->open_count == 0){
   13938:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1393b:	8b 40 10             	mov    0x10(%eax),%eax
   1393e:	8d 50 ff             	lea    -0x1(%eax),%edx
   13941:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13944:	89 50 10             	mov    %edx,0x10(%eax)
   13947:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1394a:	8b 40 10             	mov    0x10(%eax),%eax
   1394d:	85 c0                	test   %eax,%eax
   1394f:	75 25                	jne    13976 <dev_close+0x70>
        dev->desc->close(dev);
   13951:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13954:	8b 00                	mov    (%eax),%eax
   13956:	8b 40 34             	mov    0x34(%eax),%eax
   13959:	83 ec 0c             	sub    $0xc,%esp
   1395c:	ff 75 f4             	pushl  -0xc(%ebp)
   1395f:	ff d0                	call   *%eax
   13961:	83 c4 10             	add    $0x10,%esp
        kernel_memset(dev,0,sizeof(device_t));
   13964:	83 ec 04             	sub    $0x4,%esp
   13967:	6a 14                	push   $0x14
   13969:	6a 00                	push   $0x0
   1396b:	ff 75 f4             	pushl  -0xc(%ebp)
   1396e:	e8 ec 12 00 00       	call   14c5f <kernel_memset>
   13973:	83 c4 10             	add    $0x10,%esp
    }

    irq_leave_protection(state);
   13976:	83 ec 0c             	sub    $0xc,%esp
   13979:	ff 75 f0             	pushl  -0x10(%ebp)
   1397c:	e8 b5 f2 ff ff       	call   12c36 <irq_leave_protection>
   13981:	83 c4 10             	add    $0x10,%esp
    
    return;
   13984:	90                   	nop
   13985:	eb 01                	jmp    13988 <dev_close+0x82>
        return;
   13987:	90                   	nop
}
   13988:	c9                   	leave  
   13989:	c3                   	ret    

0001398a <inb>:
static inline uint8_t inb(uint16_t port){
   1398a:	55                   	push   %ebp
   1398b:	89 e5                	mov    %esp,%ebp
   1398d:	83 ec 14             	sub    $0x14,%esp
   13990:	8b 45 08             	mov    0x8(%ebp),%eax
   13993:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__(
   13997:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   1399b:	89 c2                	mov    %eax,%edx
   1399d:	ec                   	in     (%dx),%al
   1399e:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   139a1:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   139a5:	c9                   	leave  
   139a6:	c3                   	ret    

000139a7 <kbd_init>:

};



void kbd_init(void){
   139a7:	55                   	push   %ebp
   139a8:	89 e5                	mov    %esp,%ebp
   139aa:	83 ec 08             	sub    $0x8,%esp
    static int inited=0;

    if(!inited){
   139ad:	a1 a4 20 03 00       	mov    0x320a4,%eax
   139b2:	85 c0                	test   %eax,%eax
   139b4:	75 3d                	jne    139f3 <kbd_init+0x4c>
        kernel_memset(&kbd_stat,0,sizeof(kbd_stat));
   139b6:	83 ec 04             	sub    $0x4,%esp
   139b9:	6a 04                	push   $0x4
   139bb:	6a 00                	push   $0x0
   139bd:	68 a0 20 03 00       	push   $0x320a0
   139c2:	e8 98 12 00 00       	call   14c5f <kernel_memset>
   139c7:	83 c4 10             	add    $0x10,%esp
        irq_install(IRQ1_KEYBOARD,(irq_handler_t)exception_handler_kbd);
   139ca:	83 ec 08             	sub    $0x8,%esp
   139cd:	68 a8 02 01 00       	push   $0x102a8
   139d2:	6a 21                	push   $0x21
   139d4:	e8 28 ed ff ff       	call   12701 <irq_install>
   139d9:	83 c4 10             	add    $0x10,%esp
        irq_enable(IRQ1_KEYBOARD);
   139dc:	83 ec 0c             	sub    $0xc,%esp
   139df:	6a 21                	push   $0x21
   139e1:	e8 5b ea ff ff       	call   12441 <irq_enable>
   139e6:	83 c4 10             	add    $0x10,%esp

        inited=1;
   139e9:	c7 05 a4 20 03 00 01 	movl   $0x1,0x320a4
   139f0:	00 00 00 
    }

}
   139f3:	90                   	nop
   139f4:	c9                   	leave  
   139f5:	c3                   	ret    

000139f6 <is_make_code>:

static inline int is_make_code(uint8_t key_code){
   139f6:	55                   	push   %ebp
   139f7:	89 e5                	mov    %esp,%ebp
   139f9:	83 ec 04             	sub    $0x4,%esp
   139fc:	8b 45 08             	mov    0x8(%ebp),%eax
   139ff:	88 45 fc             	mov    %al,-0x4(%ebp)
    return !(key_code & 0x80);
   13a02:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
   13a06:	f7 d0                	not    %eax
   13a08:	c0 e8 07             	shr    $0x7,%al
   13a0b:	0f b6 c0             	movzbl %al,%eax
}
   13a0e:	c9                   	leave  
   13a0f:	c3                   	ret    

00013a10 <get_key>:

static inline char get_key(uint8_t key_code){
   13a10:	55                   	push   %ebp
   13a11:	89 e5                	mov    %esp,%ebp
   13a13:	83 ec 04             	sub    $0x4,%esp
   13a16:	8b 45 08             	mov    0x8(%ebp),%eax
   13a19:	88 45 fc             	mov    %al,-0x4(%ebp)
    return key_code & 0x7f;
   13a1c:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
   13a20:	83 e0 7f             	and    $0x7f,%eax
}
   13a23:	c9                   	leave  
   13a24:	c3                   	ret    

00013a25 <do_normal_key>:

static void do_normal_key(uint8_t raw_code){
   13a25:	55                   	push   %ebp
   13a26:	89 e5                	mov    %esp,%ebp
   13a28:	83 ec 28             	sub    $0x28,%esp
   13a2b:	8b 45 08             	mov    0x8(%ebp),%eax
   13a2e:	88 45 e4             	mov    %al,-0x1c(%ebp)
    char key=get_key(raw_code);
   13a31:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   13a35:	50                   	push   %eax
   13a36:	e8 d5 ff ff ff       	call   13a10 <get_key>
   13a3b:	83 c4 04             	add    $0x4,%esp
   13a3e:	88 45 f7             	mov    %al,-0x9(%ebp)
    int is_make=is_make_code(raw_code);
   13a41:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   13a45:	50                   	push   %eax
   13a46:	e8 ab ff ff ff       	call   139f6 <is_make_code>
   13a4b:	83 c4 04             	add    $0x4,%esp
   13a4e:	89 45 f0             	mov    %eax,-0x10(%ebp)

    switch(key)
   13a51:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   13a55:	83 e8 1d             	sub    $0x1d,%eax
   13a58:	83 f8 1e             	cmp    $0x1e,%eax
   13a5b:	0f 87 e7 00 00 00    	ja     13b48 <do_normal_key+0x123>
   13a61:	8b 04 85 1c 5e 01 00 	mov    0x15e1c(,%eax,4),%eax
   13a68:	ff e0                	jmp    *%eax
    {
    case KEY_RSHIFT:
        kbd_stat.rshift_press=is_make ? 1 : 0;
   13a6a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   13a6e:	0f 95 c0             	setne  %al
   13a71:	c1 e0 07             	shl    $0x7,%eax
   13a74:	c0 f8 07             	sar    $0x7,%al
   13a77:	83 e0 01             	and    $0x1,%eax
   13a7a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   13a81:	0f b6 05 a0 20 03 00 	movzbl 0x320a0,%eax
   13a88:	83 e0 fb             	and    $0xfffffffb,%eax
   13a8b:	09 d0                	or     %edx,%eax
   13a8d:	a2 a0 20 03 00       	mov    %al,0x320a0
        break;
   13a92:	e9 51 01 00 00       	jmp    13be8 <do_normal_key+0x1c3>
    case KEY_LSHIFT:
        kbd_stat.lshift_press=is_make ? 1 : 0;
   13a97:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   13a9b:	0f 95 c0             	setne  %al
   13a9e:	c1 e0 07             	shl    $0x7,%eax
   13aa1:	c0 f8 07             	sar    $0x7,%al
   13aa4:	83 e0 01             	and    $0x1,%eax
   13aa7:	8d 14 00             	lea    (%eax,%eax,1),%edx
   13aaa:	0f b6 05 a0 20 03 00 	movzbl 0x320a0,%eax
   13ab1:	83 e0 fd             	and    $0xfffffffd,%eax
   13ab4:	09 d0                	or     %edx,%eax
   13ab6:	a2 a0 20 03 00       	mov    %al,0x320a0
        break;
   13abb:	e9 28 01 00 00       	jmp    13be8 <do_normal_key+0x1c3>
    case KEY_CAPS:
        if(is_make){
   13ac0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   13ac4:	0f 84 1a 01 00 00    	je     13be4 <do_normal_key+0x1bf>
            kbd_stat.caps_lock=~kbd_stat.caps_lock;
   13aca:	0f b6 05 a0 20 03 00 	movzbl 0x320a0,%eax
   13ad1:	c1 e0 07             	shl    $0x7,%eax
   13ad4:	c0 f8 07             	sar    $0x7,%al
   13ad7:	f7 d0                	not    %eax
   13ad9:	c1 e0 07             	shl    $0x7,%eax
   13adc:	c0 f8 07             	sar    $0x7,%al
   13adf:	83 e0 01             	and    $0x1,%eax
   13ae2:	89 c2                	mov    %eax,%edx
   13ae4:	0f b6 05 a0 20 03 00 	movzbl 0x320a0,%eax
   13aeb:	83 e0 fe             	and    $0xfffffffe,%eax
   13aee:	09 d0                	or     %edx,%eax
   13af0:	a2 a0 20 03 00       	mov    %al,0x320a0
        }
        break;
   13af5:	e9 ea 00 00 00       	jmp    13be4 <do_normal_key+0x1bf>
    case KEY_ALT:
        kbd_stat.lalt_press=is_make;
   13afa:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13afd:	c1 e0 07             	shl    $0x7,%eax
   13b00:	c0 f8 07             	sar    $0x7,%al
   13b03:	83 e0 01             	and    $0x1,%eax
   13b06:	c1 e0 04             	shl    $0x4,%eax
   13b09:	89 c2                	mov    %eax,%edx
   13b0b:	0f b6 05 a0 20 03 00 	movzbl 0x320a0,%eax
   13b12:	83 e0 ef             	and    $0xffffffef,%eax
   13b15:	09 d0                	or     %edx,%eax
   13b17:	a2 a0 20 03 00       	mov    %al,0x320a0
        break;
   13b1c:	e9 c7 00 00 00       	jmp    13be8 <do_normal_key+0x1c3>
    case KEY_CTRL:
        kbd_stat.lctrl_press=is_make;
   13b21:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13b24:	c1 e0 07             	shl    $0x7,%eax
   13b27:	c0 f8 07             	sar    $0x7,%al
   13b2a:	83 e0 01             	and    $0x1,%eax
   13b2d:	c1 e0 05             	shl    $0x5,%eax
   13b30:	89 c2                	mov    %eax,%edx
   13b32:	0f b6 05 a0 20 03 00 	movzbl 0x320a0,%eax
   13b39:	83 e0 df             	and    $0xffffffdf,%eax
   13b3c:	09 d0                	or     %edx,%eax
   13b3e:	a2 a0 20 03 00       	mov    %al,0x320a0
        break;
   13b43:	e9 a0 00 00 00       	jmp    13be8 <do_normal_key+0x1c3>
    case KEY_F1:
        break;
    default:
        if(is_make){
   13b48:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   13b4c:	0f 84 95 00 00 00    	je     13be7 <do_normal_key+0x1c2>
            if(kbd_stat.lshift_press || kbd_stat.rshift_press){
   13b52:	0f b6 05 a0 20 03 00 	movzbl 0x320a0,%eax
   13b59:	83 e0 02             	and    $0x2,%eax
   13b5c:	84 c0                	test   %al,%al
   13b5e:	75 0e                	jne    13b6e <do_normal_key+0x149>
   13b60:	0f b6 05 a0 20 03 00 	movzbl 0x320a0,%eax
   13b67:	83 e0 04             	and    $0x4,%eax
   13b6a:	84 c0                	test   %al,%al
   13b6c:	74 11                	je     13b7f <do_normal_key+0x15a>
                key=map_table[key].func;
   13b6e:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   13b72:	0f b6 84 00 a1 5d 01 	movzbl 0x15da1(%eax,%eax,1),%eax
   13b79:	00 
   13b7a:	88 45 f7             	mov    %al,-0x9(%ebp)
   13b7d:	eb 0f                	jmp    13b8e <do_normal_key+0x169>
            }
            else{
                key=map_table[key].normal;
   13b7f:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   13b83:	0f b6 84 00 a0 5d 01 	movzbl 0x15da0(%eax,%eax,1),%eax
   13b8a:	00 
   13b8b:	88 45 f7             	mov    %al,-0x9(%ebp)
            }

            if(kbd_stat.caps_lock){
   13b8e:	0f b6 05 a0 20 03 00 	movzbl 0x320a0,%eax
   13b95:	83 e0 01             	and    $0x1,%eax
   13b98:	84 c0                	test   %al,%al
   13b9a:	74 2e                	je     13bca <do_normal_key+0x1a5>
                if((key>='A') && (key <='Z')){
   13b9c:	80 7d f7 40          	cmpb   $0x40,-0x9(%ebp)
   13ba0:	7e 12                	jle    13bb4 <do_normal_key+0x18f>
   13ba2:	80 7d f7 5a          	cmpb   $0x5a,-0x9(%ebp)
   13ba6:	7f 0c                	jg     13bb4 <do_normal_key+0x18f>
                    key=key-'A'+'a';
   13ba8:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
   13bac:	83 c0 20             	add    $0x20,%eax
   13baf:	88 45 f7             	mov    %al,-0x9(%ebp)
   13bb2:	eb 16                	jmp    13bca <do_normal_key+0x1a5>
                }
                else if((key >= 'a') && (key <= 'z')){
   13bb4:	80 7d f7 60          	cmpb   $0x60,-0x9(%ebp)
   13bb8:	7e 10                	jle    13bca <do_normal_key+0x1a5>
   13bba:	80 7d f7 7a          	cmpb   $0x7a,-0x9(%ebp)
   13bbe:	7f 0a                	jg     13bca <do_normal_key+0x1a5>
                    key=key-'a'+'A';
   13bc0:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
   13bc4:	83 e8 20             	sub    $0x20,%eax
   13bc7:	88 45 f7             	mov    %al,-0x9(%ebp)
                }
            }

            log_printf("key: %c",key);
   13bca:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   13bce:	83 ec 08             	sub    $0x8,%esp
   13bd1:	50                   	push   %eax
   13bd2:	68 14 5e 01 00       	push   $0x15e14
   13bd7:	e8 a6 16 00 00       	call   15282 <log_printf>
   13bdc:	83 c4 10             	add    $0x10,%esp
        }
        break;
   13bdf:	eb 06                	jmp    13be7 <do_normal_key+0x1c2>
        break;
   13be1:	90                   	nop
   13be2:	eb 04                	jmp    13be8 <do_normal_key+0x1c3>
        break;
   13be4:	90                   	nop
   13be5:	eb 01                	jmp    13be8 <do_normal_key+0x1c3>
        break;
   13be7:	90                   	nop
    }
}
   13be8:	90                   	nop
   13be9:	c9                   	leave  
   13bea:	c3                   	ret    

00013beb <do_e0_key>:

void do_e0_key(uint8_t raw_code){
   13beb:	55                   	push   %ebp
   13bec:	89 e5                	mov    %esp,%ebp
   13bee:	83 ec 14             	sub    $0x14,%esp
   13bf1:	8b 45 08             	mov    0x8(%ebp),%eax
   13bf4:	88 45 ec             	mov    %al,-0x14(%ebp)
    char key=get_key(raw_code);
   13bf7:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
   13bfb:	50                   	push   %eax
   13bfc:	e8 0f fe ff ff       	call   13a10 <get_key>
   13c01:	83 c4 04             	add    $0x4,%esp
   13c04:	88 45 ff             	mov    %al,-0x1(%ebp)
    int is_make=is_make_code(raw_code);
   13c07:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
   13c0b:	50                   	push   %eax
   13c0c:	e8 e5 fd ff ff       	call   139f6 <is_make_code>
   13c11:	83 c4 04             	add    $0x4,%esp
   13c14:	89 45 f8             	mov    %eax,-0x8(%ebp)

    switch (key)
   13c17:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
   13c1b:	83 f8 1d             	cmp    $0x1d,%eax
   13c1e:	74 07                	je     13c27 <do_e0_key+0x3c>
   13c20:	83 f8 38             	cmp    $0x38,%eax
   13c23:	74 26                	je     13c4b <do_e0_key+0x60>
        break;
    case KEY_ALT:
        kbd_stat.ralt_press;
        break;
    default:
        break;
   13c25:	eb 25                	jmp    13c4c <do_e0_key+0x61>
        kbd_stat.rctrl_press=is_make;
   13c27:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13c2a:	c1 e0 07             	shl    $0x7,%eax
   13c2d:	c0 f8 07             	sar    $0x7,%al
   13c30:	83 e0 01             	and    $0x1,%eax
   13c33:	c1 e0 06             	shl    $0x6,%eax
   13c36:	89 c2                	mov    %eax,%edx
   13c38:	0f b6 05 a0 20 03 00 	movzbl 0x320a0,%eax
   13c3f:	83 e0 bf             	and    $0xffffffbf,%eax
   13c42:	09 d0                	or     %edx,%eax
   13c44:	a2 a0 20 03 00       	mov    %al,0x320a0
        break;
   13c49:	eb 01                	jmp    13c4c <do_e0_key+0x61>
        break;
   13c4b:	90                   	nop
    }
}
   13c4c:	90                   	nop
   13c4d:	c9                   	leave  
   13c4e:	c3                   	ret    

00013c4f <do_handler_kbd>:

void do_handler_kbd(exception_frame_t *frame){
   13c4f:	55                   	push   %ebp
   13c50:	89 e5                	mov    %esp,%ebp
   13c52:	83 ec 18             	sub    $0x18,%esp
    static enum{
        NORMAL,
        BEGIN_E0,
        BEGIN_E1,
    }recv_state=NORMAL;
    uint8_t status=inb(KBD_PORT_STAT);
   13c55:	6a 64                	push   $0x64
   13c57:	e8 2e fd ff ff       	call   1398a <inb>
   13c5c:	83 c4 04             	add    $0x4,%esp
   13c5f:	88 45 f7             	mov    %al,-0x9(%ebp)

    if(!(status & KBD_STAT_RECV_READY)){
   13c62:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
   13c66:	83 e0 01             	and    $0x1,%eax
   13c69:	85 c0                	test   %eax,%eax
   13c6b:	75 12                	jne    13c7f <do_handler_kbd+0x30>
        pic_send_eoi(IRQ1_KEYBOARD);
   13c6d:	83 ec 0c             	sub    $0xc,%esp
   13c70:	6a 21                	push   $0x21
   13c72:	e8 7c ef ff ff       	call   12bf3 <pic_send_eoi>
   13c77:	83 c4 10             	add    $0x10,%esp
        return;
   13c7a:	e9 8e 00 00 00       	jmp    13d0d <do_handler_kbd+0xbe>
    }

    uint8_t raw_code=inb(KBD_PORT_DATA);
   13c7f:	83 ec 0c             	sub    $0xc,%esp
   13c82:	6a 60                	push   $0x60
   13c84:	e8 01 fd ff ff       	call   1398a <inb>
   13c89:	83 c4 10             	add    $0x10,%esp
   13c8c:	88 45 f6             	mov    %al,-0xa(%ebp)

    if(raw_code == KEY_E0){
   13c8f:	80 7d f6 e0          	cmpb   $0xe0,-0xa(%ebp)
   13c93:	75 0a                	jne    13c9f <do_handler_kbd+0x50>
        recv_state=BEGIN_E0;
   13c95:	c7 05 a8 20 03 00 01 	movl   $0x1,0x320a8
   13c9c:	00 00 00 
    }

    if(raw_code == KEY_E1){
   13c9f:	80 7d f6 e1          	cmpb   $0xe1,-0xa(%ebp)
   13ca3:	75 0c                	jne    13cb1 <do_handler_kbd+0x62>
        recv_state=BEGIN_E1;
   13ca5:	c7 05 a8 20 03 00 02 	movl   $0x2,0x320a8
   13cac:	00 00 00 
   13caf:	eb 4f                	jmp    13d00 <do_handler_kbd+0xb1>
    }
    else{
        switch (recv_state)
   13cb1:	a1 a8 20 03 00       	mov    0x320a8,%eax
   13cb6:	83 f8 01             	cmp    $0x1,%eax
   13cb9:	74 1e                	je     13cd9 <do_handler_kbd+0x8a>
   13cbb:	83 f8 01             	cmp    $0x1,%eax
   13cbe:	72 07                	jb     13cc7 <do_handler_kbd+0x78>
   13cc0:	83 f8 02             	cmp    $0x2,%eax
   13cc3:	74 30                	je     13cf5 <do_handler_kbd+0xa6>
            break;
        case BEGIN_E1:
            recv_state=NORMAL;
            break;
        default:
            break;
   13cc5:	eb 39                	jmp    13d00 <do_handler_kbd+0xb1>
            do_normal_key(raw_code);
   13cc7:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
   13ccb:	83 ec 0c             	sub    $0xc,%esp
   13cce:	50                   	push   %eax
   13ccf:	e8 51 fd ff ff       	call   13a25 <do_normal_key>
   13cd4:	83 c4 10             	add    $0x10,%esp
            break;
   13cd7:	eb 27                	jmp    13d00 <do_handler_kbd+0xb1>
            do_e0_key(raw_code);
   13cd9:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
   13cdd:	83 ec 0c             	sub    $0xc,%esp
   13ce0:	50                   	push   %eax
   13ce1:	e8 05 ff ff ff       	call   13beb <do_e0_key>
   13ce6:	83 c4 10             	add    $0x10,%esp
            recv_state=NORMAL;
   13ce9:	c7 05 a8 20 03 00 00 	movl   $0x0,0x320a8
   13cf0:	00 00 00 
            break;
   13cf3:	eb 0b                	jmp    13d00 <do_handler_kbd+0xb1>
            recv_state=NORMAL;
   13cf5:	c7 05 a8 20 03 00 00 	movl   $0x0,0x320a8
   13cfc:	00 00 00 
            break;
   13cff:	90                   	nop
        }
    }

    pic_send_eoi(IRQ1_KEYBOARD);
   13d00:	83 ec 0c             	sub    $0xc,%esp
   13d03:	6a 21                	push   $0x21
   13d05:	e8 e9 ee ff ff       	call   12bf3 <pic_send_eoi>
   13d0a:	83 c4 10             	add    $0x10,%esp
   13d0d:	c9                   	leave  
   13d0e:	c3                   	ret    

00013d0f <outb>:
static inline void outb(uint16_t port,uint8_t data){
   13d0f:	55                   	push   %ebp
   13d10:	89 e5                	mov    %esp,%ebp
   13d12:	83 ec 08             	sub    $0x8,%esp
   13d15:	8b 55 08             	mov    0x8(%ebp),%edx
   13d18:	8b 45 0c             	mov    0xc(%ebp),%eax
   13d1b:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   13d1f:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile(
   13d22:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   13d26:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   13d2a:	ee                   	out    %al,(%dx)
}
   13d2b:	90                   	nop
   13d2c:	c9                   	leave  
   13d2d:	c3                   	ret    

00013d2e <do_handler_time>:
#include "dev/time.h"

// 定时器计数
static uint32_t sys_tick;

void do_handler_time(exception_frame_t* frame){
   13d2e:	55                   	push   %ebp
   13d2f:	89 e5                	mov    %esp,%ebp
   13d31:	83 ec 08             	sub    $0x8,%esp
    sys_tick++;
   13d34:	a1 ac 20 03 00       	mov    0x320ac,%eax
   13d39:	83 c0 01             	add    $0x1,%eax
   13d3c:	a3 ac 20 03 00       	mov    %eax,0x320ac
    pic_send_eoi(IRQ0_TIMER);
   13d41:	83 ec 0c             	sub    $0xc,%esp
   13d44:	6a 20                	push   $0x20
   13d46:	e8 a8 ee ff ff       	call   12bf3 <pic_send_eoi>
   13d4b:	83 c4 10             	add    $0x10,%esp
    task_time_tick();
   13d4e:	e8 58 d9 ff ff       	call   116ab <task_time_tick>
}
   13d53:	90                   	nop
   13d54:	c9                   	leave  
   13d55:	c3                   	ret    

00013d56 <init_pit>:

// 定时器硬件初始化
static void init_pit(void){
   13d56:	55                   	push   %ebp
   13d57:	89 e5                	mov    %esp,%ebp
   13d59:	83 ec 18             	sub    $0x18,%esp
    
    uint32_t reload_count = PIT_OSC_FREQ / (1000.0 / OS_TICK_MS);
   13d5c:	c7 45 f4 9b 2e 00 00 	movl   $0x2e9b,-0xc(%ebp)
    // 设置多少秒产生中断
    outb(PIT_COMMAND_MODE_PORT, PIT_CHANNEL0 | PIT_LOAD_LOHI | PIT_MODE3);
   13d63:	6a 36                	push   $0x36
   13d65:	6a 43                	push   $0x43
   13d67:	e8 a3 ff ff ff       	call   13d0f <outb>
   13d6c:	83 c4 08             	add    $0x8,%esp
    outb(PIT_CHANNEL0_DATA_PORT, reload_count & 0xFF);   // 加载低8位
   13d6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13d72:	0f b6 c0             	movzbl %al,%eax
   13d75:	50                   	push   %eax
   13d76:	6a 40                	push   $0x40
   13d78:	e8 92 ff ff ff       	call   13d0f <outb>
   13d7d:	83 c4 08             	add    $0x8,%esp
    outb(PIT_CHANNEL0_DATA_PORT, (reload_count >> 8) & 0xFF); // 再加载高8位
   13d80:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13d83:	c1 e8 08             	shr    $0x8,%eax
   13d86:	0f b6 c0             	movzbl %al,%eax
   13d89:	50                   	push   %eax
   13d8a:	6a 40                	push   $0x40
   13d8c:	e8 7e ff ff ff       	call   13d0f <outb>
   13d91:	83 c4 08             	add    $0x8,%esp

    irq_install(IRQ0_TIMER, (irq_handler_t)exception_handler_time);
   13d94:	83 ec 08             	sub    $0x8,%esp
   13d97:	68 89 02 01 00       	push   $0x10289
   13d9c:	6a 20                	push   $0x20
   13d9e:	e8 5e e9 ff ff       	call   12701 <irq_install>
   13da3:	83 c4 10             	add    $0x10,%esp
    irq_enable(IRQ0_TIMER);
   13da6:	83 ec 0c             	sub    $0xc,%esp
   13da9:	6a 20                	push   $0x20
   13dab:	e8 91 e6 ff ff       	call   12441 <irq_enable>
   13db0:	83 c4 10             	add    $0x10,%esp
}
   13db3:	90                   	nop
   13db4:	c9                   	leave  
   13db5:	c3                   	ret    

00013db6 <time_init>:

// 定时器初始化
void time_init(void){
   13db6:	55                   	push   %ebp
   13db7:	89 e5                	mov    %esp,%ebp
   13db9:	83 ec 08             	sub    $0x8,%esp
    sys_tick=0;
   13dbc:	c7 05 ac 20 03 00 00 	movl   $0x0,0x320ac
   13dc3:	00 00 00 
    init_pit();
   13dc6:	e8 8b ff ff ff       	call   13d56 <init_pit>
   13dcb:	90                   	nop
   13dcc:	c9                   	leave  
   13dcd:	c3                   	ret    

00013dce <get_tty>:
#include "dev/kbd.h"
#include "dev/console.h"

static tty_t tty_devs[TTY_NR];

static tty_t* get_tty(device_t* dev){
   13dce:	55                   	push   %ebp
   13dcf:	89 e5                	mov    %esp,%ebp
   13dd1:	83 ec 18             	sub    $0x18,%esp
    int idx=dev->minor;
   13dd4:	8b 45 08             	mov    0x8(%ebp),%eax
   13dd7:	8b 40 08             	mov    0x8(%eax),%eax
   13dda:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if((idx<0) || (idx>=TTY_NR) || (!dev->open_count)){
   13ddd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   13de1:	78 10                	js     13df3 <get_tty+0x25>
   13de3:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   13de7:	7f 0a                	jg     13df3 <get_tty+0x25>
   13de9:	8b 45 08             	mov    0x8(%ebp),%eax
   13dec:	8b 40 10             	mov    0x10(%eax),%eax
   13def:	85 c0                	test   %eax,%eax
   13df1:	75 1a                	jne    13e0d <get_tty+0x3f>
        log_printf("tty is not opened. tty=%d\n",idx);
   13df3:	83 ec 08             	sub    $0x8,%esp
   13df6:	ff 75 f4             	pushl  -0xc(%ebp)
   13df9:	68 98 5e 01 00       	push   $0x15e98
   13dfe:	e8 7f 14 00 00       	call   15282 <log_printf>
   13e03:	83 c4 10             	add    $0x10,%esp
        return (tty_t*)0;
   13e06:	b8 00 00 00 00       	mov    $0x0,%eax
   13e0b:	eb 0e                	jmp    13e1b <get_tty+0x4d>
    }

    return tty_devs+idx;
   13e0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13e10:	69 c0 40 04 00 00    	imul   $0x440,%eax,%eax
   13e16:	05 c0 20 03 00       	add    $0x320c0,%eax
}
   13e1b:	c9                   	leave  
   13e1c:	c3                   	ret    

00013e1d <tty_fifo_init>:

void tty_fifo_init(tty_fifo_t* fifo,char* buf,int size){
   13e1d:	55                   	push   %ebp
   13e1e:	89 e5                	mov    %esp,%ebp
    fifo->buf=buf;
   13e20:	8b 45 08             	mov    0x8(%ebp),%eax
   13e23:	8b 55 0c             	mov    0xc(%ebp),%edx
   13e26:	89 10                	mov    %edx,(%eax)
    fifo->size=size;
   13e28:	8b 45 08             	mov    0x8(%ebp),%eax
   13e2b:	8b 55 10             	mov    0x10(%ebp),%edx
   13e2e:	89 50 04             	mov    %edx,0x4(%eax)
    fifo->count=0;
   13e31:	8b 45 08             	mov    0x8(%ebp),%eax
   13e34:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    fifo->read=fifo->write=0;
   13e3b:	8b 45 08             	mov    0x8(%ebp),%eax
   13e3e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
   13e45:	8b 45 08             	mov    0x8(%ebp),%eax
   13e48:	8b 50 0c             	mov    0xc(%eax),%edx
   13e4b:	8b 45 08             	mov    0x8(%ebp),%eax
   13e4e:	89 50 08             	mov    %edx,0x8(%eax)
}
   13e51:	90                   	nop
   13e52:	5d                   	pop    %ebp
   13e53:	c3                   	ret    

00013e54 <tty_fifo_put>:

int tty_fifo_put(tty_fifo_t* fifo,char c){
   13e54:	55                   	push   %ebp
   13e55:	89 e5                	mov    %esp,%ebp
   13e57:	53                   	push   %ebx
   13e58:	83 ec 04             	sub    $0x4,%esp
   13e5b:	8b 45 0c             	mov    0xc(%ebp),%eax
   13e5e:	88 45 f8             	mov    %al,-0x8(%ebp)
    if(fifo->count>=fifo->size){
   13e61:	8b 45 08             	mov    0x8(%ebp),%eax
   13e64:	8b 50 10             	mov    0x10(%eax),%edx
   13e67:	8b 45 08             	mov    0x8(%ebp),%eax
   13e6a:	8b 40 04             	mov    0x4(%eax),%eax
   13e6d:	39 c2                	cmp    %eax,%edx
   13e6f:	7c 07                	jl     13e78 <tty_fifo_put+0x24>
        return -1;
   13e71:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13e76:	eb 4b                	jmp    13ec3 <tty_fifo_put+0x6f>
    }

    fifo->buf[fifo->write++]=c;
   13e78:	8b 45 08             	mov    0x8(%ebp),%eax
   13e7b:	8b 18                	mov    (%eax),%ebx
   13e7d:	8b 45 08             	mov    0x8(%ebp),%eax
   13e80:	8b 40 0c             	mov    0xc(%eax),%eax
   13e83:	8d 48 01             	lea    0x1(%eax),%ecx
   13e86:	8b 55 08             	mov    0x8(%ebp),%edx
   13e89:	89 4a 0c             	mov    %ecx,0xc(%edx)
   13e8c:	8d 14 03             	lea    (%ebx,%eax,1),%edx
   13e8f:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   13e93:	88 02                	mov    %al,(%edx)
    if(fifo->write>=fifo->size){
   13e95:	8b 45 08             	mov    0x8(%ebp),%eax
   13e98:	8b 50 0c             	mov    0xc(%eax),%edx
   13e9b:	8b 45 08             	mov    0x8(%ebp),%eax
   13e9e:	8b 40 04             	mov    0x4(%eax),%eax
   13ea1:	39 c2                	cmp    %eax,%edx
   13ea3:	7c 0a                	jl     13eaf <tty_fifo_put+0x5b>
        fifo->write=0;
   13ea5:	8b 45 08             	mov    0x8(%ebp),%eax
   13ea8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    }
    fifo->count++;
   13eaf:	8b 45 08             	mov    0x8(%ebp),%eax
   13eb2:	8b 40 10             	mov    0x10(%eax),%eax
   13eb5:	8d 50 01             	lea    0x1(%eax),%edx
   13eb8:	8b 45 08             	mov    0x8(%ebp),%eax
   13ebb:	89 50 10             	mov    %edx,0x10(%eax)

    return 0;
   13ebe:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13ec3:	83 c4 04             	add    $0x4,%esp
   13ec6:	5b                   	pop    %ebx
   13ec7:	5d                   	pop    %ebp
   13ec8:	c3                   	ret    

00013ec9 <tty_fifo_get>:

int tty_fifo_get(tty_fifo_t* fifo,char* c){
   13ec9:	55                   	push   %ebp
   13eca:	89 e5                	mov    %esp,%ebp
   13ecc:	53                   	push   %ebx
    if(fifo->count<=0){
   13ecd:	8b 45 08             	mov    0x8(%ebp),%eax
   13ed0:	8b 40 10             	mov    0x10(%eax),%eax
   13ed3:	85 c0                	test   %eax,%eax
   13ed5:	7f 07                	jg     13ede <tty_fifo_get+0x15>
        return -1;
   13ed7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13edc:	eb 4c                	jmp    13f2a <tty_fifo_get+0x61>
    }

    *c=fifo->buf[fifo->read++];
   13ede:	8b 45 08             	mov    0x8(%ebp),%eax
   13ee1:	8b 18                	mov    (%eax),%ebx
   13ee3:	8b 45 08             	mov    0x8(%ebp),%eax
   13ee6:	8b 40 08             	mov    0x8(%eax),%eax
   13ee9:	8d 48 01             	lea    0x1(%eax),%ecx
   13eec:	8b 55 08             	mov    0x8(%ebp),%edx
   13eef:	89 4a 08             	mov    %ecx,0x8(%edx)
   13ef2:	01 d8                	add    %ebx,%eax
   13ef4:	0f b6 10             	movzbl (%eax),%edx
   13ef7:	8b 45 0c             	mov    0xc(%ebp),%eax
   13efa:	88 10                	mov    %dl,(%eax)
    if(fifo->read>=fifo->size){
   13efc:	8b 45 08             	mov    0x8(%ebp),%eax
   13eff:	8b 50 08             	mov    0x8(%eax),%edx
   13f02:	8b 45 08             	mov    0x8(%ebp),%eax
   13f05:	8b 40 04             	mov    0x4(%eax),%eax
   13f08:	39 c2                	cmp    %eax,%edx
   13f0a:	7c 0a                	jl     13f16 <tty_fifo_get+0x4d>
        fifo->read=0;
   13f0c:	8b 45 08             	mov    0x8(%ebp),%eax
   13f0f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    }
    fifo->count--;
   13f16:	8b 45 08             	mov    0x8(%ebp),%eax
   13f19:	8b 40 10             	mov    0x10(%eax),%eax
   13f1c:	8d 50 ff             	lea    -0x1(%eax),%edx
   13f1f:	8b 45 08             	mov    0x8(%ebp),%eax
   13f22:	89 50 10             	mov    %edx,0x10(%eax)

    return 0;
   13f25:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13f2a:	5b                   	pop    %ebx
   13f2b:	5d                   	pop    %ebp
   13f2c:	c3                   	ret    

00013f2d <tty_open>:

int tty_open(device_t* dev){
   13f2d:	55                   	push   %ebp
   13f2e:	89 e5                	mov    %esp,%ebp
   13f30:	83 ec 18             	sub    $0x18,%esp
    int idx=dev->minor;
   13f33:	8b 45 08             	mov    0x8(%ebp),%eax
   13f36:	8b 40 08             	mov    0x8(%eax),%eax
   13f39:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if((idx<0)&&(idx>=TTY_NR)){
   13f3c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   13f40:	79 23                	jns    13f65 <tty_open+0x38>
   13f42:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   13f46:	7e 1d                	jle    13f65 <tty_open+0x38>
        log_printf("open tty failed. incorrect tty num=%d\n",idx);
   13f48:	83 ec 08             	sub    $0x8,%esp
   13f4b:	ff 75 f4             	pushl  -0xc(%ebp)
   13f4e:	68 b4 5e 01 00       	push   $0x15eb4
   13f53:	e8 2a 13 00 00       	call   15282 <log_printf>
   13f58:	83 c4 10             	add    $0x10,%esp
        return -1;
   13f5b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13f60:	e9 a3 00 00 00       	jmp    14008 <tty_open+0xdb>
    }

    tty_t* tty=tty_devs+idx;
   13f65:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13f68:	69 c0 40 04 00 00    	imul   $0x440,%eax,%eax
   13f6e:	05 c0 20 03 00       	add    $0x320c0,%eax
   13f73:	89 45 f0             	mov    %eax,-0x10(%ebp)
    tty_fifo_init(&tty->ofifo,tty->obuf,TTY_OBUF_SIZE);
   13f76:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13f79:	8b 55 f0             	mov    -0x10(%ebp),%edx
   13f7c:	81 c2 00 04 00 00    	add    $0x400,%edx
   13f82:	83 ec 04             	sub    $0x4,%esp
   13f85:	68 00 02 00 00       	push   $0x200
   13f8a:	50                   	push   %eax
   13f8b:	52                   	push   %edx
   13f8c:	e8 8c fe ff ff       	call   13e1d <tty_fifo_init>
   13f91:	83 c4 10             	add    $0x10,%esp
    sem_init(&tty->osem,TTY_OBUF_SIZE);
   13f94:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13f97:	05 2c 04 00 00       	add    $0x42c,%eax
   13f9c:	83 ec 08             	sub    $0x8,%esp
   13f9f:	68 00 02 00 00       	push   $0x200
   13fa4:	50                   	push   %eax
   13fa5:	e8 44 07 00 00       	call   146ee <sem_init>
   13faa:	83 c4 10             	add    $0x10,%esp
    tty_fifo_init(&tty->ififo,tty->ibuf,TTY_IBUF_SIZE);
   13fad:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13fb0:	8d 90 00 02 00 00    	lea    0x200(%eax),%edx
   13fb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13fb9:	05 14 04 00 00       	add    $0x414,%eax
   13fbe:	83 ec 04             	sub    $0x4,%esp
   13fc1:	68 00 02 00 00       	push   $0x200
   13fc6:	52                   	push   %edx
   13fc7:	50                   	push   %eax
   13fc8:	e8 50 fe ff ff       	call   13e1d <tty_fifo_init>
   13fcd:	83 c4 10             	add    $0x10,%esp

    tty->oflags=TTY_OCRLF;
   13fd0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13fd3:	c7 80 3c 04 00 00 01 	movl   $0x1,0x43c(%eax)
   13fda:	00 00 00 
    tty->console_index=idx;
   13fdd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13fe0:	8b 55 f4             	mov    -0xc(%ebp),%edx
   13fe3:	89 90 28 04 00 00    	mov    %edx,0x428(%eax)

    kbd_init();    
   13fe9:	e8 b9 f9 ff ff       	call   139a7 <kbd_init>
    console_init(tty->console_index);
   13fee:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13ff1:	8b 80 28 04 00 00    	mov    0x428(%eax),%eax
   13ff7:	83 ec 0c             	sub    $0xc,%esp
   13ffa:	50                   	push   %eax
   13ffb:	e8 22 f0 ff ff       	call   13022 <console_init>
   14000:	83 c4 10             	add    $0x10,%esp
    
    return 0;
   14003:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14008:	c9                   	leave  
   14009:	c3                   	ret    

0001400a <tty_read>:

int tty_read(device_t* dev,int addr,char* buf,int size){
   1400a:	55                   	push   %ebp
   1400b:	89 e5                	mov    %esp,%ebp
    return size;
   1400d:	8b 45 14             	mov    0x14(%ebp),%eax
}
   14010:	5d                   	pop    %ebp
   14011:	c3                   	ret    

00014012 <tty_write>:

int tty_write(device_t* dev,int addr,char* buf,int size){
   14012:	55                   	push   %ebp
   14013:	89 e5                	mov    %esp,%ebp
   14015:	83 ec 28             	sub    $0x28,%esp
    if (size < 0){
   14018:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   1401c:	79 0a                	jns    14028 <tty_write+0x16>
        return -1;
   1401e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14023:	e9 e5 00 00 00       	jmp    1410d <tty_write+0xfb>
    }

    tty_t* tty=get_tty(dev);
   14028:	83 ec 0c             	sub    $0xc,%esp
   1402b:	ff 75 08             	pushl  0x8(%ebp)
   1402e:	e8 9b fd ff ff       	call   13dce <get_tty>
   14033:	83 c4 10             	add    $0x10,%esp
   14036:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (!tty){
   14039:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1403d:	75 0a                	jne    14049 <tty_write+0x37>
        return -1;
   1403f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14044:	e9 c4 00 00 00       	jmp    1410d <tty_write+0xfb>
    }

    int len =0;
   14049:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while(size){
   14050:	e9 a5 00 00 00       	jmp    140fa <tty_write+0xe8>
        char c=*buf++;
   14055:	8b 45 10             	mov    0x10(%ebp),%eax
   14058:	8d 50 01             	lea    0x1(%eax),%edx
   1405b:	89 55 10             	mov    %edx,0x10(%ebp)
   1405e:	0f b6 00             	movzbl (%eax),%eax
   14061:	88 45 ef             	mov    %al,-0x11(%ebp)

        if(c == '\n' && (tty->oflags & TTY_OCRLF)){
   14064:	80 7d ef 0a          	cmpb   $0xa,-0x11(%ebp)
   14068:	75 43                	jne    140ad <tty_write+0x9b>
   1406a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1406d:	8b 80 3c 04 00 00    	mov    0x43c(%eax),%eax
   14073:	83 e0 01             	and    $0x1,%eax
   14076:	85 c0                	test   %eax,%eax
   14078:	74 33                	je     140ad <tty_write+0x9b>
            sem_wait(&tty->osem);
   1407a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1407d:	05 2c 04 00 00       	add    $0x42c,%eax
   14082:	83 ec 0c             	sub    $0xc,%esp
   14085:	50                   	push   %eax
   14086:	e8 86 06 00 00       	call   14711 <sem_wait>
   1408b:	83 c4 10             	add    $0x10,%esp
            int err=tty_fifo_put(&tty->ofifo,'\r');
   1408e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14091:	05 00 04 00 00       	add    $0x400,%eax
   14096:	83 ec 08             	sub    $0x8,%esp
   14099:	6a 0d                	push   $0xd
   1409b:	50                   	push   %eax
   1409c:	e8 b3 fd ff ff       	call   13e54 <tty_fifo_put>
   140a1:	83 c4 10             	add    $0x10,%esp
   140a4:	89 45 e8             	mov    %eax,-0x18(%ebp)
            if (err<0){
   140a7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   140ab:	78 59                	js     14106 <tty_write+0xf4>
                break;
            }
        }

        sem_wait(&tty->osem);
   140ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
   140b0:	05 2c 04 00 00       	add    $0x42c,%eax
   140b5:	83 ec 0c             	sub    $0xc,%esp
   140b8:	50                   	push   %eax
   140b9:	e8 53 06 00 00       	call   14711 <sem_wait>
   140be:	83 c4 10             	add    $0x10,%esp
        int err=tty_fifo_put(&tty->ofifo,c);
   140c1:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
   140c5:	8b 55 f0             	mov    -0x10(%ebp),%edx
   140c8:	81 c2 00 04 00 00    	add    $0x400,%edx
   140ce:	83 ec 08             	sub    $0x8,%esp
   140d1:	50                   	push   %eax
   140d2:	52                   	push   %edx
   140d3:	e8 7c fd ff ff       	call   13e54 <tty_fifo_put>
   140d8:	83 c4 10             	add    $0x10,%esp
   140db:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (err<0){
   140de:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   140e2:	78 25                	js     14109 <tty_write+0xf7>
            break;
        }
        len++;
   140e4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
        size--;
   140e8:	83 6d 14 01          	subl   $0x1,0x14(%ebp)

        console_write(tty);
   140ec:	83 ec 0c             	sub    $0xc,%esp
   140ef:	ff 75 f0             	pushl  -0x10(%ebp)
   140f2:	e8 c7 f4 ff ff       	call   135be <console_write>
   140f7:	83 c4 10             	add    $0x10,%esp
    while(size){
   140fa:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   140fe:	0f 85 51 ff ff ff    	jne    14055 <tty_write+0x43>
   14104:	eb 04                	jmp    1410a <tty_write+0xf8>
                break;
   14106:	90                   	nop
   14107:	eb 01                	jmp    1410a <tty_write+0xf8>
            break;
   14109:	90                   	nop
    }

    return len;
   1410a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1410d:	c9                   	leave  
   1410e:	c3                   	ret    

0001410f <tty_control>:

int tty_control(device_t*dev,int cmd,int arg0,int arg1){
   1410f:	55                   	push   %ebp
   14110:	89 e5                	mov    %esp,%ebp
    return 0;
   14112:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14117:	5d                   	pop    %ebp
   14118:	c3                   	ret    

00014119 <tty_close>:

void tty_close(device_t* dev){
   14119:	55                   	push   %ebp
   1411a:	89 e5                	mov    %esp,%ebp

}
   1411c:	90                   	nop
   1411d:	5d                   	pop    %ebp
   1411e:	c3                   	ret    

0001411f <file_alloc>:
#include "ipc/mutex.h"

static file_t file_table[FILE_TABLE_SIZE]; // 文件表
static mutex_t file_alloc_mutex; // 文件表的互斥锁

file_t* file_alloc(void){
   1411f:	55                   	push   %ebp
   14120:	89 e5                	mov    %esp,%ebp
   14122:	83 ec 18             	sub    $0x18,%esp
    file_t* file=(file_t*)0;
   14125:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    mutex_lock(&file_alloc_mutex);
   1412c:	83 ec 0c             	sub    $0xc,%esp
   1412f:	68 c0 02 05 00       	push   $0x502c0
   14134:	e8 5c 04 00 00       	call   14595 <mutex_lock>
   14139:	83 c4 10             	add    $0x10,%esp

    for(int i=0;i<FILE_TABLE_SIZE;i++){
   1413c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   14143:	eb 40                	jmp    14185 <file_alloc+0x66>
       file_t* p_file=file_table+i;
   14145:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14148:	6b c0 38             	imul   $0x38,%eax,%eax
   1414b:	05 c0 42 03 00       	add    $0x342c0,%eax
   14150:	89 45 ec             	mov    %eax,-0x14(%ebp)
       if(p_file->ref==0){
   14153:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14156:	8b 40 28             	mov    0x28(%eax),%eax
   14159:	85 c0                	test   %eax,%eax
   1415b:	75 24                	jne    14181 <file_alloc+0x62>
           kernel_memset(p_file,0,sizeof(file_t));
   1415d:	83 ec 04             	sub    $0x4,%esp
   14160:	6a 38                	push   $0x38
   14162:	6a 00                	push   $0x0
   14164:	ff 75 ec             	pushl  -0x14(%ebp)
   14167:	e8 f3 0a 00 00       	call   14c5f <kernel_memset>
   1416c:	83 c4 10             	add    $0x10,%esp
           p_file->ref=1;
   1416f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14172:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
           file=p_file;
   14179:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1417c:	89 45 f4             	mov    %eax,-0xc(%ebp)
           break;
   1417f:	eb 0d                	jmp    1418e <file_alloc+0x6f>
    for(int i=0;i<FILE_TABLE_SIZE;i++){
   14181:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14185:	81 7d f0 ff 07 00 00 	cmpl   $0x7ff,-0x10(%ebp)
   1418c:	7e b7                	jle    14145 <file_alloc+0x26>
       }
    }

    mutex_unlock(&file_alloc_mutex);
   1418e:	83 ec 0c             	sub    $0xc,%esp
   14191:	68 c0 02 05 00       	push   $0x502c0
   14196:	e8 89 04 00 00       	call   14624 <mutex_unlock>
   1419b:	83 c4 10             	add    $0x10,%esp
    return file;
   1419e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   141a1:	c9                   	leave  
   141a2:	c3                   	ret    

000141a3 <file_free>:

void file_free(file_t* file){
   141a3:	55                   	push   %ebp
   141a4:	89 e5                	mov    %esp,%ebp
   141a6:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&file_alloc_mutex);
   141a9:	83 ec 0c             	sub    $0xc,%esp
   141ac:	68 c0 02 05 00       	push   $0x502c0
   141b1:	e8 df 03 00 00       	call   14595 <mutex_lock>
   141b6:	83 c4 10             	add    $0x10,%esp

    if(file->ref){
   141b9:	8b 45 08             	mov    0x8(%ebp),%eax
   141bc:	8b 40 28             	mov    0x28(%eax),%eax
   141bf:	85 c0                	test   %eax,%eax
   141c1:	74 0f                	je     141d2 <file_free+0x2f>
        file->ref--;
   141c3:	8b 45 08             	mov    0x8(%ebp),%eax
   141c6:	8b 40 28             	mov    0x28(%eax),%eax
   141c9:	8d 50 ff             	lea    -0x1(%eax),%edx
   141cc:	8b 45 08             	mov    0x8(%ebp),%eax
   141cf:	89 50 28             	mov    %edx,0x28(%eax)
    }
    
    mutex_unlock(&file_alloc_mutex);
   141d2:	83 ec 0c             	sub    $0xc,%esp
   141d5:	68 c0 02 05 00       	push   $0x502c0
   141da:	e8 45 04 00 00       	call   14624 <mutex_unlock>
   141df:	83 c4 10             	add    $0x10,%esp
}
   141e2:	90                   	nop
   141e3:	c9                   	leave  
   141e4:	c3                   	ret    

000141e5 <file_table_init>:

void file_table_init(void){
   141e5:	55                   	push   %ebp
   141e6:	89 e5                	mov    %esp,%ebp
   141e8:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&file_alloc_mutex);
   141eb:	83 ec 0c             	sub    $0xc,%esp
   141ee:	68 c0 02 05 00       	push   $0x502c0
   141f3:	e8 6f 03 00 00       	call   14567 <mutex_init>
   141f8:	83 c4 10             	add    $0x10,%esp
    kernel_memset(file_table,0,sizeof(file_table));
   141fb:	83 ec 04             	sub    $0x4,%esp
   141fe:	68 00 c0 01 00       	push   $0x1c000
   14203:	6a 00                	push   $0x0
   14205:	68 c0 42 03 00       	push   $0x342c0
   1420a:	e8 50 0a 00 00       	call   14c5f <kernel_memset>
   1420f:	83 c4 10             	add    $0x10,%esp
   14212:	90                   	nop
   14213:	c9                   	leave  
   14214:	c3                   	ret    

00014215 <inb>:
static inline uint8_t inb(uint16_t port){
   14215:	55                   	push   %ebp
   14216:	89 e5                	mov    %esp,%ebp
   14218:	83 ec 14             	sub    $0x14,%esp
   1421b:	8b 45 08             	mov    0x8(%ebp),%eax
   1421e:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__(
   14222:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   14226:	89 c2                	mov    %eax,%edx
   14228:	ec                   	in     (%dx),%al
   14229:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   1422c:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   14230:	c9                   	leave  
   14231:	c3                   	ret    

00014232 <inw>:
static inline uint16_t inw(uint16_t port){
   14232:	55                   	push   %ebp
   14233:	89 e5                	mov    %esp,%ebp
   14235:	83 ec 14             	sub    $0x14,%esp
   14238:	8b 45 08             	mov    0x8(%ebp),%eax
   1423b:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__(
   1423f:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   14243:	89 c2                	mov    %eax,%edx
   14245:	66 ed                	in     (%dx),%ax
   14247:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    return rv;
   1424b:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
}
   1424f:	c9                   	leave  
   14250:	c3                   	ret    

00014251 <outb>:
static inline void outb(uint16_t port,uint8_t data){
   14251:	55                   	push   %ebp
   14252:	89 e5                	mov    %esp,%ebp
   14254:	83 ec 08             	sub    $0x8,%esp
   14257:	8b 55 08             	mov    0x8(%ebp),%edx
   1425a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1425d:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   14261:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile(
   14264:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   14268:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   1426c:	ee                   	out    %al,(%dx)
}
   1426d:	90                   	nop
   1426e:	c9                   	leave  
   1426f:	c3                   	ret    

00014270 <read_disk>:
#define TEMP_FILE_ID        100

static uint8_t TEMP_ADDR[100*1024];
static uint8_t* temp_pos;

static void read_disk(int sector, int sector_count, uint8_t * buf) {
   14270:	55                   	push   %ebp
   14271:	89 e5                	mov    %esp,%ebp
   14273:	53                   	push   %ebx
   14274:	83 ec 10             	sub    $0x10,%esp
    outb(0x1F6, (uint8_t) (0xE0));
   14277:	68 e0 00 00 00       	push   $0xe0
   1427c:	68 f6 01 00 00       	push   $0x1f6
   14281:	e8 cb ff ff ff       	call   14251 <outb>
   14286:	83 c4 08             	add    $0x8,%esp

	outb(0x1F2, (uint8_t) (sector_count >> 8));
   14289:	8b 45 0c             	mov    0xc(%ebp),%eax
   1428c:	c1 f8 08             	sar    $0x8,%eax
   1428f:	0f b6 c0             	movzbl %al,%eax
   14292:	50                   	push   %eax
   14293:	68 f2 01 00 00       	push   $0x1f2
   14298:	e8 b4 ff ff ff       	call   14251 <outb>
   1429d:	83 c4 08             	add    $0x8,%esp
    outb(0x1F3, (uint8_t) (sector >> 24));		
   142a0:	8b 45 08             	mov    0x8(%ebp),%eax
   142a3:	c1 f8 18             	sar    $0x18,%eax
   142a6:	0f b6 c0             	movzbl %al,%eax
   142a9:	50                   	push   %eax
   142aa:	68 f3 01 00 00       	push   $0x1f3
   142af:	e8 9d ff ff ff       	call   14251 <outb>
   142b4:	83 c4 08             	add    $0x8,%esp
    outb(0x1F4, (uint8_t) (0));					
   142b7:	6a 00                	push   $0x0
   142b9:	68 f4 01 00 00       	push   $0x1f4
   142be:	e8 8e ff ff ff       	call   14251 <outb>
   142c3:	83 c4 08             	add    $0x8,%esp
    outb(0x1F5, (uint8_t) (0));					
   142c6:	6a 00                	push   $0x0
   142c8:	68 f5 01 00 00       	push   $0x1f5
   142cd:	e8 7f ff ff ff       	call   14251 <outb>
   142d2:	83 c4 08             	add    $0x8,%esp

    outb(0x1F2, (uint8_t) (sector_count));
   142d5:	8b 45 0c             	mov    0xc(%ebp),%eax
   142d8:	0f b6 c0             	movzbl %al,%eax
   142db:	50                   	push   %eax
   142dc:	68 f2 01 00 00       	push   $0x1f2
   142e1:	e8 6b ff ff ff       	call   14251 <outb>
   142e6:	83 c4 08             	add    $0x8,%esp
	outb(0x1F3, (uint8_t) (sector));			
   142e9:	8b 45 08             	mov    0x8(%ebp),%eax
   142ec:	0f b6 c0             	movzbl %al,%eax
   142ef:	50                   	push   %eax
   142f0:	68 f3 01 00 00       	push   $0x1f3
   142f5:	e8 57 ff ff ff       	call   14251 <outb>
   142fa:	83 c4 08             	add    $0x8,%esp
	outb(0x1F4, (uint8_t) (sector >> 8));		
   142fd:	8b 45 08             	mov    0x8(%ebp),%eax
   14300:	c1 f8 08             	sar    $0x8,%eax
   14303:	0f b6 c0             	movzbl %al,%eax
   14306:	50                   	push   %eax
   14307:	68 f4 01 00 00       	push   $0x1f4
   1430c:	e8 40 ff ff ff       	call   14251 <outb>
   14311:	83 c4 08             	add    $0x8,%esp
	outb(0x1F5, (uint8_t) (sector >> 16));		
   14314:	8b 45 08             	mov    0x8(%ebp),%eax
   14317:	c1 f8 10             	sar    $0x10,%eax
   1431a:	0f b6 c0             	movzbl %al,%eax
   1431d:	50                   	push   %eax
   1431e:	68 f5 01 00 00       	push   $0x1f5
   14323:	e8 29 ff ff ff       	call   14251 <outb>
   14328:	83 c4 08             	add    $0x8,%esp

	outb(0x1F7, (uint8_t) 0x24);
   1432b:	6a 24                	push   $0x24
   1432d:	68 f7 01 00 00       	push   $0x1f7
   14332:	e8 1a ff ff ff       	call   14251 <outb>
   14337:	83 c4 08             	add    $0x8,%esp

	
	uint16_t *data_buf = (uint16_t*) buf;
   1433a:	8b 45 10             	mov    0x10(%ebp),%eax
   1433d:	89 45 f8             	mov    %eax,-0x8(%ebp)
	// 这里是要读取的扇区
	while (sector_count-- > 0) {
   14340:	eb 4a                	jmp    1438c <read_disk+0x11c>
		
		while ((inb(0x1F7) & 0x88) != 0x8) {}
   14342:	90                   	nop
   14343:	68 f7 01 00 00       	push   $0x1f7
   14348:	e8 c8 fe ff ff       	call   14215 <inb>
   1434d:	83 c4 04             	add    $0x4,%esp
   14350:	0f b6 c0             	movzbl %al,%eax
   14353:	25 88 00 00 00       	and    $0x88,%eax
   14358:	83 f8 08             	cmp    $0x8,%eax
   1435b:	75 e6                	jne    14343 <read_disk+0xd3>

		// 以每次2字节方式读取每个扇区
		for (int i = 0; i < SECTOR_SIZE / 2; i++) {
   1435d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14364:	eb 1d                	jmp    14383 <read_disk+0x113>
			*data_buf++ = inw(0x1F0);
   14366:	8b 5d f8             	mov    -0x8(%ebp),%ebx
   14369:	8d 43 02             	lea    0x2(%ebx),%eax
   1436c:	89 45 f8             	mov    %eax,-0x8(%ebp)
   1436f:	68 f0 01 00 00       	push   $0x1f0
   14374:	e8 b9 fe ff ff       	call   14232 <inw>
   14379:	83 c4 04             	add    $0x4,%esp
   1437c:	66 89 03             	mov    %ax,(%ebx)
		for (int i = 0; i < SECTOR_SIZE / 2; i++) {
   1437f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14383:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   1438a:	7e da                	jle    14366 <read_disk+0xf6>
	while (sector_count-- > 0) {
   1438c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1438f:	8d 50 ff             	lea    -0x1(%eax),%edx
   14392:	89 55 0c             	mov    %edx,0xc(%ebp)
   14395:	85 c0                	test   %eax,%eax
   14397:	7f a9                	jg     14342 <read_disk+0xd2>
		}
	}
}
   14399:	90                   	nop
   1439a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1439d:	c9                   	leave  
   1439e:	c3                   	ret    

0001439f <sys_open>:

int sys_open(const char* name,int flags,...){
   1439f:	55                   	push   %ebp
   143a0:	89 e5                	mov    %esp,%ebp
    if(name[0]=='/'){
   143a2:	8b 45 08             	mov    0x8(%ebp),%eax
   143a5:	0f b6 00             	movzbl (%eax),%eax
   143a8:	3c 2f                	cmp    $0x2f,%al
   143aa:	75 25                	jne    143d1 <sys_open+0x32>

        read_disk(5000,80,(uint8_t*)TEMP_ADDR);
   143ac:	68 e0 02 05 00       	push   $0x502e0
   143b1:	6a 50                	push   $0x50
   143b3:	68 88 13 00 00       	push   $0x1388
   143b8:	e8 b3 fe ff ff       	call   14270 <read_disk>
   143bd:	83 c4 0c             	add    $0xc,%esp
        temp_pos=(uint8_t*)TEMP_ADDR;
   143c0:	c7 05 e0 92 06 00 e0 	movl   $0x502e0,0x692e0
   143c7:	02 05 00 

        return TEMP_FILE_ID;
   143ca:	b8 64 00 00 00       	mov    $0x64,%eax
   143cf:	eb 05                	jmp    143d6 <sys_open+0x37>
    }

    return -1;
   143d1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   143d6:	c9                   	leave  
   143d7:	c3                   	ret    

000143d8 <sys_read>:

int sys_read(int file,char* ptr,int len){
   143d8:	55                   	push   %ebp
   143d9:	89 e5                	mov    %esp,%ebp
   143db:	83 ec 08             	sub    $0x8,%esp
   if(file==TEMP_FILE_ID){
   143de:	83 7d 08 64          	cmpl   $0x64,0x8(%ebp)
   143e2:	75 2d                	jne    14411 <sys_read+0x39>
        kernel_memcpy(ptr,temp_pos,len);
   143e4:	8b 55 10             	mov    0x10(%ebp),%edx
   143e7:	a1 e0 92 06 00       	mov    0x692e0,%eax
   143ec:	83 ec 04             	sub    $0x4,%esp
   143ef:	52                   	push   %edx
   143f0:	50                   	push   %eax
   143f1:	ff 75 0c             	pushl  0xc(%ebp)
   143f4:	e8 17 08 00 00       	call   14c10 <kernel_memcpy>
   143f9:	83 c4 10             	add    $0x10,%esp
        temp_pos+=len;
   143fc:	8b 15 e0 92 06 00    	mov    0x692e0,%edx
   14402:	8b 45 10             	mov    0x10(%ebp),%eax
   14405:	01 d0                	add    %edx,%eax
   14407:	a3 e0 92 06 00       	mov    %eax,0x692e0

        return len;
   1440c:	8b 45 10             	mov    0x10(%ebp),%eax
   1440f:	eb 05                	jmp    14416 <sys_read+0x3e>
   }
   
   return -1;
   14411:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   14416:	c9                   	leave  
   14417:	c3                   	ret    

00014418 <sys_write>:

int sys_write(int file,char* ptr,int len){
   14418:	55                   	push   %ebp
   14419:	89 e5                	mov    %esp,%ebp
   1441b:	83 ec 08             	sub    $0x8,%esp
   if(file==1){
   1441e:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
   14422:	75 1e                	jne    14442 <sys_write+0x2a>
        ptr[len]='\0';
   14424:	8b 55 10             	mov    0x10(%ebp),%edx
   14427:	8b 45 0c             	mov    0xc(%ebp),%eax
   1442a:	01 d0                	add    %edx,%eax
   1442c:	c6 00 00             	movb   $0x0,(%eax)
        log_printf("%s",ptr);
   1442f:	83 ec 08             	sub    $0x8,%esp
   14432:	ff 75 0c             	pushl  0xc(%ebp)
   14435:	68 db 5e 01 00       	push   $0x15edb
   1443a:	e8 43 0e 00 00       	call   15282 <log_printf>
   1443f:	83 c4 10             	add    $0x10,%esp
   }
    
    return len;
   14442:	8b 45 10             	mov    0x10(%ebp),%eax
}
   14445:	c9                   	leave  
   14446:	c3                   	ret    

00014447 <sys_lseek>:

int sys_lseek(int file,int ptr,int dir){
   14447:	55                   	push   %ebp
   14448:	89 e5                	mov    %esp,%ebp
    if(file==TEMP_FILE_ID){
   1444a:	83 7d 08 64          	cmpl   $0x64,0x8(%ebp)
   1444e:	75 14                	jne    14464 <sys_lseek+0x1d>

        temp_pos=(uint8_t*)(TEMP_ADDR+ptr);
   14450:	8b 45 0c             	mov    0xc(%ebp),%eax
   14453:	05 e0 02 05 00       	add    $0x502e0,%eax
   14458:	a3 e0 92 06 00       	mov    %eax,0x692e0
        return 0;
   1445d:	b8 00 00 00 00       	mov    $0x0,%eax
   14462:	eb 05                	jmp    14469 <sys_lseek+0x22>
    }

    return -1;
   14464:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}   
   14469:	5d                   	pop    %ebp
   1446a:	c3                   	ret    

0001446b <sys_close>:

int sys_close(int file){
   1446b:	55                   	push   %ebp
   1446c:	89 e5                	mov    %esp,%ebp
    return 0;
   1446e:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14473:	5d                   	pop    %ebp
   14474:	c3                   	ret    

00014475 <sys_isatty>:

int sys_isatty(int file){
   14475:	55                   	push   %ebp
   14476:	89 e5                	mov    %esp,%ebp
    return -1;
   14478:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   1447d:	5d                   	pop    %ebp
   1447e:	c3                   	ret    

0001447f <sys_fstat>:

int sys_fstat(int file,struct stat* st){
   1447f:	55                   	push   %ebp
   14480:	89 e5                	mov    %esp,%ebp
    return -1;
   14482:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   14487:	5d                   	pop    %ebp
   14488:	c3                   	ret    

00014489 <fs_init>:

void fs_init(void){
   14489:	55                   	push   %ebp
   1448a:	89 e5                	mov    %esp,%ebp
   1448c:	83 ec 08             	sub    $0x8,%esp
    file_table_init();
   1448f:	e8 51 fd ff ff       	call   141e5 <file_table_init>
   14494:	90                   	nop
   14495:	c9                   	leave  
   14496:	c3                   	ret    

00014497 <kernel_init>:
#include "ipc/sem.h"
#include "cpu/cpu.h"
#include "dev/kbd.h"
#include "fs/fs.h"

void kernel_init(boot_info_t* boot_info){
   14497:	55                   	push   %ebp
   14498:	89 e5                	mov    %esp,%ebp
   1449a:	83 ec 08             	sub    $0x8,%esp
    irq_init();
   1449d:	e8 b1 e0 ff ff       	call   12553 <irq_init>

    cpu_init();
   144a2:	e8 6f dd ff ff       	call   12216 <cpu_init>
    log_init();
   144a7:	e8 a7 0d 00 00       	call   15253 <log_init>

    memory_init(boot_info);
   144ac:	83 ec 0c             	sub    $0xc,%esp
   144af:	ff 75 08             	pushl  0x8(%ebp)
   144b2:	e8 6c c2 ff ff       	call   10723 <memory_init>
   144b7:	83 c4 10             	add    $0x10,%esp
    fs_init();
   144ba:	e8 ca ff ff ff       	call   14489 <fs_init>
    
    time_init();
   144bf:	e8 f2 f8 ff ff       	call   13db6 <time_init>

    task_manager_init();
   144c4:	e8 97 ce ff ff       	call   11360 <task_manager_init>

}
   144c9:	90                   	nop
   144ca:	c9                   	leave  
   144cb:	c3                   	ret    

000144cc <move_to_first_task>:

void move_to_first_task(void){
   144cc:	55                   	push   %ebp
   144cd:	89 e5                	mov    %esp,%ebp
   144cf:	56                   	push   %esi
   144d0:	53                   	push   %ebx
   144d1:	83 ec 10             	sub    $0x10,%esp
    task_t* curr=task_current();
   144d4:	e8 0c d1 ff ff       	call   115e5 <task_current>
   144d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    ASSERT(curr!=0);
   144dc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   144e0:	75 19                	jne    144fb <move_to_first_task+0x2f>
   144e2:	68 e0 5e 01 00       	push   $0x15ee0
   144e7:	68 34 5f 01 00       	push   $0x15f34
   144ec:	6a 23                	push   $0x23
   144ee:	68 e8 5e 01 00       	push   $0x15ee8
   144f3:	e8 ba 0a 00 00       	call   14fb2 <panic>
   144f8:	83 c4 10             	add    $0x10,%esp
    tss_t* tss=&(curr->tss);
   144fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   144fe:	05 58 02 00 00       	add    $0x258,%eax
   14503:	89 45 f0             	mov    %eax,-0x10(%ebp)
        "push %[eflags]\n\t"
        "push %[cs]\n\t"
        "push %[eip]\n\t"
        "iret"
        :
        :[ss]"r"(tss->ss),[esp]"r"(tss->esp),[eflags]"r"(tss->eflags),[cs]"r"(tss->cs),
   14506:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14509:	8b 40 50             	mov    0x50(%eax),%eax
   1450c:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1450f:	8b 52 38             	mov    0x38(%edx),%edx
   14512:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   14515:	8b 49 24             	mov    0x24(%ecx),%ecx
   14518:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   1451b:	8b 5b 4c             	mov    0x4c(%ebx),%ebx
         [eip]"r"(tss->eip)
   1451e:	8b 75 f0             	mov    -0x10(%ebp),%esi
   14521:	8b 76 20             	mov    0x20(%esi),%esi
    __asm__ __volatile__(
   14524:	50                   	push   %eax
   14525:	52                   	push   %edx
   14526:	51                   	push   %ecx
   14527:	53                   	push   %ebx
   14528:	56                   	push   %esi
   14529:	cf                   	iret   
    );
}
   1452a:	90                   	nop
   1452b:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1452e:	5b                   	pop    %ebx
   1452f:	5e                   	pop    %esi
   14530:	5d                   	pop    %ebp
   14531:	c3                   	ret    

00014532 <init_main>:

void init_main(){
   14532:	55                   	push   %ebp
   14533:	89 e5                	mov    %esp,%ebp
   14535:	83 ec 18             	sub    $0x18,%esp
    int count=0;
   14538:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    log_printf("Kernel is running....");
   1453f:	83 ec 0c             	sub    $0xc,%esp
   14542:	68 1b 5f 01 00       	push   $0x15f1b
   14547:	e8 36 0d 00 00       	call   15282 <log_printf>
   1454c:	83 c4 10             	add    $0x10,%esp
    task_first_init();
   1454f:	e8 f3 ce ff ff       	call   11447 <task_first_init>
    move_to_first_task();
   14554:	e8 73 ff ff ff       	call   144cc <move_to_first_task>
}
   14559:	90                   	nop
   1455a:	c9                   	leave  
   1455b:	c3                   	ret    

0001455c <list_count>:
static inline int list_count(list_t* list){
   1455c:	55                   	push   %ebp
   1455d:	89 e5                	mov    %esp,%ebp
    return list->count;
   1455f:	8b 45 08             	mov    0x8(%ebp),%eax
   14562:	8b 40 08             	mov    0x8(%eax),%eax
}
   14565:	5d                   	pop    %ebp
   14566:	c3                   	ret    

00014567 <mutex_init>:
#include "ipc/mutex.h"

void mutex_init(mutex_t* mutex){
   14567:	55                   	push   %ebp
   14568:	89 e5                	mov    %esp,%ebp
   1456a:	83 ec 08             	sub    $0x8,%esp
    mutex->locked_count=0;
   1456d:	8b 45 08             	mov    0x8(%ebp),%eax
   14570:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    mutex->owner=(task_t*)0;
   14577:	8b 45 08             	mov    0x8(%ebp),%eax
   1457a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    list_init(&mutex->wait_list); 
   14580:	8b 45 08             	mov    0x8(%ebp),%eax
   14583:	83 c0 08             	add    $0x8,%eax
   14586:	83 ec 0c             	sub    $0xc,%esp
   14589:	50                   	push   %eax
   1458a:	e8 df 0a 00 00       	call   1506e <list_init>
   1458f:	83 c4 10             	add    $0x10,%esp
}
   14592:	90                   	nop
   14593:	c9                   	leave  
   14594:	c3                   	ret    

00014595 <mutex_lock>:

void mutex_lock(mutex_t* mutex){
   14595:	55                   	push   %ebp
   14596:	89 e5                	mov    %esp,%ebp
   14598:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   1459b:	e8 7e e6 ff ff       	call   12c1e <irq_enter_protection>
   145a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t* curr=task_current();
   145a3:	e8 3d d0 ff ff       	call   115e5 <task_current>
   145a8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(mutex->locked_count==0){
   145ab:	8b 45 08             	mov    0x8(%ebp),%eax
   145ae:	8b 40 04             	mov    0x4(%eax),%eax
   145b1:	85 c0                	test   %eax,%eax
   145b3:	75 14                	jne    145c9 <mutex_lock+0x34>
        mutex->locked_count=1;
   145b5:	8b 45 08             	mov    0x8(%ebp),%eax
   145b8:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
        mutex->owner=curr;
   145bf:	8b 45 08             	mov    0x8(%ebp),%eax
   145c2:	8b 55 f0             	mov    -0x10(%ebp),%edx
   145c5:	89 10                	mov    %edx,(%eax)
   145c7:	eb 4a                	jmp    14613 <mutex_lock+0x7e>
    }
    else if(mutex->owner==curr){
   145c9:	8b 45 08             	mov    0x8(%ebp),%eax
   145cc:	8b 00                	mov    (%eax),%eax
   145ce:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   145d1:	75 11                	jne    145e4 <mutex_lock+0x4f>
        mutex->locked_count++;
   145d3:	8b 45 08             	mov    0x8(%ebp),%eax
   145d6:	8b 40 04             	mov    0x4(%eax),%eax
   145d9:	8d 50 01             	lea    0x1(%eax),%edx
   145dc:	8b 45 08             	mov    0x8(%ebp),%eax
   145df:	89 50 04             	mov    %edx,0x4(%eax)
   145e2:	eb 2f                	jmp    14613 <mutex_lock+0x7e>
    }
    else{
        task_set_block(curr);
   145e4:	83 ec 0c             	sub    $0xc,%esp
   145e7:	ff 75 f0             	pushl  -0x10(%ebp)
   145ea:	e8 84 cf ff ff       	call   11573 <task_set_block>
   145ef:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&mutex->wait_list,&curr->wait_node);
   145f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   145f5:	8d 90 50 02 00 00    	lea    0x250(%eax),%edx
   145fb:	8b 45 08             	mov    0x8(%ebp),%eax
   145fe:	83 c0 08             	add    $0x8,%eax
   14601:	83 ec 08             	sub    $0x8,%esp
   14604:	52                   	push   %edx
   14605:	50                   	push   %eax
   14606:	e8 e7 0a 00 00       	call   150f2 <list_insert_last>
   1460b:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   1460e:	e8 3d d0 ff ff       	call   11650 <task_dispatch>
    }
    irq_leave_protection(state);
   14613:	83 ec 0c             	sub    $0xc,%esp
   14616:	ff 75 f4             	pushl  -0xc(%ebp)
   14619:	e8 18 e6 ff ff       	call   12c36 <irq_leave_protection>
   1461e:	83 c4 10             	add    $0x10,%esp
}
   14621:	90                   	nop
   14622:	c9                   	leave  
   14623:	c3                   	ret    

00014624 <mutex_unlock>:

void mutex_unlock(mutex_t* mutex){
   14624:	55                   	push   %ebp
   14625:	89 e5                	mov    %esp,%ebp
   14627:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   1462a:	e8 ef e5 ff ff       	call   12c1e <irq_enter_protection>
   1462f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t* curr=task_current();
   14632:	e8 ae cf ff ff       	call   115e5 <task_current>
   14637:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(mutex->owner==curr){
   1463a:	8b 45 08             	mov    0x8(%ebp),%eax
   1463d:	8b 00                	mov    (%eax),%eax
   1463f:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   14642:	0f 85 8a 00 00 00    	jne    146d2 <mutex_unlock+0xae>
        if(--mutex->locked_count==0){
   14648:	8b 45 08             	mov    0x8(%ebp),%eax
   1464b:	8b 40 04             	mov    0x4(%eax),%eax
   1464e:	8d 50 ff             	lea    -0x1(%eax),%edx
   14651:	8b 45 08             	mov    0x8(%ebp),%eax
   14654:	89 50 04             	mov    %edx,0x4(%eax)
   14657:	8b 45 08             	mov    0x8(%ebp),%eax
   1465a:	8b 40 04             	mov    0x4(%eax),%eax
   1465d:	85 c0                	test   %eax,%eax
   1465f:	75 71                	jne    146d2 <mutex_unlock+0xae>
            mutex->owner=(task_t*)0;
   14661:	8b 45 08             	mov    0x8(%ebp),%eax
   14664:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
            if(list_count(&mutex->wait_list)){
   1466a:	8b 45 08             	mov    0x8(%ebp),%eax
   1466d:	83 c0 08             	add    $0x8,%eax
   14670:	83 ec 0c             	sub    $0xc,%esp
   14673:	50                   	push   %eax
   14674:	e8 e3 fe ff ff       	call   1455c <list_count>
   14679:	83 c4 10             	add    $0x10,%esp
   1467c:	85 c0                	test   %eax,%eax
   1467e:	74 52                	je     146d2 <mutex_unlock+0xae>
                list_node_t* node=list_remove_first(&mutex->wait_list);
   14680:	8b 45 08             	mov    0x8(%ebp),%eax
   14683:	83 c0 08             	add    $0x8,%eax
   14686:	83 ec 0c             	sub    $0xc,%esp
   14689:	50                   	push   %eax
   1468a:	e8 c7 0a 00 00       	call   15156 <list_remove_first>
   1468f:	83 c4 10             	add    $0x10,%esp
   14692:	89 45 ec             	mov    %eax,-0x14(%ebp)
                task_t* task=list_node_parent(node,task_t,wait_node);
   14695:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   14699:	74 0a                	je     146a5 <mutex_unlock+0x81>
   1469b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1469e:	2d 50 02 00 00       	sub    $0x250,%eax
   146a3:	eb 05                	jmp    146aa <mutex_unlock+0x86>
   146a5:	b8 00 00 00 00       	mov    $0x0,%eax
   146aa:	89 45 e8             	mov    %eax,-0x18(%ebp)
                task_set_ready(task);
   146ad:	83 ec 0c             	sub    $0xc,%esp
   146b0:	ff 75 e8             	pushl  -0x18(%ebp)
   146b3:	e8 85 ce ff ff       	call   1153d <task_set_ready>
   146b8:	83 c4 10             	add    $0x10,%esp
                mutex->locked_count=1;
   146bb:	8b 45 08             	mov    0x8(%ebp),%eax
   146be:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
                mutex->owner=task;
   146c5:	8b 45 08             	mov    0x8(%ebp),%eax
   146c8:	8b 55 e8             	mov    -0x18(%ebp),%edx
   146cb:	89 10                	mov    %edx,(%eax)
                task_dispatch();
   146cd:	e8 7e cf ff ff       	call   11650 <task_dispatch>
            }
        }
    }
    irq_leave_protection(state);
   146d2:	83 ec 0c             	sub    $0xc,%esp
   146d5:	ff 75 f4             	pushl  -0xc(%ebp)
   146d8:	e8 59 e5 ff ff       	call   12c36 <irq_leave_protection>
   146dd:	83 c4 10             	add    $0x10,%esp
   146e0:	90                   	nop
   146e1:	c9                   	leave  
   146e2:	c3                   	ret    

000146e3 <list_count>:
static inline int list_count(list_t* list){
   146e3:	55                   	push   %ebp
   146e4:	89 e5                	mov    %esp,%ebp
    return list->count;
   146e6:	8b 45 08             	mov    0x8(%ebp),%eax
   146e9:	8b 40 08             	mov    0x8(%eax),%eax
}
   146ec:	5d                   	pop    %ebp
   146ed:	c3                   	ret    

000146ee <sem_init>:
#include "ipc/sem.h"

void sem_init(sem_t* sem,int init_count){
   146ee:	55                   	push   %ebp
   146ef:	89 e5                	mov    %esp,%ebp
   146f1:	83 ec 08             	sub    $0x8,%esp
    sem->count=init_count;
   146f4:	8b 45 08             	mov    0x8(%ebp),%eax
   146f7:	8b 55 0c             	mov    0xc(%ebp),%edx
   146fa:	89 10                	mov    %edx,(%eax)
    list_init(&sem->wait_list);
   146fc:	8b 45 08             	mov    0x8(%ebp),%eax
   146ff:	83 c0 04             	add    $0x4,%eax
   14702:	83 ec 0c             	sub    $0xc,%esp
   14705:	50                   	push   %eax
   14706:	e8 63 09 00 00       	call   1506e <list_init>
   1470b:	83 c4 10             	add    $0x10,%esp
}
   1470e:	90                   	nop
   1470f:	c9                   	leave  
   14710:	c3                   	ret    

00014711 <sem_wait>:

void sem_wait(sem_t* sem){
   14711:	55                   	push   %ebp
   14712:	89 e5                	mov    %esp,%ebp
   14714:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   14717:	e8 02 e5 ff ff       	call   12c1e <irq_enter_protection>
   1471c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(sem->count>0){
   1471f:	8b 45 08             	mov    0x8(%ebp),%eax
   14722:	8b 00                	mov    (%eax),%eax
   14724:	85 c0                	test   %eax,%eax
   14726:	7e 0f                	jle    14737 <sem_wait+0x26>
        sem->count--;
   14728:	8b 45 08             	mov    0x8(%ebp),%eax
   1472b:	8b 00                	mov    (%eax),%eax
   1472d:	8d 50 ff             	lea    -0x1(%eax),%edx
   14730:	8b 45 08             	mov    0x8(%ebp),%eax
   14733:	89 10                	mov    %edx,(%eax)
   14735:	eb 37                	jmp    1476e <sem_wait+0x5d>
    }
    else{
        task_t* curr=task_current();
   14737:	e8 a9 ce ff ff       	call   115e5 <task_current>
   1473c:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_set_block(curr);
   1473f:	83 ec 0c             	sub    $0xc,%esp
   14742:	ff 75 f0             	pushl  -0x10(%ebp)
   14745:	e8 29 ce ff ff       	call   11573 <task_set_block>
   1474a:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&sem->wait_list,&curr->wait_node);
   1474d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14750:	8d 90 50 02 00 00    	lea    0x250(%eax),%edx
   14756:	8b 45 08             	mov    0x8(%ebp),%eax
   14759:	83 c0 04             	add    $0x4,%eax
   1475c:	83 ec 08             	sub    $0x8,%esp
   1475f:	52                   	push   %edx
   14760:	50                   	push   %eax
   14761:	e8 8c 09 00 00       	call   150f2 <list_insert_last>
   14766:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   14769:	e8 e2 ce ff ff       	call   11650 <task_dispatch>
    }
    irq_leave_protection(state);
   1476e:	83 ec 0c             	sub    $0xc,%esp
   14771:	ff 75 f4             	pushl  -0xc(%ebp)
   14774:	e8 bd e4 ff ff       	call   12c36 <irq_leave_protection>
   14779:	83 c4 10             	add    $0x10,%esp
}
   1477c:	90                   	nop
   1477d:	c9                   	leave  
   1477e:	c3                   	ret    

0001477f <sem_notify>:

void sem_notify(sem_t* sem){
   1477f:	55                   	push   %ebp
   14780:	89 e5                	mov    %esp,%ebp
   14782:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   14785:	e8 94 e4 ff ff       	call   12c1e <irq_enter_protection>
   1478a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(list_count(&sem->wait_list)){
   1478d:	8b 45 08             	mov    0x8(%ebp),%eax
   14790:	83 c0 04             	add    $0x4,%eax
   14793:	83 ec 0c             	sub    $0xc,%esp
   14796:	50                   	push   %eax
   14797:	e8 47 ff ff ff       	call   146e3 <list_count>
   1479c:	83 c4 10             	add    $0x10,%esp
   1479f:	85 c0                	test   %eax,%eax
   147a1:	74 42                	je     147e5 <sem_notify+0x66>
        list_node_t* node=list_remove_first(&sem->wait_list);
   147a3:	8b 45 08             	mov    0x8(%ebp),%eax
   147a6:	83 c0 04             	add    $0x4,%eax
   147a9:	83 ec 0c             	sub    $0xc,%esp
   147ac:	50                   	push   %eax
   147ad:	e8 a4 09 00 00       	call   15156 <list_remove_first>
   147b2:	83 c4 10             	add    $0x10,%esp
   147b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_t* task=list_node_parent(node,task_t,wait_node);
   147b8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   147bc:	74 0a                	je     147c8 <sem_notify+0x49>
   147be:	8b 45 f0             	mov    -0x10(%ebp),%eax
   147c1:	2d 50 02 00 00       	sub    $0x250,%eax
   147c6:	eb 05                	jmp    147cd <sem_notify+0x4e>
   147c8:	b8 00 00 00 00       	mov    $0x0,%eax
   147cd:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_set_ready(task);
   147d0:	83 ec 0c             	sub    $0xc,%esp
   147d3:	ff 75 ec             	pushl  -0x14(%ebp)
   147d6:	e8 62 cd ff ff       	call   1153d <task_set_ready>
   147db:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   147de:	e8 6d ce ff ff       	call   11650 <task_dispatch>
   147e3:	eb 0d                	jmp    147f2 <sem_notify+0x73>
    }
    else{
        sem->count++;
   147e5:	8b 45 08             	mov    0x8(%ebp),%eax
   147e8:	8b 00                	mov    (%eax),%eax
   147ea:	8d 50 01             	lea    0x1(%eax),%edx
   147ed:	8b 45 08             	mov    0x8(%ebp),%eax
   147f0:	89 10                	mov    %edx,(%eax)
    }
    irq_leave_protection(state);
   147f2:	83 ec 0c             	sub    $0xc,%esp
   147f5:	ff 75 f4             	pushl  -0xc(%ebp)
   147f8:	e8 39 e4 ff ff       	call   12c36 <irq_leave_protection>
   147fd:	83 c4 10             	add    $0x10,%esp
}
   14800:	90                   	nop
   14801:	c9                   	leave  
   14802:	c3                   	ret    

00014803 <sem_count>:

int sem_count(sem_t* sem){
   14803:	55                   	push   %ebp
   14804:	89 e5                	mov    %esp,%ebp
   14806:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   14809:	e8 10 e4 ff ff       	call   12c1e <irq_enter_protection>
   1480e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int count=sem->count;
   14811:	8b 45 08             	mov    0x8(%ebp),%eax
   14814:	8b 00                	mov    (%eax),%eax
   14816:	89 45 f0             	mov    %eax,-0x10(%ebp)
    irq_leave_protection(state);
   14819:	83 ec 0c             	sub    $0xc,%esp
   1481c:	ff 75 f4             	pushl  -0xc(%ebp)
   1481f:	e8 12 e4 ff ff       	call   12c36 <irq_leave_protection>
   14824:	83 c4 10             	add    $0x10,%esp
    return count;
   14827:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1482a:	c9                   	leave  
   1482b:	c3                   	ret    

0001482c <bitmap_byte_count>:
#include "tools/bitmap.h"
#include "tools/klib.h"

int bitmap_byte_count(int bit_count){
   1482c:	55                   	push   %ebp
   1482d:	89 e5                	mov    %esp,%ebp
    return (bit_count+8-1)/8;
   1482f:	8b 45 08             	mov    0x8(%ebp),%eax
   14832:	83 c0 07             	add    $0x7,%eax
   14835:	8d 50 07             	lea    0x7(%eax),%edx
   14838:	85 c0                	test   %eax,%eax
   1483a:	0f 48 c2             	cmovs  %edx,%eax
   1483d:	c1 f8 03             	sar    $0x3,%eax
}
   14840:	5d                   	pop    %ebp
   14841:	c3                   	ret    

00014842 <bitmap_init>:

void bitmap_init(bitmap_t* bitmap,uint8_t* bits,int count,int init_bit){
   14842:	55                   	push   %ebp
   14843:	89 e5                	mov    %esp,%ebp
   14845:	83 ec 18             	sub    $0x18,%esp
    bitmap->bit_count=count;
   14848:	8b 45 08             	mov    0x8(%ebp),%eax
   1484b:	8b 55 10             	mov    0x10(%ebp),%edx
   1484e:	89 10                	mov    %edx,(%eax)
    bitmap->bits=bits;
   14850:	8b 45 08             	mov    0x8(%ebp),%eax
   14853:	8b 55 0c             	mov    0xc(%ebp),%edx
   14856:	89 50 04             	mov    %edx,0x4(%eax)
    int bytes=bitmap_byte_count(bitmap->bit_count);
   14859:	8b 45 08             	mov    0x8(%ebp),%eax
   1485c:	8b 00                	mov    (%eax),%eax
   1485e:	50                   	push   %eax
   1485f:	e8 c8 ff ff ff       	call   1482c <bitmap_byte_count>
   14864:	83 c4 04             	add    $0x4,%esp
   14867:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kernel_memset(bitmap->bits,init_bit? 0xFF : 0,bytes);
   1486a:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   1486e:	74 07                	je     14877 <bitmap_init+0x35>
   14870:	ba ff 00 00 00       	mov    $0xff,%edx
   14875:	eb 05                	jmp    1487c <bitmap_init+0x3a>
   14877:	ba 00 00 00 00       	mov    $0x0,%edx
   1487c:	8b 45 08             	mov    0x8(%ebp),%eax
   1487f:	8b 40 04             	mov    0x4(%eax),%eax
   14882:	83 ec 04             	sub    $0x4,%esp
   14885:	ff 75 f4             	pushl  -0xc(%ebp)
   14888:	52                   	push   %edx
   14889:	50                   	push   %eax
   1488a:	e8 d0 03 00 00       	call   14c5f <kernel_memset>
   1488f:	83 c4 10             	add    $0x10,%esp
}
   14892:	90                   	nop
   14893:	c9                   	leave  
   14894:	c3                   	ret    

00014895 <bitmap_get_bit>:

int bitmap_get_bit(bitmap_t* bitmap,int index){
   14895:	55                   	push   %ebp
   14896:	89 e5                	mov    %esp,%ebp
   14898:	53                   	push   %ebx
    if(index>bitmap->bit_count) return -1;
   14899:	8b 45 08             	mov    0x8(%ebp),%eax
   1489c:	8b 00                	mov    (%eax),%eax
   1489e:	39 45 0c             	cmp    %eax,0xc(%ebp)
   148a1:	7e 07                	jle    148aa <bitmap_get_bit+0x15>
   148a3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   148a8:	eb 37                	jmp    148e1 <bitmap_get_bit+0x4c>
    return bitmap->bits[index/8] & (1<<(index % 8));
   148aa:	8b 45 08             	mov    0x8(%ebp),%eax
   148ad:	8b 50 04             	mov    0x4(%eax),%edx
   148b0:	8b 45 0c             	mov    0xc(%ebp),%eax
   148b3:	8d 48 07             	lea    0x7(%eax),%ecx
   148b6:	85 c0                	test   %eax,%eax
   148b8:	0f 48 c1             	cmovs  %ecx,%eax
   148bb:	c1 f8 03             	sar    $0x3,%eax
   148be:	01 d0                	add    %edx,%eax
   148c0:	0f b6 00             	movzbl (%eax),%eax
   148c3:	0f b6 d8             	movzbl %al,%ebx
   148c6:	8b 45 0c             	mov    0xc(%ebp),%eax
   148c9:	99                   	cltd   
   148ca:	c1 ea 1d             	shr    $0x1d,%edx
   148cd:	01 d0                	add    %edx,%eax
   148cf:	83 e0 07             	and    $0x7,%eax
   148d2:	29 d0                	sub    %edx,%eax
   148d4:	ba 01 00 00 00       	mov    $0x1,%edx
   148d9:	89 c1                	mov    %eax,%ecx
   148db:	d3 e2                	shl    %cl,%edx
   148dd:	89 d0                	mov    %edx,%eax
   148df:	21 d8                	and    %ebx,%eax
}
   148e1:	5b                   	pop    %ebx
   148e2:	5d                   	pop    %ebp
   148e3:	c3                   	ret    

000148e4 <bitmap_set_bit>:

void bitmap_set_bit(bitmap_t* bitmap,int index,int count,int bit){
   148e4:	55                   	push   %ebp
   148e5:	89 e5                	mov    %esp,%ebp
   148e7:	56                   	push   %esi
   148e8:	53                   	push   %ebx
   148e9:	83 ec 10             	sub    $0x10,%esp
    if(index+count>bitmap->bit_count) return;
   148ec:	8b 55 0c             	mov    0xc(%ebp),%edx
   148ef:	8b 45 10             	mov    0x10(%ebp),%eax
   148f2:	01 c2                	add    %eax,%edx
   148f4:	8b 45 08             	mov    0x8(%ebp),%eax
   148f7:	8b 00                	mov    (%eax),%eax
   148f9:	39 c2                	cmp    %eax,%edx
   148fb:	0f 8f c6 00 00 00    	jg     149c7 <bitmap_set_bit+0xe3>
    for(int i=0;(i<count) && (index<bitmap->bit_count);i++,index++){
   14901:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14908:	e9 a2 00 00 00       	jmp    149af <bitmap_set_bit+0xcb>
        if(bit){
   1490d:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   14911:	74 4a                	je     1495d <bitmap_set_bit+0x79>
            bitmap->bits[index/8] |=(1<<(index%8));
   14913:	8b 45 08             	mov    0x8(%ebp),%eax
   14916:	8b 50 04             	mov    0x4(%eax),%edx
   14919:	8b 45 0c             	mov    0xc(%ebp),%eax
   1491c:	8d 48 07             	lea    0x7(%eax),%ecx
   1491f:	85 c0                	test   %eax,%eax
   14921:	0f 48 c1             	cmovs  %ecx,%eax
   14924:	c1 f8 03             	sar    $0x3,%eax
   14927:	89 c3                	mov    %eax,%ebx
   14929:	89 d8                	mov    %ebx,%eax
   1492b:	01 d0                	add    %edx,%eax
   1492d:	0f b6 00             	movzbl (%eax),%eax
   14930:	89 c6                	mov    %eax,%esi
   14932:	8b 45 0c             	mov    0xc(%ebp),%eax
   14935:	99                   	cltd   
   14936:	c1 ea 1d             	shr    $0x1d,%edx
   14939:	01 d0                	add    %edx,%eax
   1493b:	83 e0 07             	and    $0x7,%eax
   1493e:	29 d0                	sub    %edx,%eax
   14940:	ba 01 00 00 00       	mov    $0x1,%edx
   14945:	89 c1                	mov    %eax,%ecx
   14947:	d3 e2                	shl    %cl,%edx
   14949:	89 d0                	mov    %edx,%eax
   1494b:	89 f2                	mov    %esi,%edx
   1494d:	09 c2                	or     %eax,%edx
   1494f:	8b 45 08             	mov    0x8(%ebp),%eax
   14952:	8b 40 04             	mov    0x4(%eax),%eax
   14955:	89 d9                	mov    %ebx,%ecx
   14957:	01 c8                	add    %ecx,%eax
   14959:	88 10                	mov    %dl,(%eax)
   1495b:	eb 4a                	jmp    149a7 <bitmap_set_bit+0xc3>
        }
        else{
            bitmap->bits[index/8]&=~(1<<(index%8));
   1495d:	8b 45 08             	mov    0x8(%ebp),%eax
   14960:	8b 50 04             	mov    0x4(%eax),%edx
   14963:	8b 45 0c             	mov    0xc(%ebp),%eax
   14966:	8d 48 07             	lea    0x7(%eax),%ecx
   14969:	85 c0                	test   %eax,%eax
   1496b:	0f 48 c1             	cmovs  %ecx,%eax
   1496e:	c1 f8 03             	sar    $0x3,%eax
   14971:	89 c3                	mov    %eax,%ebx
   14973:	89 d8                	mov    %ebx,%eax
   14975:	01 d0                	add    %edx,%eax
   14977:	0f b6 00             	movzbl (%eax),%eax
   1497a:	89 c6                	mov    %eax,%esi
   1497c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1497f:	99                   	cltd   
   14980:	c1 ea 1d             	shr    $0x1d,%edx
   14983:	01 d0                	add    %edx,%eax
   14985:	83 e0 07             	and    $0x7,%eax
   14988:	29 d0                	sub    %edx,%eax
   1498a:	ba 01 00 00 00       	mov    $0x1,%edx
   1498f:	89 c1                	mov    %eax,%ecx
   14991:	d3 e2                	shl    %cl,%edx
   14993:	89 d0                	mov    %edx,%eax
   14995:	f7 d0                	not    %eax
   14997:	89 f2                	mov    %esi,%edx
   14999:	21 c2                	and    %eax,%edx
   1499b:	8b 45 08             	mov    0x8(%ebp),%eax
   1499e:	8b 40 04             	mov    0x4(%eax),%eax
   149a1:	89 d9                	mov    %ebx,%ecx
   149a3:	01 c8                	add    %ecx,%eax
   149a5:	88 10                	mov    %dl,(%eax)
    for(int i=0;(i<count) && (index<bitmap->bit_count);i++,index++){
   149a7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   149ab:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
   149af:	8b 45 f4             	mov    -0xc(%ebp),%eax
   149b2:	3b 45 10             	cmp    0x10(%ebp),%eax
   149b5:	7d 11                	jge    149c8 <bitmap_set_bit+0xe4>
   149b7:	8b 45 08             	mov    0x8(%ebp),%eax
   149ba:	8b 00                	mov    (%eax),%eax
   149bc:	39 45 0c             	cmp    %eax,0xc(%ebp)
   149bf:	0f 8c 48 ff ff ff    	jl     1490d <bitmap_set_bit+0x29>
   149c5:	eb 01                	jmp    149c8 <bitmap_set_bit+0xe4>
    if(index+count>bitmap->bit_count) return;
   149c7:	90                   	nop
        }
    }
}
   149c8:	83 c4 10             	add    $0x10,%esp
   149cb:	5b                   	pop    %ebx
   149cc:	5e                   	pop    %esi
   149cd:	5d                   	pop    %ebp
   149ce:	c3                   	ret    

000149cf <bitmap_is_set>:

int bitmap_is_set(bitmap_t* bitmap,int index){
   149cf:	55                   	push   %ebp
   149d0:	89 e5                	mov    %esp,%ebp
    return bitmap_get_bit(bitmap,index) ? 1 : 0;
   149d2:	ff 75 0c             	pushl  0xc(%ebp)
   149d5:	ff 75 08             	pushl  0x8(%ebp)
   149d8:	e8 b8 fe ff ff       	call   14895 <bitmap_get_bit>
   149dd:	83 c4 08             	add    $0x8,%esp
   149e0:	85 c0                	test   %eax,%eax
   149e2:	0f 95 c0             	setne  %al
   149e5:	0f b6 c0             	movzbl %al,%eax
}
   149e8:	c9                   	leave  
   149e9:	c3                   	ret    

000149ea <bitmap_alloc_nbits>:

int bitmap_alloc_nbits(bitmap_t* bitmap,int bit,int count){
   149ea:	55                   	push   %ebp
   149eb:	89 e5                	mov    %esp,%ebp
   149ed:	83 ec 10             	sub    $0x10,%esp
    int search_idx = 0;
   149f0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    int ok_idx = -1;
   149f7:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)

    while (search_idx < bitmap->bit_count) {
   149fe:	e9 85 00 00 00       	jmp    14a88 <bitmap_alloc_nbits+0x9e>
        if (bitmap_get_bit(bitmap, search_idx) != bit) {
   14a03:	ff 75 fc             	pushl  -0x4(%ebp)
   14a06:	ff 75 08             	pushl  0x8(%ebp)
   14a09:	e8 87 fe ff ff       	call   14895 <bitmap_get_bit>
   14a0e:	83 c4 08             	add    $0x8,%esp
   14a11:	39 45 0c             	cmp    %eax,0xc(%ebp)
   14a14:	74 06                	je     14a1c <bitmap_alloc_nbits+0x32>
            search_idx++;
   14a16:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
            continue;
   14a1a:	eb 6c                	jmp    14a88 <bitmap_alloc_nbits+0x9e>
        }

        ok_idx = search_idx;
   14a1c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   14a1f:	89 45 f8             	mov    %eax,-0x8(%ebp)

        int i;
        for (i = 1; (i < count) && (search_idx < bitmap->bit_count); i++) {
   14a22:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
   14a29:	eb 27                	jmp    14a52 <bitmap_alloc_nbits+0x68>
            if (bitmap_get_bit(bitmap, search_idx++) != bit) {
   14a2b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   14a2e:	8d 50 01             	lea    0x1(%eax),%edx
   14a31:	89 55 fc             	mov    %edx,-0x4(%ebp)
   14a34:	50                   	push   %eax
   14a35:	ff 75 08             	pushl  0x8(%ebp)
   14a38:	e8 58 fe ff ff       	call   14895 <bitmap_get_bit>
   14a3d:	83 c4 08             	add    $0x8,%esp
   14a40:	39 45 0c             	cmp    %eax,0xc(%ebp)
   14a43:	74 09                	je     14a4e <bitmap_alloc_nbits+0x64>
                ok_idx = -1;
   14a45:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)
                break;
   14a4c:	eb 16                	jmp    14a64 <bitmap_alloc_nbits+0x7a>
        for (i = 1; (i < count) && (search_idx < bitmap->bit_count); i++) {
   14a4e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14a52:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14a55:	3b 45 10             	cmp    0x10(%ebp),%eax
   14a58:	7d 0a                	jge    14a64 <bitmap_alloc_nbits+0x7a>
   14a5a:	8b 45 08             	mov    0x8(%ebp),%eax
   14a5d:	8b 00                	mov    (%eax),%eax
   14a5f:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   14a62:	7c c7                	jl     14a2b <bitmap_alloc_nbits+0x41>
            }
        }
        
        if (i >= count) {
   14a64:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14a67:	3b 45 10             	cmp    0x10(%ebp),%eax
   14a6a:	7c 1c                	jl     14a88 <bitmap_alloc_nbits+0x9e>
            bitmap_set_bit(bitmap, ok_idx, count, ~bit);
   14a6c:	8b 45 0c             	mov    0xc(%ebp),%eax
   14a6f:	f7 d0                	not    %eax
   14a71:	50                   	push   %eax
   14a72:	ff 75 10             	pushl  0x10(%ebp)
   14a75:	ff 75 f8             	pushl  -0x8(%ebp)
   14a78:	ff 75 08             	pushl  0x8(%ebp)
   14a7b:	e8 64 fe ff ff       	call   148e4 <bitmap_set_bit>
   14a80:	83 c4 10             	add    $0x10,%esp
            return ok_idx;
   14a83:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14a86:	eb 13                	jmp    14a9b <bitmap_alloc_nbits+0xb1>
    while (search_idx < bitmap->bit_count) {
   14a88:	8b 45 08             	mov    0x8(%ebp),%eax
   14a8b:	8b 00                	mov    (%eax),%eax
   14a8d:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   14a90:	0f 8c 6d ff ff ff    	jl     14a03 <bitmap_alloc_nbits+0x19>
        }
    }

    return -1;
   14a96:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14a9b:	c9                   	leave  
   14a9c:	c3                   	ret    

00014a9d <hlt>:
static inline void hlt(void){
   14a9d:	55                   	push   %ebp
   14a9e:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile("hlt");
   14aa0:	f4                   	hlt    
}
   14aa1:	90                   	nop
   14aa2:	5d                   	pop    %ebp
   14aa3:	c3                   	ret    

00014aa4 <kernel_strcpy>:
#include "tools/klib.h"

// 复制字符串
void kernel_strcpy(char* dest,const char* src){
   14aa4:	55                   	push   %ebp
   14aa5:	89 e5                	mov    %esp,%ebp
    if(!dest || !src){
   14aa7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   14aab:	74 3b                	je     14ae8 <kernel_strcpy+0x44>
   14aad:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   14ab1:	74 35                	je     14ae8 <kernel_strcpy+0x44>
        return;
    }
    while(*dest&&*src){
   14ab3:	eb 17                	jmp    14acc <kernel_strcpy+0x28>
        *dest++=*src++;
   14ab5:	8b 55 0c             	mov    0xc(%ebp),%edx
   14ab8:	8d 42 01             	lea    0x1(%edx),%eax
   14abb:	89 45 0c             	mov    %eax,0xc(%ebp)
   14abe:	8b 45 08             	mov    0x8(%ebp),%eax
   14ac1:	8d 48 01             	lea    0x1(%eax),%ecx
   14ac4:	89 4d 08             	mov    %ecx,0x8(%ebp)
   14ac7:	0f b6 12             	movzbl (%edx),%edx
   14aca:	88 10                	mov    %dl,(%eax)
    while(*dest&&*src){
   14acc:	8b 45 08             	mov    0x8(%ebp),%eax
   14acf:	0f b6 00             	movzbl (%eax),%eax
   14ad2:	84 c0                	test   %al,%al
   14ad4:	74 0a                	je     14ae0 <kernel_strcpy+0x3c>
   14ad6:	8b 45 0c             	mov    0xc(%ebp),%eax
   14ad9:	0f b6 00             	movzbl (%eax),%eax
   14adc:	84 c0                	test   %al,%al
   14ade:	75 d5                	jne    14ab5 <kernel_strcpy+0x11>
    }
    *dest='\0';
   14ae0:	8b 45 08             	mov    0x8(%ebp),%eax
   14ae3:	c6 00 00             	movb   $0x0,(%eax)
   14ae6:	eb 01                	jmp    14ae9 <kernel_strcpy+0x45>
        return;
   14ae8:	90                   	nop
}
   14ae9:	5d                   	pop    %ebp
   14aea:	c3                   	ret    

00014aeb <kernel_strncpy>:

// 复制字符串指明复制多个字符
void kernel_strncpy(char* dest,const char* src,unsigned int size){
   14aeb:	55                   	push   %ebp
   14aec:	89 e5                	mov    %esp,%ebp
   14aee:	83 ec 10             	sub    $0x10,%esp
    if(!dest||!src||!size){
   14af1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   14af5:	74 61                	je     14b58 <kernel_strncpy+0x6d>
   14af7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   14afb:	74 5b                	je     14b58 <kernel_strncpy+0x6d>
   14afd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   14b01:	74 55                	je     14b58 <kernel_strncpy+0x6d>
        return;
    }
    char*d=dest;
   14b03:	8b 45 08             	mov    0x8(%ebp),%eax
   14b06:	89 45 fc             	mov    %eax,-0x4(%ebp)
    const char* s=src;
   14b09:	8b 45 0c             	mov    0xc(%ebp),%eax
   14b0c:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while((size-->0)&&(*s)){
   14b0f:	eb 17                	jmp    14b28 <kernel_strncpy+0x3d>
        *d++=*s++;
   14b11:	8b 55 f8             	mov    -0x8(%ebp),%edx
   14b14:	8d 42 01             	lea    0x1(%edx),%eax
   14b17:	89 45 f8             	mov    %eax,-0x8(%ebp)
   14b1a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   14b1d:	8d 48 01             	lea    0x1(%eax),%ecx
   14b20:	89 4d fc             	mov    %ecx,-0x4(%ebp)
   14b23:	0f b6 12             	movzbl (%edx),%edx
   14b26:	88 10                	mov    %dl,(%eax)
    while((size-->0)&&(*s)){
   14b28:	8b 45 10             	mov    0x10(%ebp),%eax
   14b2b:	8d 50 ff             	lea    -0x1(%eax),%edx
   14b2e:	89 55 10             	mov    %edx,0x10(%ebp)
   14b31:	85 c0                	test   %eax,%eax
   14b33:	74 0a                	je     14b3f <kernel_strncpy+0x54>
   14b35:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14b38:	0f b6 00             	movzbl (%eax),%eax
   14b3b:	84 c0                	test   %al,%al
   14b3d:	75 d2                	jne    14b11 <kernel_strncpy+0x26>
    }
    if(size==0){
   14b3f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   14b43:	75 0b                	jne    14b50 <kernel_strncpy+0x65>
        *(d-1)='\0';
   14b45:	8b 45 fc             	mov    -0x4(%ebp),%eax
   14b48:	83 e8 01             	sub    $0x1,%eax
   14b4b:	c6 00 00             	movb   $0x0,(%eax)
   14b4e:	eb 09                	jmp    14b59 <kernel_strncpy+0x6e>
    }
    else{
        *d='\0';
   14b50:	8b 45 fc             	mov    -0x4(%ebp),%eax
   14b53:	c6 00 00             	movb   $0x0,(%eax)
   14b56:	eb 01                	jmp    14b59 <kernel_strncpy+0x6e>
        return;
   14b58:	90                   	nop
    }
}
   14b59:	c9                   	leave  
   14b5a:	c3                   	ret    

00014b5b <kernel_strncmp>:


// 比较两个字符串
int kernel_strncmp(const char* s1,const char* s2,unsigned int size){
   14b5b:	55                   	push   %ebp
   14b5c:	89 e5                	mov    %esp,%ebp
    if(!s1 || !s2){
   14b5e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   14b62:	74 06                	je     14b6a <kernel_strncmp+0xf>
   14b64:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   14b68:	75 0f                	jne    14b79 <kernel_strncmp+0x1e>
        return -1;
   14b6a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14b6f:	eb 62                	jmp    14bd3 <kernel_strncmp+0x78>
    }
    while(*s1 && *s2 && (*s1==*s2) && size){
        s1++;
   14b71:	83 45 08 01          	addl   $0x1,0x8(%ebp)
        s2++;
   14b75:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
    while(*s1 && *s2 && (*s1==*s2) && size){
   14b79:	8b 45 08             	mov    0x8(%ebp),%eax
   14b7c:	0f b6 00             	movzbl (%eax),%eax
   14b7f:	84 c0                	test   %al,%al
   14b81:	74 20                	je     14ba3 <kernel_strncmp+0x48>
   14b83:	8b 45 0c             	mov    0xc(%ebp),%eax
   14b86:	0f b6 00             	movzbl (%eax),%eax
   14b89:	84 c0                	test   %al,%al
   14b8b:	74 16                	je     14ba3 <kernel_strncmp+0x48>
   14b8d:	8b 45 08             	mov    0x8(%ebp),%eax
   14b90:	0f b6 10             	movzbl (%eax),%edx
   14b93:	8b 45 0c             	mov    0xc(%ebp),%eax
   14b96:	0f b6 00             	movzbl (%eax),%eax
   14b99:	38 c2                	cmp    %al,%dl
   14b9b:	75 06                	jne    14ba3 <kernel_strncmp+0x48>
   14b9d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   14ba1:	75 ce                	jne    14b71 <kernel_strncmp+0x16>
    }
    // 相等返回1
    return !((*s1=='\0') || (*s2=='\0') || (*s1==*s2));
   14ba3:	8b 45 08             	mov    0x8(%ebp),%eax
   14ba6:	0f b6 00             	movzbl (%eax),%eax
   14ba9:	84 c0                	test   %al,%al
   14bab:	74 21                	je     14bce <kernel_strncmp+0x73>
   14bad:	8b 45 0c             	mov    0xc(%ebp),%eax
   14bb0:	0f b6 00             	movzbl (%eax),%eax
   14bb3:	84 c0                	test   %al,%al
   14bb5:	74 17                	je     14bce <kernel_strncmp+0x73>
   14bb7:	8b 45 08             	mov    0x8(%ebp),%eax
   14bba:	0f b6 10             	movzbl (%eax),%edx
   14bbd:	8b 45 0c             	mov    0xc(%ebp),%eax
   14bc0:	0f b6 00             	movzbl (%eax),%eax
   14bc3:	38 c2                	cmp    %al,%dl
   14bc5:	74 07                	je     14bce <kernel_strncmp+0x73>
   14bc7:	b8 01 00 00 00       	mov    $0x1,%eax
   14bcc:	eb 05                	jmp    14bd3 <kernel_strncmp+0x78>
   14bce:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14bd3:	5d                   	pop    %ebp
   14bd4:	c3                   	ret    

00014bd5 <kernel_strlen>:

// 获取字符串长度
int kernel_strlen(const char* str){
   14bd5:	55                   	push   %ebp
   14bd6:	89 e5                	mov    %esp,%ebp
   14bd8:	83 ec 10             	sub    $0x10,%esp
    if(!str){
   14bdb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   14bdf:	75 07                	jne    14be8 <kernel_strlen+0x13>
        return 0;
   14be1:	b8 00 00 00 00       	mov    $0x0,%eax
   14be6:	eb 26                	jmp    14c0e <kernel_strlen+0x39>
    }
    const char*c=str;
   14be8:	8b 45 08             	mov    0x8(%ebp),%eax
   14beb:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int len=0;
   14bee:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    while(*c++){
   14bf5:	eb 04                	jmp    14bfb <kernel_strlen+0x26>
        len++;
   14bf7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    while(*c++){
   14bfb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   14bfe:	8d 50 01             	lea    0x1(%eax),%edx
   14c01:	89 55 fc             	mov    %edx,-0x4(%ebp)
   14c04:	0f b6 00             	movzbl (%eax),%eax
   14c07:	84 c0                	test   %al,%al
   14c09:	75 ec                	jne    14bf7 <kernel_strlen+0x22>
    }
    return len;
   14c0b:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
   14c0e:	c9                   	leave  
   14c0f:	c3                   	ret    

00014c10 <kernel_memcpy>:

// 复制内存的值
void kernel_memcpy(void* dest,void* src,unsigned int size){
   14c10:	55                   	push   %ebp
   14c11:	89 e5                	mov    %esp,%ebp
   14c13:	83 ec 10             	sub    $0x10,%esp
    if(!dest || !src || !size){
   14c16:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   14c1a:	74 40                	je     14c5c <kernel_memcpy+0x4c>
   14c1c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   14c20:	74 3a                	je     14c5c <kernel_memcpy+0x4c>
   14c22:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   14c26:	74 34                	je     14c5c <kernel_memcpy+0x4c>
        return;
    }
    uint8_t* s=(uint8_t*) src;
   14c28:	8b 45 0c             	mov    0xc(%ebp),%eax
   14c2b:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint8_t* d=(uint8_t*) dest;
   14c2e:	8b 45 08             	mov    0x8(%ebp),%eax
   14c31:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while(size--){
   14c34:	eb 17                	jmp    14c4d <kernel_memcpy+0x3d>
        *d++=*s++;
   14c36:	8b 55 fc             	mov    -0x4(%ebp),%edx
   14c39:	8d 42 01             	lea    0x1(%edx),%eax
   14c3c:	89 45 fc             	mov    %eax,-0x4(%ebp)
   14c3f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14c42:	8d 48 01             	lea    0x1(%eax),%ecx
   14c45:	89 4d f8             	mov    %ecx,-0x8(%ebp)
   14c48:	0f b6 12             	movzbl (%edx),%edx
   14c4b:	88 10                	mov    %dl,(%eax)
    while(size--){
   14c4d:	8b 45 10             	mov    0x10(%ebp),%eax
   14c50:	8d 50 ff             	lea    -0x1(%eax),%edx
   14c53:	89 55 10             	mov    %edx,0x10(%ebp)
   14c56:	85 c0                	test   %eax,%eax
   14c58:	75 dc                	jne    14c36 <kernel_memcpy+0x26>
   14c5a:	eb 01                	jmp    14c5d <kernel_memcpy+0x4d>
        return;
   14c5c:	90                   	nop
    }
    
}
   14c5d:	c9                   	leave  
   14c5e:	c3                   	ret    

00014c5f <kernel_memset>:

// 设置内存的值
void kernel_memset(void* dest,uint8_t v,int size){
   14c5f:	55                   	push   %ebp
   14c60:	89 e5                	mov    %esp,%ebp
   14c62:	83 ec 14             	sub    $0x14,%esp
   14c65:	8b 45 0c             	mov    0xc(%ebp),%eax
   14c68:	88 45 ec             	mov    %al,-0x14(%ebp)
    if(!dest || !size){
   14c6b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   14c6f:	74 2c                	je     14c9d <kernel_memset+0x3e>
   14c71:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   14c75:	74 26                	je     14c9d <kernel_memset+0x3e>
        return;
    }
    uint8_t* d=(uint8_t*) dest;
   14c77:	8b 45 08             	mov    0x8(%ebp),%eax
   14c7a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while(size--){
   14c7d:	eb 0f                	jmp    14c8e <kernel_memset+0x2f>
        *d++=v;
   14c7f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   14c82:	8d 50 01             	lea    0x1(%eax),%edx
   14c85:	89 55 fc             	mov    %edx,-0x4(%ebp)
   14c88:	0f b6 55 ec          	movzbl -0x14(%ebp),%edx
   14c8c:	88 10                	mov    %dl,(%eax)
    while(size--){
   14c8e:	8b 45 10             	mov    0x10(%ebp),%eax
   14c91:	8d 50 ff             	lea    -0x1(%eax),%edx
   14c94:	89 55 10             	mov    %edx,0x10(%ebp)
   14c97:	85 c0                	test   %eax,%eax
   14c99:	75 e4                	jne    14c7f <kernel_memset+0x20>
   14c9b:	eb 01                	jmp    14c9e <kernel_memset+0x3f>
        return;
   14c9d:	90                   	nop
    }
}
   14c9e:	c9                   	leave  
   14c9f:	c3                   	ret    

00014ca0 <kernel_memcmp>:

// 比较内存的值
int kernel_memcmp(void* d1,void* d2,unsigned int size){
   14ca0:	55                   	push   %ebp
   14ca1:	89 e5                	mov    %esp,%ebp
   14ca3:	83 ec 10             	sub    $0x10,%esp
     if(!d1 || !d2 || !size){
   14ca6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   14caa:	74 0c                	je     14cb8 <kernel_memcmp+0x18>
   14cac:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   14cb0:	74 06                	je     14cb8 <kernel_memcmp+0x18>
   14cb2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   14cb6:	75 07                	jne    14cbf <kernel_memcmp+0x1f>
        return 1;
   14cb8:	b8 01 00 00 00       	mov    $0x1,%eax
   14cbd:	eb 43                	jmp    14d02 <kernel_memcmp+0x62>
    }
    uint8_t* p_d1=(uint8_t*) d1;
   14cbf:	8b 45 08             	mov    0x8(%ebp),%eax
   14cc2:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint8_t* p_d2=(uint8_t*) d2;
   14cc5:	8b 45 0c             	mov    0xc(%ebp),%eax
   14cc8:	89 45 f8             	mov    %eax,-0x8(%ebp)
    // 不同返回1，相同返回0
    while(size--){
   14ccb:	eb 23                	jmp    14cf0 <kernel_memcmp+0x50>
        if(*p_d1++!=*p_d2++){
   14ccd:	8b 45 fc             	mov    -0x4(%ebp),%eax
   14cd0:	8d 50 01             	lea    0x1(%eax),%edx
   14cd3:	89 55 fc             	mov    %edx,-0x4(%ebp)
   14cd6:	0f b6 08             	movzbl (%eax),%ecx
   14cd9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14cdc:	8d 50 01             	lea    0x1(%eax),%edx
   14cdf:	89 55 f8             	mov    %edx,-0x8(%ebp)
   14ce2:	0f b6 00             	movzbl (%eax),%eax
   14ce5:	38 c1                	cmp    %al,%cl
   14ce7:	74 07                	je     14cf0 <kernel_memcmp+0x50>
            return 1;
   14ce9:	b8 01 00 00 00       	mov    $0x1,%eax
   14cee:	eb 12                	jmp    14d02 <kernel_memcmp+0x62>
    while(size--){
   14cf0:	8b 45 10             	mov    0x10(%ebp),%eax
   14cf3:	8d 50 ff             	lea    -0x1(%eax),%edx
   14cf6:	89 55 10             	mov    %edx,0x10(%ebp)
   14cf9:	85 c0                	test   %eax,%eax
   14cfb:	75 d0                	jne    14ccd <kernel_memcmp+0x2d>
        }
    }
    return 0;
   14cfd:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14d02:	c9                   	leave  
   14d03:	c3                   	ret    

00014d04 <kernel_sprintf>:

void kernel_sprintf(char* buf,const char* fmt,...){
   14d04:	55                   	push   %ebp
   14d05:	89 e5                	mov    %esp,%ebp
   14d07:	83 ec 18             	sub    $0x18,%esp
    va_list args;
    va_start(args,fmt);
   14d0a:	8d 45 10             	lea    0x10(%ebp),%eax
   14d0d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kernel_vsprintf(buf,fmt,args);
   14d10:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14d13:	83 ec 04             	sub    $0x4,%esp
   14d16:	50                   	push   %eax
   14d17:	ff 75 0c             	pushl  0xc(%ebp)
   14d1a:	ff 75 08             	pushl  0x8(%ebp)
   14d1d:	e8 45 01 00 00       	call   14e67 <kernel_vsprintf>
   14d22:	83 c4 10             	add    $0x10,%esp
    va_end(args);
}
   14d25:	90                   	nop
   14d26:	c9                   	leave  
   14d27:	c3                   	ret    

00014d28 <kernel_itoa>:

void kernel_itoa(char * buf, int num, int base) {
   14d28:	55                   	push   %ebp
   14d29:	89 e5                	mov    %esp,%ebp
   14d2b:	53                   	push   %ebx
   14d2c:	83 ec 20             	sub    $0x20,%esp
    static const char * num2ch = {"FEDCBA9876543210123456789ABCDEF"};
    char * p = buf;
   14d2f:	8b 45 08             	mov    0x8(%ebp),%eax
   14d32:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int old_num = num;
   14d35:	8b 45 0c             	mov    0xc(%ebp),%eax
   14d38:	89 45 e8             	mov    %eax,-0x18(%ebp)

    if ((base != 2) && (base != 8) && (base != 10) && (base != 16)) {
   14d3b:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
   14d3f:	74 1d                	je     14d5e <kernel_itoa+0x36>
   14d41:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
   14d45:	74 17                	je     14d5e <kernel_itoa+0x36>
   14d47:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   14d4b:	74 11                	je     14d5e <kernel_itoa+0x36>
   14d4d:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
   14d51:	74 0b                	je     14d5e <kernel_itoa+0x36>
        *p = '\0';
   14d53:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14d56:	c6 00 00             	movb   $0x0,(%eax)
        return;
   14d59:	e9 03 01 00 00       	jmp    14e61 <kernel_itoa+0x139>
    }

    int signed_num = 0;
   14d5e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    if ((num < 0) && (base == 10)) {
   14d65:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   14d69:	79 19                	jns    14d84 <kernel_itoa+0x5c>
   14d6b:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   14d6f:	75 13                	jne    14d84 <kernel_itoa+0x5c>
        *p++ = '-';
   14d71:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14d74:	8d 50 01             	lea    0x1(%eax),%edx
   14d77:	89 55 f8             	mov    %edx,-0x8(%ebp)
   14d7a:	c6 00 2d             	movb   $0x2d,(%eax)
        signed_num = 1;
   14d7d:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    }

    if (signed_num) {
   14d84:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14d88:	74 3b                	je     14dc5 <kernel_itoa+0x9d>
        do {
            char ch = num2ch[num % base + 15];
   14d8a:	8b 0d 98 60 01 00    	mov    0x16098,%ecx
   14d90:	8b 45 0c             	mov    0xc(%ebp),%eax
   14d93:	99                   	cltd   
   14d94:	f7 7d 10             	idivl  0x10(%ebp)
   14d97:	89 d0                	mov    %edx,%eax
   14d99:	83 c0 0f             	add    $0xf,%eax
   14d9c:	01 c8                	add    %ecx,%eax
   14d9e:	0f b6 00             	movzbl (%eax),%eax
   14da1:	88 45 e6             	mov    %al,-0x1a(%ebp)
            *p++ = ch;
   14da4:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14da7:	8d 50 01             	lea    0x1(%eax),%edx
   14daa:	89 55 f8             	mov    %edx,-0x8(%ebp)
   14dad:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
   14db1:	88 10                	mov    %dl,(%eax)
            num /= base;
   14db3:	8b 45 0c             	mov    0xc(%ebp),%eax
   14db6:	99                   	cltd   
   14db7:	f7 7d 10             	idivl  0x10(%ebp)
   14dba:	89 45 0c             	mov    %eax,0xc(%ebp)
        } while (num);
   14dbd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   14dc1:	75 c7                	jne    14d8a <kernel_itoa+0x62>
   14dc3:	eb 4b                	jmp    14e10 <kernel_itoa+0xe8>
    } else {
        uint32_t u_num = (uint32_t)num;
   14dc5:	8b 45 0c             	mov    0xc(%ebp),%eax
   14dc8:	89 45 f0             	mov    %eax,-0x10(%ebp)
        do {
            char ch = num2ch[u_num % base + 15];
   14dcb:	8b 0d 98 60 01 00    	mov    0x16098,%ecx
   14dd1:	8b 5d 10             	mov    0x10(%ebp),%ebx
   14dd4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14dd7:	ba 00 00 00 00       	mov    $0x0,%edx
   14ddc:	f7 f3                	div    %ebx
   14dde:	89 d0                	mov    %edx,%eax
   14de0:	83 c0 0f             	add    $0xf,%eax
   14de3:	01 c8                	add    %ecx,%eax
   14de5:	0f b6 00             	movzbl (%eax),%eax
   14de8:	88 45 e7             	mov    %al,-0x19(%ebp)
            *p++ = ch;
   14deb:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14dee:	8d 50 01             	lea    0x1(%eax),%edx
   14df1:	89 55 f8             	mov    %edx,-0x8(%ebp)
   14df4:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
   14df8:	88 10                	mov    %dl,(%eax)
            u_num /= base;
   14dfa:	8b 5d 10             	mov    0x10(%ebp),%ebx
   14dfd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14e00:	ba 00 00 00 00       	mov    $0x0,%edx
   14e05:	f7 f3                	div    %ebx
   14e07:	89 45 f0             	mov    %eax,-0x10(%ebp)
        } while (u_num);
   14e0a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14e0e:	75 bb                	jne    14dcb <kernel_itoa+0xa3>
    }
    *p-- = '\0';
   14e10:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14e13:	8d 50 ff             	lea    -0x1(%eax),%edx
   14e16:	89 55 f8             	mov    %edx,-0x8(%ebp)
   14e19:	c6 00 00             	movb   $0x0,(%eax)

    char * start = (!signed_num) ? buf : buf + 1;
   14e1c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14e20:	74 08                	je     14e2a <kernel_itoa+0x102>
   14e22:	8b 45 08             	mov    0x8(%ebp),%eax
   14e25:	83 c0 01             	add    $0x1,%eax
   14e28:	eb 03                	jmp    14e2d <kernel_itoa+0x105>
   14e2a:	8b 45 08             	mov    0x8(%ebp),%eax
   14e2d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    while (start < p) {
   14e30:	eb 27                	jmp    14e59 <kernel_itoa+0x131>
        char ch = *start;
   14e32:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14e35:	0f b6 00             	movzbl (%eax),%eax
   14e38:	88 45 e5             	mov    %al,-0x1b(%ebp)
        *start = *p;
   14e3b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14e3e:	0f b6 10             	movzbl (%eax),%edx
   14e41:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14e44:	88 10                	mov    %dl,(%eax)
        *p-- = ch;
   14e46:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14e49:	8d 50 ff             	lea    -0x1(%eax),%edx
   14e4c:	89 55 f8             	mov    %edx,-0x8(%ebp)
   14e4f:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
   14e53:	88 10                	mov    %dl,(%eax)
        start++;
   14e55:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    while (start < p) {
   14e59:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14e5c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   14e5f:	72 d1                	jb     14e32 <kernel_itoa+0x10a>
    }
}
   14e61:	83 c4 20             	add    $0x20,%esp
   14e64:	5b                   	pop    %ebx
   14e65:	5d                   	pop    %ebp
   14e66:	c3                   	ret    

00014e67 <kernel_vsprintf>:

void kernel_vsprintf(char* buf,const char*fmt,va_list args){
   14e67:	55                   	push   %ebp
   14e68:	89 e5                	mov    %esp,%ebp
   14e6a:	83 ec 20             	sub    $0x20,%esp
    enum {NORMAL,READ_FMT} state=NORMAL;
   14e6d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    char* curr=buf;
   14e74:	8b 45 08             	mov    0x8(%ebp),%eax
   14e77:	89 45 f8             	mov    %eax,-0x8(%ebp)
    char ch;
    while((ch=*fmt++)){
   14e7a:	e9 17 01 00 00       	jmp    14f96 <kernel_vsprintf+0x12f>
       switch (state)
   14e7f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   14e82:	85 c0                	test   %eax,%eax
   14e84:	74 0a                	je     14e90 <kernel_vsprintf+0x29>
   14e86:	83 f8 01             	cmp    $0x1,%eax
   14e89:	74 2b                	je     14eb6 <kernel_vsprintf+0x4f>
   14e8b:	e9 06 01 00 00       	jmp    14f96 <kernel_vsprintf+0x12f>
       {
            case NORMAL:
                if(ch=='%'){
   14e90:	80 7d ef 25          	cmpb   $0x25,-0x11(%ebp)
   14e94:	75 0c                	jne    14ea2 <kernel_vsprintf+0x3b>
                    state=READ_FMT;
   14e96:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
   14e9d:	e9 f4 00 00 00       	jmp    14f96 <kernel_vsprintf+0x12f>
                }
                else{
                    *curr++=ch;
   14ea2:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14ea5:	8d 50 01             	lea    0x1(%eax),%edx
   14ea8:	89 55 f8             	mov    %edx,-0x8(%ebp)
   14eab:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
   14eaf:	88 10                	mov    %dl,(%eax)
                }
                break;
   14eb1:	e9 e0 00 00 00       	jmp    14f96 <kernel_vsprintf+0x12f>
            case READ_FMT:
                if(ch=='s'){
   14eb6:	80 7d ef 73          	cmpb   $0x73,-0x11(%ebp)
   14eba:	75 47                	jne    14f03 <kernel_vsprintf+0x9c>
                    const char*str=va_arg(args,char*);
   14ebc:	8b 45 10             	mov    0x10(%ebp),%eax
   14ebf:	8d 50 04             	lea    0x4(%eax),%edx
   14ec2:	89 55 10             	mov    %edx,0x10(%ebp)
   14ec5:	8b 00                	mov    (%eax),%eax
   14ec7:	89 45 f4             	mov    %eax,-0xc(%ebp)
                    int len=kernel_strlen(str);
   14eca:	ff 75 f4             	pushl  -0xc(%ebp)
   14ecd:	e8 03 fd ff ff       	call   14bd5 <kernel_strlen>
   14ed2:	83 c4 04             	add    $0x4,%esp
   14ed5:	89 45 f0             	mov    %eax,-0x10(%ebp)
                    while(len--){
   14ed8:	eb 17                	jmp    14ef1 <kernel_vsprintf+0x8a>
                        *curr++=*str++;
   14eda:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14edd:	8d 42 01             	lea    0x1(%edx),%eax
   14ee0:	89 45 f4             	mov    %eax,-0xc(%ebp)
   14ee3:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14ee6:	8d 48 01             	lea    0x1(%eax),%ecx
   14ee9:	89 4d f8             	mov    %ecx,-0x8(%ebp)
   14eec:	0f b6 12             	movzbl (%edx),%edx
   14eef:	88 10                	mov    %dl,(%eax)
                    while(len--){
   14ef1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14ef4:	8d 50 ff             	lea    -0x1(%eax),%edx
   14ef7:	89 55 f0             	mov    %edx,-0x10(%ebp)
   14efa:	85 c0                	test   %eax,%eax
   14efc:	75 dc                	jne    14eda <kernel_vsprintf+0x73>
   14efe:	e9 8b 00 00 00       	jmp    14f8e <kernel_vsprintf+0x127>
                    }
                }
                else if(ch=='d'){
   14f03:	80 7d ef 64          	cmpb   $0x64,-0x11(%ebp)
   14f07:	75 2e                	jne    14f37 <kernel_vsprintf+0xd0>
                    int num=va_arg(args,int);
   14f09:	8b 45 10             	mov    0x10(%ebp),%eax
   14f0c:	8d 50 04             	lea    0x4(%eax),%edx
   14f0f:	89 55 10             	mov    %edx,0x10(%ebp)
   14f12:	8b 00                	mov    (%eax),%eax
   14f14:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                    kernel_itoa(curr,num,10);
   14f17:	6a 0a                	push   $0xa
   14f19:	ff 75 e4             	pushl  -0x1c(%ebp)
   14f1c:	ff 75 f8             	pushl  -0x8(%ebp)
   14f1f:	e8 04 fe ff ff       	call   14d28 <kernel_itoa>
   14f24:	83 c4 0c             	add    $0xc,%esp
                    curr+=kernel_strlen(curr);
   14f27:	ff 75 f8             	pushl  -0x8(%ebp)
   14f2a:	e8 a6 fc ff ff       	call   14bd5 <kernel_strlen>
   14f2f:	83 c4 04             	add    $0x4,%esp
   14f32:	01 45 f8             	add    %eax,-0x8(%ebp)
   14f35:	eb 57                	jmp    14f8e <kernel_vsprintf+0x127>
                }
                else if(ch=='x'){
   14f37:	80 7d ef 78          	cmpb   $0x78,-0x11(%ebp)
   14f3b:	75 2e                	jne    14f6b <kernel_vsprintf+0x104>
                    int num=va_arg(args,int);
   14f3d:	8b 45 10             	mov    0x10(%ebp),%eax
   14f40:	8d 50 04             	lea    0x4(%eax),%edx
   14f43:	89 55 10             	mov    %edx,0x10(%ebp)
   14f46:	8b 00                	mov    (%eax),%eax
   14f48:	89 45 e8             	mov    %eax,-0x18(%ebp)
                    kernel_itoa(curr,num,16);
   14f4b:	6a 10                	push   $0x10
   14f4d:	ff 75 e8             	pushl  -0x18(%ebp)
   14f50:	ff 75 f8             	pushl  -0x8(%ebp)
   14f53:	e8 d0 fd ff ff       	call   14d28 <kernel_itoa>
   14f58:	83 c4 0c             	add    $0xc,%esp
                    curr+=kernel_strlen(curr);
   14f5b:	ff 75 f8             	pushl  -0x8(%ebp)
   14f5e:	e8 72 fc ff ff       	call   14bd5 <kernel_strlen>
   14f63:	83 c4 04             	add    $0x4,%esp
   14f66:	01 45 f8             	add    %eax,-0x8(%ebp)
   14f69:	eb 23                	jmp    14f8e <kernel_vsprintf+0x127>
                }
                else if(ch=='c'){
   14f6b:	80 7d ef 63          	cmpb   $0x63,-0x11(%ebp)
   14f6f:	75 1d                	jne    14f8e <kernel_vsprintf+0x127>
                    char c=va_arg(args,int);
   14f71:	8b 45 10             	mov    0x10(%ebp),%eax
   14f74:	8d 50 04             	lea    0x4(%eax),%edx
   14f77:	89 55 10             	mov    %edx,0x10(%ebp)
   14f7a:	8b 00                	mov    (%eax),%eax
   14f7c:	88 45 ee             	mov    %al,-0x12(%ebp)
                    *curr++=c;
   14f7f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14f82:	8d 50 01             	lea    0x1(%eax),%edx
   14f85:	89 55 f8             	mov    %edx,-0x8(%ebp)
   14f88:	0f b6 55 ee          	movzbl -0x12(%ebp),%edx
   14f8c:	88 10                	mov    %dl,(%eax)
                }
                state=NORMAL;
   14f8e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
                break;
   14f95:	90                   	nop
    while((ch=*fmt++)){
   14f96:	8b 45 0c             	mov    0xc(%ebp),%eax
   14f99:	8d 50 01             	lea    0x1(%eax),%edx
   14f9c:	89 55 0c             	mov    %edx,0xc(%ebp)
   14f9f:	0f b6 00             	movzbl (%eax),%eax
   14fa2:	88 45 ef             	mov    %al,-0x11(%ebp)
   14fa5:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
   14fa9:	0f 85 d0 fe ff ff    	jne    14e7f <kernel_vsprintf+0x18>
        
       }
    }

}
   14faf:	90                   	nop
   14fb0:	c9                   	leave  
   14fb1:	c3                   	ret    

00014fb2 <panic>:

void panic (const char * file, int line, const char * func, const char * cond){
   14fb2:	55                   	push   %ebp
   14fb3:	89 e5                	mov    %esp,%ebp
   14fb5:	83 ec 08             	sub    $0x8,%esp
    log_printf("assert failed!, %s\n",cond);
   14fb8:	83 ec 08             	sub    $0x8,%esp
   14fbb:	ff 75 14             	pushl  0x14(%ebp)
   14fbe:	68 48 5f 01 00       	push   $0x15f48
   14fc3:	e8 ba 02 00 00       	call   15282 <log_printf>
   14fc8:	83 c4 10             	add    $0x10,%esp
    log_printf("file: %s\nline: %d\nfunc: %s\n",file,line,func);
   14fcb:	ff 75 10             	pushl  0x10(%ebp)
   14fce:	ff 75 0c             	pushl  0xc(%ebp)
   14fd1:	ff 75 08             	pushl  0x8(%ebp)
   14fd4:	68 5c 5f 01 00       	push   $0x15f5c
   14fd9:	e8 a4 02 00 00       	call   15282 <log_printf>
   14fde:	83 c4 10             	add    $0x10,%esp
    for(;;){
        hlt();
   14fe1:	e8 b7 fa ff ff       	call   14a9d <hlt>
   14fe6:	eb f9                	jmp    14fe1 <panic+0x2f>

00014fe8 <string_count>:
    }
}

int string_count(char**start){
   14fe8:	55                   	push   %ebp
   14fe9:	89 e5                	mov    %esp,%ebp
   14feb:	83 ec 10             	sub    $0x10,%esp
    int count=0;
   14fee:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    if(start){
   14ff5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   14ff9:	74 15                	je     15010 <string_count+0x28>
        while(*start++){
   14ffb:	eb 04                	jmp    15001 <string_count+0x19>
            count++;
   14ffd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        while(*start++){
   15001:	8b 45 08             	mov    0x8(%ebp),%eax
   15004:	8d 50 04             	lea    0x4(%eax),%edx
   15007:	89 55 08             	mov    %edx,0x8(%ebp)
   1500a:	8b 00                	mov    (%eax),%eax
   1500c:	85 c0                	test   %eax,%eax
   1500e:	75 ed                	jne    14ffd <string_count+0x15>
        }
    }

    return count;
   15010:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   15013:	c9                   	leave  
   15014:	c3                   	ret    

00015015 <get_file_name>:

char* get_file_name(char*name){
   15015:	55                   	push   %ebp
   15016:	89 e5                	mov    %esp,%ebp
   15018:	83 ec 10             	sub    $0x10,%esp
    char*s=name;
   1501b:	8b 45 08             	mov    0x8(%ebp),%eax
   1501e:	89 45 fc             	mov    %eax,-0x4(%ebp)

    while(*s!='\0'){
   15021:	eb 04                	jmp    15027 <get_file_name+0x12>
        s++;
   15023:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    while(*s!='\0'){
   15027:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1502a:	0f b6 00             	movzbl (%eax),%eax
   1502d:	84 c0                	test   %al,%al
   1502f:	75 f2                	jne    15023 <get_file_name+0xe>
    }

    while((*s!='/') && (*s!='\\') && (s>=name)){
   15031:	eb 04                	jmp    15037 <get_file_name+0x22>
        s--;
   15033:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    while((*s!='/') && (*s!='\\') && (s>=name)){
   15037:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1503a:	0f b6 00             	movzbl (%eax),%eax
   1503d:	3c 2f                	cmp    $0x2f,%al
   1503f:	74 12                	je     15053 <get_file_name+0x3e>
   15041:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15044:	0f b6 00             	movzbl (%eax),%eax
   15047:	3c 5c                	cmp    $0x5c,%al
   15049:	74 08                	je     15053 <get_file_name+0x3e>
   1504b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1504e:	3b 45 08             	cmp    0x8(%ebp),%eax
   15051:	73 e0                	jae    15033 <get_file_name+0x1e>
    }

    return s+1;
   15053:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15056:	83 c0 01             	add    $0x1,%eax
   15059:	c9                   	leave  
   1505a:	c3                   	ret    

0001505b <list_is_empty>:
static inline int list_is_empty(list_t* list){
   1505b:	55                   	push   %ebp
   1505c:	89 e5                	mov    %esp,%ebp
    return list->count==0;
   1505e:	8b 45 08             	mov    0x8(%ebp),%eax
   15061:	8b 40 08             	mov    0x8(%eax),%eax
   15064:	85 c0                	test   %eax,%eax
   15066:	0f 94 c0             	sete   %al
   15069:	0f b6 c0             	movzbl %al,%eax
}
   1506c:	5d                   	pop    %ebp
   1506d:	c3                   	ret    

0001506e <list_init>:
#include "tools/list.h"

void list_init(list_t* list){
   1506e:	55                   	push   %ebp
   1506f:	89 e5                	mov    %esp,%ebp
    list->first=list->last=(list_node_t*)0;
   15071:	8b 45 08             	mov    0x8(%ebp),%eax
   15074:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   1507b:	8b 45 08             	mov    0x8(%ebp),%eax
   1507e:	8b 50 04             	mov    0x4(%eax),%edx
   15081:	8b 45 08             	mov    0x8(%ebp),%eax
   15084:	89 10                	mov    %edx,(%eax)
    list->count=0;
   15086:	8b 45 08             	mov    0x8(%ebp),%eax
   15089:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
   15090:	90                   	nop
   15091:	5d                   	pop    %ebp
   15092:	c3                   	ret    

00015093 <list_insert_first>:

void list_insert_first(list_t* list,list_node_t* node){
   15093:	55                   	push   %ebp
   15094:	89 e5                	mov    %esp,%ebp
    node->next=list->first;
   15096:	8b 45 08             	mov    0x8(%ebp),%eax
   15099:	8b 10                	mov    (%eax),%edx
   1509b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1509e:	89 50 04             	mov    %edx,0x4(%eax)
    node->pre=(list_node_t*)0;
   150a1:	8b 45 0c             	mov    0xc(%ebp),%eax
   150a4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(list_is_empty(list)){
   150aa:	ff 75 08             	pushl  0x8(%ebp)
   150ad:	e8 a9 ff ff ff       	call   1505b <list_is_empty>
   150b2:	83 c4 04             	add    $0x4,%esp
   150b5:	85 c0                	test   %eax,%eax
   150b7:	74 15                	je     150ce <list_insert_first+0x3b>
        list->last=list->first=node;
   150b9:	8b 45 08             	mov    0x8(%ebp),%eax
   150bc:	8b 55 0c             	mov    0xc(%ebp),%edx
   150bf:	89 10                	mov    %edx,(%eax)
   150c1:	8b 45 08             	mov    0x8(%ebp),%eax
   150c4:	8b 10                	mov    (%eax),%edx
   150c6:	8b 45 08             	mov    0x8(%ebp),%eax
   150c9:	89 50 04             	mov    %edx,0x4(%eax)
   150cc:	eb 12                	jmp    150e0 <list_insert_first+0x4d>
    }
    else{
        list->first->pre=node;
   150ce:	8b 45 08             	mov    0x8(%ebp),%eax
   150d1:	8b 00                	mov    (%eax),%eax
   150d3:	8b 55 0c             	mov    0xc(%ebp),%edx
   150d6:	89 10                	mov    %edx,(%eax)
        list->first=node;
   150d8:	8b 45 08             	mov    0x8(%ebp),%eax
   150db:	8b 55 0c             	mov    0xc(%ebp),%edx
   150de:	89 10                	mov    %edx,(%eax)
    }
    list->count++;
   150e0:	8b 45 08             	mov    0x8(%ebp),%eax
   150e3:	8b 40 08             	mov    0x8(%eax),%eax
   150e6:	8d 50 01             	lea    0x1(%eax),%edx
   150e9:	8b 45 08             	mov    0x8(%ebp),%eax
   150ec:	89 50 08             	mov    %edx,0x8(%eax)
}
   150ef:	90                   	nop
   150f0:	c9                   	leave  
   150f1:	c3                   	ret    

000150f2 <list_insert_last>:

void list_insert_last(list_t*list,list_node_t*node){
   150f2:	55                   	push   %ebp
   150f3:	89 e5                	mov    %esp,%ebp
    node->pre=list->last;
   150f5:	8b 45 08             	mov    0x8(%ebp),%eax
   150f8:	8b 50 04             	mov    0x4(%eax),%edx
   150fb:	8b 45 0c             	mov    0xc(%ebp),%eax
   150fe:	89 10                	mov    %edx,(%eax)
    node->next=(list_node_t*)0;
   15100:	8b 45 0c             	mov    0xc(%ebp),%eax
   15103:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    if(list_is_empty(list)){
   1510a:	ff 75 08             	pushl  0x8(%ebp)
   1510d:	e8 49 ff ff ff       	call   1505b <list_is_empty>
   15112:	83 c4 04             	add    $0x4,%esp
   15115:	85 c0                	test   %eax,%eax
   15117:	74 16                	je     1512f <list_insert_last+0x3d>
        list->first=list->last=node;
   15119:	8b 45 08             	mov    0x8(%ebp),%eax
   1511c:	8b 55 0c             	mov    0xc(%ebp),%edx
   1511f:	89 50 04             	mov    %edx,0x4(%eax)
   15122:	8b 45 08             	mov    0x8(%ebp),%eax
   15125:	8b 50 04             	mov    0x4(%eax),%edx
   15128:	8b 45 08             	mov    0x8(%ebp),%eax
   1512b:	89 10                	mov    %edx,(%eax)
   1512d:	eb 15                	jmp    15144 <list_insert_last+0x52>
    }
    else{
        list->last->next=node;
   1512f:	8b 45 08             	mov    0x8(%ebp),%eax
   15132:	8b 40 04             	mov    0x4(%eax),%eax
   15135:	8b 55 0c             	mov    0xc(%ebp),%edx
   15138:	89 50 04             	mov    %edx,0x4(%eax)
        list->last=node;
   1513b:	8b 45 08             	mov    0x8(%ebp),%eax
   1513e:	8b 55 0c             	mov    0xc(%ebp),%edx
   15141:	89 50 04             	mov    %edx,0x4(%eax)
    }
    list->count++;
   15144:	8b 45 08             	mov    0x8(%ebp),%eax
   15147:	8b 40 08             	mov    0x8(%eax),%eax
   1514a:	8d 50 01             	lea    0x1(%eax),%edx
   1514d:	8b 45 08             	mov    0x8(%ebp),%eax
   15150:	89 50 08             	mov    %edx,0x8(%eax)
}
   15153:	90                   	nop
   15154:	c9                   	leave  
   15155:	c3                   	ret    

00015156 <list_remove_first>:

list_node_t* list_remove_first(list_t* list){
   15156:	55                   	push   %ebp
   15157:	89 e5                	mov    %esp,%ebp
   15159:	83 ec 10             	sub    $0x10,%esp
    if(list_is_empty(list)){
   1515c:	ff 75 08             	pushl  0x8(%ebp)
   1515f:	e8 f7 fe ff ff       	call   1505b <list_is_empty>
   15164:	83 c4 04             	add    $0x4,%esp
   15167:	85 c0                	test   %eax,%eax
   15169:	74 07                	je     15172 <list_remove_first+0x1c>
        return (list_node_t*)0;
   1516b:	b8 00 00 00 00       	mov    $0x0,%eax
   15170:	eb 5a                	jmp    151cc <list_remove_first+0x76>
    }
    list_node_t* remove_node=list->first;
   15172:	8b 45 08             	mov    0x8(%ebp),%eax
   15175:	8b 00                	mov    (%eax),%eax
   15177:	89 45 fc             	mov    %eax,-0x4(%ebp)
    list->first=remove_node->next;
   1517a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1517d:	8b 50 04             	mov    0x4(%eax),%edx
   15180:	8b 45 08             	mov    0x8(%ebp),%eax
   15183:	89 10                	mov    %edx,(%eax)
    if(list->first==(list_node_t*)0){
   15185:	8b 45 08             	mov    0x8(%ebp),%eax
   15188:	8b 00                	mov    (%eax),%eax
   1518a:	85 c0                	test   %eax,%eax
   1518c:	75 0c                	jne    1519a <list_remove_first+0x44>
        list->last=(list_node_t*)0;
   1518e:	8b 45 08             	mov    0x8(%ebp),%eax
   15191:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   15198:	eb 0b                	jmp    151a5 <list_remove_first+0x4f>
    }
    else{
        list->first->pre=(list_node_t*)0;
   1519a:	8b 45 08             	mov    0x8(%ebp),%eax
   1519d:	8b 00                	mov    (%eax),%eax
   1519f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    remove_node->pre=remove_node->next=(list_node_t*)0;
   151a5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   151a8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   151af:	8b 45 fc             	mov    -0x4(%ebp),%eax
   151b2:	8b 50 04             	mov    0x4(%eax),%edx
   151b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   151b8:	89 10                	mov    %edx,(%eax)
    list->count--;
   151ba:	8b 45 08             	mov    0x8(%ebp),%eax
   151bd:	8b 40 08             	mov    0x8(%eax),%eax
   151c0:	8d 50 ff             	lea    -0x1(%eax),%edx
   151c3:	8b 45 08             	mov    0x8(%ebp),%eax
   151c6:	89 50 08             	mov    %edx,0x8(%eax)
    return remove_node;
   151c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   151cc:	c9                   	leave  
   151cd:	c3                   	ret    

000151ce <list_remove>:

list_node_t* list_remove(list_t* list,list_node_t*node){
   151ce:	55                   	push   %ebp
   151cf:	89 e5                	mov    %esp,%ebp
    if(node==list->first){
   151d1:	8b 45 08             	mov    0x8(%ebp),%eax
   151d4:	8b 00                	mov    (%eax),%eax
   151d6:	39 45 0c             	cmp    %eax,0xc(%ebp)
   151d9:	75 0b                	jne    151e6 <list_remove+0x18>
        list->first=node->next;
   151db:	8b 45 0c             	mov    0xc(%ebp),%eax
   151de:	8b 50 04             	mov    0x4(%eax),%edx
   151e1:	8b 45 08             	mov    0x8(%ebp),%eax
   151e4:	89 10                	mov    %edx,(%eax)
    }
    if(node==list->last){
   151e6:	8b 45 08             	mov    0x8(%ebp),%eax
   151e9:	8b 40 04             	mov    0x4(%eax),%eax
   151ec:	39 45 0c             	cmp    %eax,0xc(%ebp)
   151ef:	75 0b                	jne    151fc <list_remove+0x2e>
        list->last=node->pre;
   151f1:	8b 45 0c             	mov    0xc(%ebp),%eax
   151f4:	8b 10                	mov    (%eax),%edx
   151f6:	8b 45 08             	mov    0x8(%ebp),%eax
   151f9:	89 50 04             	mov    %edx,0x4(%eax)
    }
    if(node->pre){
   151fc:	8b 45 0c             	mov    0xc(%ebp),%eax
   151ff:	8b 00                	mov    (%eax),%eax
   15201:	85 c0                	test   %eax,%eax
   15203:	74 0e                	je     15213 <list_remove+0x45>
        node->pre->next=node->next;
   15205:	8b 45 0c             	mov    0xc(%ebp),%eax
   15208:	8b 00                	mov    (%eax),%eax
   1520a:	8b 55 0c             	mov    0xc(%ebp),%edx
   1520d:	8b 52 04             	mov    0x4(%edx),%edx
   15210:	89 50 04             	mov    %edx,0x4(%eax)
    }
    if(node->next){
   15213:	8b 45 0c             	mov    0xc(%ebp),%eax
   15216:	8b 40 04             	mov    0x4(%eax),%eax
   15219:	85 c0                	test   %eax,%eax
   1521b:	74 0d                	je     1522a <list_remove+0x5c>
        node->next->pre=node->pre;
   1521d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15220:	8b 40 04             	mov    0x4(%eax),%eax
   15223:	8b 55 0c             	mov    0xc(%ebp),%edx
   15226:	8b 12                	mov    (%edx),%edx
   15228:	89 10                	mov    %edx,(%eax)
    }
    node->pre=node->next=(list_node_t*)0;
   1522a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1522d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   15234:	8b 45 0c             	mov    0xc(%ebp),%eax
   15237:	8b 50 04             	mov    0x4(%eax),%edx
   1523a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1523d:	89 10                	mov    %edx,(%eax)
    list->count--;
   1523f:	8b 45 08             	mov    0x8(%ebp),%eax
   15242:	8b 40 08             	mov    0x8(%eax),%eax
   15245:	8d 50 ff             	lea    -0x1(%eax),%edx
   15248:	8b 45 08             	mov    0x8(%ebp),%eax
   1524b:	89 50 08             	mov    %edx,0x8(%eax)
    return node;
   1524e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15251:	5d                   	pop    %ebp
   15252:	c3                   	ret    

00015253 <log_init>:
static mutex_t mutex;

// 用来记录打印设备的id
static int log_dev_id;

void log_init(void){
   15253:	55                   	push   %ebp
   15254:	89 e5                	mov    %esp,%ebp
   15256:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&mutex);
   15259:	83 ec 0c             	sub    $0xc,%esp
   1525c:	68 e4 92 06 00       	push   $0x692e4
   15261:	e8 01 f3 ff ff       	call   14567 <mutex_init>
   15266:	83 c4 10             	add    $0x10,%esp

    log_dev_id=dev_open(DEV_TTY,0,0);
   15269:	83 ec 04             	sub    $0x4,%esp
   1526c:	6a 00                	push   $0x0
   1526e:	6a 00                	push   $0x0
   15270:	6a 01                	push   $0x1
   15272:	e8 5b e4 ff ff       	call   136d2 <dev_open>
   15277:	83 c4 10             	add    $0x10,%esp
   1527a:	a3 f8 92 06 00       	mov    %eax,0x692f8
    outb(COM1_PORT+1,0x00);
    outb(COM1_PORT+3,0x03);
    outb(COM1_PORT+2,0xc7);
    outb(COM1_PORT+4,0x0F);
#endif
}
   1527f:	90                   	nop
   15280:	c9                   	leave  
   15281:	c3                   	ret    

00015282 <log_printf>:

void log_printf(const char* fmt,...){
   15282:	55                   	push   %ebp
   15283:	89 e5                	mov    %esp,%ebp
   15285:	81 ec 98 00 00 00    	sub    $0x98,%esp
    char str_buf[128];
    va_list args;
    kernel_memset(str_buf,'\0',128);
   1528b:	83 ec 04             	sub    $0x4,%esp
   1528e:	68 80 00 00 00       	push   $0x80
   15293:	6a 00                	push   $0x0
   15295:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   1529b:	50                   	push   %eax
   1529c:	e8 be f9 ff ff       	call   14c5f <kernel_memset>
   152a1:	83 c4 10             	add    $0x10,%esp
    va_start(args,fmt);
   152a4:	8d 45 0c             	lea    0xc(%ebp),%eax
   152a7:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
    kernel_vsprintf(str_buf,fmt,args);
   152ad:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
   152b3:	83 ec 04             	sub    $0x4,%esp
   152b6:	50                   	push   %eax
   152b7:	ff 75 08             	pushl  0x8(%ebp)
   152ba:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   152c0:	50                   	push   %eax
   152c1:	e8 a1 fb ff ff       	call   14e67 <kernel_vsprintf>
   152c6:	83 c4 10             	add    $0x10,%esp
    va_end(args);
    
    mutex_lock(&mutex);
   152c9:	83 ec 0c             	sub    $0xc,%esp
   152cc:	68 e4 92 06 00       	push   $0x692e4
   152d1:	e8 bf f2 ff ff       	call   14595 <mutex_lock>
   152d6:	83 c4 10             	add    $0x10,%esp
    }
    outb(COM1_PORT,'\r');
    outb(COM1_PORT,'\n');
#else
    // console_write(0,str_buf,kernel_strlen(str_buf));
    dev_write(log_dev_id,0,str_buf,kernel_strlen(str_buf));
   152d9:	83 ec 0c             	sub    $0xc,%esp
   152dc:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   152e2:	50                   	push   %eax
   152e3:	e8 ed f8 ff ff       	call   14bd5 <kernel_strlen>
   152e8:	83 c4 10             	add    $0x10,%esp
   152eb:	89 c2                	mov    %eax,%edx
   152ed:	a1 f8 92 06 00       	mov    0x692f8,%eax
   152f2:	52                   	push   %edx
   152f3:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
   152f9:	52                   	push   %edx
   152fa:	6a 00                	push   $0x0
   152fc:	50                   	push   %eax
   152fd:	e8 6c e5 ff ff       	call   1386e <dev_write>
   15302:	83 c4 10             	add    $0x10,%esp
    char c='\n';
   15305:	c6 85 73 ff ff ff 0a 	movb   $0xa,-0x8d(%ebp)
    // console_write(0,&c,1);
    dev_write(log_dev_id,0,&c,1);
   1530c:	a1 f8 92 06 00       	mov    0x692f8,%eax
   15311:	6a 01                	push   $0x1
   15313:	8d 95 73 ff ff ff    	lea    -0x8d(%ebp),%edx
   15319:	52                   	push   %edx
   1531a:	6a 00                	push   $0x0
   1531c:	50                   	push   %eax
   1531d:	e8 4c e5 ff ff       	call   1386e <dev_write>
   15322:	83 c4 10             	add    $0x10,%esp
#endif
    mutex_unlock(&mutex);
   15325:	83 ec 0c             	sub    $0xc,%esp
   15328:	68 e4 92 06 00       	push   $0x692e4
   1532d:	e8 f2 f2 ff ff       	call   14624 <mutex_unlock>
   15332:	83 c4 10             	add    $0x10,%esp
   15335:	90                   	nop
   15336:	c9                   	leave  
   15337:	c3                   	ret    

Disassembly of section .first_task:

80000000 <first_task_entry>:
    .text
	.global first_task_entry
	.extern first_task_main
first_task_entry:
	mov %ss,%ax
80000000:	66 8c d0             	mov    %ss,%ax
	mov %ax, %ds
80000003:	8e d8                	mov    %eax,%ds
	mov %ax, %ss
80000005:	8e d0                	mov    %eax,%ss
	mov %ax, %es
80000007:	8e c0                	mov    %eax,%es
	mov %ax, %fs
80000009:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
8000000b:	8e e8                	mov    %eax,%gs
8000000d:	e9 00 00 00 00       	jmp    80000012 <first_task_main>

80000012 <first_task_main>:
#include "tools/log.h"
#include "core/task.h"
#include "applib/lib_syscall.h"

int first_task_main(void){
80000012:	55                   	push   %ebp
80000013:	89 e5                	mov    %esp,%ebp
80000015:	83 ec 28             	sub    $0x28,%esp
    int count=3;
80000018:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
    print_msg("first task id=%d",getpid());
8000001f:	e8 c1 01 00 00       	call   800001e5 <getpid>
80000024:	83 ec 08             	sub    $0x8,%esp
80000027:	50                   	push   %eax
80000028:	68 f2 00 00 80       	push   $0x800000f2
8000002d:	e8 ce 01 00 00       	call   80000200 <print_msg>
80000032:	83 c4 10             	add    $0x10,%esp
    int pid=fork();
80000035:	e8 ee 01 00 00       	call   80000228 <fork>
8000003a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(pid<0){
8000003d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
80000041:	79 14                	jns    80000057 <first_task_main+0x45>
        print_msg("create child proc failed.\n",0);
80000043:	83 ec 08             	sub    $0x8,%esp
80000046:	6a 00                	push   $0x0
80000048:	68 03 01 00 80       	push   $0x80000103
8000004d:	e8 ae 01 00 00       	call   80000200 <print_msg>
80000052:	83 c4 10             	add    $0x10,%esp
80000055:	eb 73                	jmp    800000ca <first_task_main+0xb8>
    }
    else if(pid==0){
80000057:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
8000005b:	75 47                	jne    800000a4 <first_task_main+0x92>
        print_msg("child: %d\n",count);
8000005d:	83 ec 08             	sub    $0x8,%esp
80000060:	ff 75 f4             	pushl  -0xc(%ebp)
80000063:	68 1e 01 00 80       	push   $0x8000011e
80000068:	e8 93 01 00 00       	call   80000200 <print_msg>
8000006d:	83 c4 10             	add    $0x10,%esp
        char* argv[]={"arg0","arg1","arg2","arg3"};
80000070:	c7 45 e0 29 01 00 80 	movl   $0x80000129,-0x20(%ebp)
80000077:	c7 45 e4 2e 01 00 80 	movl   $0x8000012e,-0x1c(%ebp)
8000007e:	c7 45 e8 33 01 00 80 	movl   $0x80000133,-0x18(%ebp)
80000085:	c7 45 ec 38 01 00 80 	movl   $0x80000138,-0x14(%ebp)
        execve("/shell.elf",argv,(char**)0);
8000008c:	83 ec 04             	sub    $0x4,%esp
8000008f:	6a 00                	push   $0x0
80000091:	8d 45 e0             	lea    -0x20(%ebp),%eax
80000094:	50                   	push   %eax
80000095:	68 3d 01 00 80       	push   $0x8000013d
8000009a:	e8 a4 01 00 00       	call   80000243 <execve>
8000009f:	83 c4 10             	add    $0x10,%esp
800000a2:	eb 26                	jmp    800000ca <first_task_main+0xb8>
    }
    else{
        print_msg("child task id=%d",pid);
800000a4:	83 ec 08             	sub    $0x8,%esp
800000a7:	ff 75 f0             	pushl  -0x10(%ebp)
800000aa:	68 48 01 00 80       	push   $0x80000148
800000af:	e8 4c 01 00 00       	call   80000200 <print_msg>
800000b4:	83 c4 10             	add    $0x10,%esp
        print_msg("parent: %d",count);
800000b7:	83 ec 08             	sub    $0x8,%esp
800000ba:	ff 75 f4             	pushl  -0xc(%ebp)
800000bd:	68 59 01 00 80       	push   $0x80000159
800000c2:	e8 39 01 00 00       	call   80000200 <print_msg>
800000c7:	83 c4 10             	add    $0x10,%esp
    }

    for(;;){
        print_msg("task id=%d",getpid());
800000ca:	e8 16 01 00 00       	call   800001e5 <getpid>
800000cf:	83 ec 08             	sub    $0x8,%esp
800000d2:	50                   	push   %eax
800000d3:	68 64 01 00 80       	push   $0x80000164
800000d8:	e8 23 01 00 00       	call   80000200 <print_msg>
800000dd:	83 c4 10             	add    $0x10,%esp
        msleep(1000);
800000e0:	83 ec 0c             	sub    $0xc,%esp
800000e3:	68 e8 03 00 00       	push   $0x3e8
800000e8:	e8 ce 00 00 00       	call   800001bb <msleep>
800000ed:	83 c4 10             	add    $0x10,%esp
        print_msg("task id=%d",getpid());
800000f0:	eb d8                	jmp    800000ca <first_task_main+0xb8>
800000f2:	66 69 72 73 74 20    	imul   $0x2074,0x73(%edx),%si
800000f8:	74 61                	je     8000015b <first_task_main+0x149>
800000fa:	73 6b                	jae    80000167 <first_task_main+0x155>
800000fc:	20 69 64             	and    %ch,0x64(%ecx)
800000ff:	3d 25 64 00 63       	cmp    $0x63006425,%eax
80000104:	72 65                	jb     8000016b <first_task_main+0x159>
80000106:	61                   	popa   
80000107:	74 65                	je     8000016e <first_task_main+0x15c>
80000109:	20 63 68             	and    %ah,0x68(%ebx)
8000010c:	69 6c 64 20 70 72 6f 	imul   $0x636f7270,0x20(%esp,%eiz,2),%ebp
80000113:	63 
80000114:	20 66 61             	and    %ah,0x61(%esi)
80000117:	69 6c 65 64 2e 0a 00 	imul   $0x63000a2e,0x64(%ebp,%eiz,2),%ebp
8000011e:	63 
8000011f:	68 69 6c 64 3a       	push   $0x3a646c69
80000124:	20 25 64 0a 00 61    	and    %ah,0x61000a64
8000012a:	72 67                	jb     80000193 <sys_call+0x24>
8000012c:	30 00                	xor    %al,(%eax)
8000012e:	61                   	popa   
8000012f:	72 67                	jb     80000198 <sys_call+0x29>
80000131:	31 00                	xor    %eax,(%eax)
80000133:	61                   	popa   
80000134:	72 67                	jb     8000019d <sys_call+0x2e>
80000136:	32 00                	xor    (%eax),%al
80000138:	61                   	popa   
80000139:	72 67                	jb     800001a2 <sys_call+0x33>
8000013b:	33 00                	xor    (%eax),%eax
8000013d:	2f                   	das    
8000013e:	73 68                	jae    800001a8 <sys_call+0x39>
80000140:	65 6c                	gs insb (%dx),%es:(%edi)
80000142:	6c                   	insb   (%dx),%es:(%edi)
80000143:	2e 65 6c             	cs gs insb (%dx),%es:(%edi)
80000146:	66 00 63 68          	data16 add %ah,0x68(%ebx)
8000014a:	69 6c 64 20 74 61 73 	imul   $0x6b736174,0x20(%esp,%eiz,2),%ebp
80000151:	6b 
80000152:	20 69 64             	and    %ch,0x64(%ecx)
80000155:	3d 25 64 00 70       	cmp    $0x70006425,%eax
8000015a:	61                   	popa   
8000015b:	72 65                	jb     800001c2 <msleep+0x7>
8000015d:	6e                   	outsb  %ds:(%esi),(%dx)
8000015e:	74 3a                	je     8000019a <sys_call+0x2b>
80000160:	20 25 64 00 74 61    	and    %ah,0x61740064
80000166:	73 6b                	jae    800001d3 <msleep+0x18>
80000168:	20 69 64             	and    %ch,0x64(%ecx)
8000016b:	3d                   	.byte 0x3d
8000016c:	25                   	.byte 0x25
8000016d:	64                   	fs
	...

8000016f <sys_call>:
#include "lib_syscall.h"
#include "comm/types.h"
#include "core/syscall.h"
#include "os_cfg.h"

static inline int sys_call(syscall_args_t*args){
8000016f:	55                   	push   %ebp
80000170:	89 e5                	mov    %esp,%ebp
80000172:	57                   	push   %edi
80000173:	56                   	push   %esi
80000174:	53                   	push   %ebx
80000175:	83 ec 10             	sub    $0x10,%esp
    uint32_t addr[]={0,SELECTOR_SYSCALL | 0};
80000178:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
8000017f:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%ebp)
        "push %[arg0]\n\t"
        "push %[id]\n\t"
        "lcall *(%[a])"
        :"=a"(ret)
        :[a]"r"(addr),
         [arg3]"r"(args->arg3),
80000186:	8b 45 08             	mov    0x8(%ebp),%eax
80000189:	8b 50 10             	mov    0x10(%eax),%edx
         [arg2]"r"(args->arg2),
8000018c:	8b 45 08             	mov    0x8(%ebp),%eax
8000018f:	8b 48 0c             	mov    0xc(%eax),%ecx
         [arg1]"r"(args->arg1),
80000192:	8b 45 08             	mov    0x8(%ebp),%eax
80000195:	8b 58 08             	mov    0x8(%eax),%ebx
         [arg0]"r"(args->arg0),
80000198:	8b 45 08             	mov    0x8(%ebp),%eax
8000019b:	8b 70 04             	mov    0x4(%eax),%esi
         [id]"r"(args->id)
8000019e:	8b 45 08             	mov    0x8(%ebp),%eax
800001a1:	8b 38                	mov    (%eax),%edi
    __asm__ __volatile__(
800001a3:	8d 45 e8             	lea    -0x18(%ebp),%eax
800001a6:	52                   	push   %edx
800001a7:	51                   	push   %ecx
800001a8:	53                   	push   %ebx
800001a9:	56                   	push   %esi
800001aa:	57                   	push   %edi
800001ab:	ff 18                	lcall  *(%eax)
800001ad:	89 45 f0             	mov    %eax,-0x10(%ebp)
    );
    return ret;
800001b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
800001b3:	83 c4 10             	add    $0x10,%esp
800001b6:	5b                   	pop    %ebx
800001b7:	5e                   	pop    %esi
800001b8:	5f                   	pop    %edi
800001b9:	5d                   	pop    %ebp
800001ba:	c3                   	ret    

800001bb <msleep>:

void msleep(int ms){
800001bb:	55                   	push   %ebp
800001bc:	89 e5                	mov    %esp,%ebp
800001be:	83 ec 20             	sub    $0x20,%esp
    if(ms<=0){
800001c1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
800001c5:	7e 1b                	jle    800001e2 <msleep+0x27>
        return;
    }

    syscall_args_t args;
    args.id=SYS_SLEEP;
800001c7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    args.arg0=ms;
800001ce:	8b 45 08             	mov    0x8(%ebp),%eax
800001d1:	89 45 f0             	mov    %eax,-0x10(%ebp)

    sys_call(&args);
800001d4:	8d 45 ec             	lea    -0x14(%ebp),%eax
800001d7:	50                   	push   %eax
800001d8:	e8 92 ff ff ff       	call   8000016f <sys_call>
800001dd:	83 c4 04             	add    $0x4,%esp
800001e0:	eb 01                	jmp    800001e3 <msleep+0x28>
        return;
800001e2:	90                   	nop
}
800001e3:	c9                   	leave  
800001e4:	c3                   	ret    

800001e5 <getpid>:

int getpid(void){
800001e5:	55                   	push   %ebp
800001e6:	89 e5                	mov    %esp,%ebp
800001e8:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_GETPID;
800001eb:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
    return sys_call(&args);
800001f2:	8d 45 ec             	lea    -0x14(%ebp),%eax
800001f5:	50                   	push   %eax
800001f6:	e8 74 ff ff ff       	call   8000016f <sys_call>
800001fb:	83 c4 04             	add    $0x4,%esp
}
800001fe:	c9                   	leave  
800001ff:	c3                   	ret    

80000200 <print_msg>:

void print_msg(const char* fmt,int arg){
80000200:	55                   	push   %ebp
80000201:	89 e5                	mov    %esp,%ebp
80000203:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_PRINT_MSG;
80000206:	c7 45 ec 64 00 00 00 	movl   $0x64,-0x14(%ebp)
    args.arg0=(uint32_t)fmt;
8000020d:	8b 45 08             	mov    0x8(%ebp),%eax
80000210:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=arg;
80000213:	8b 45 0c             	mov    0xc(%ebp),%eax
80000216:	89 45 f4             	mov    %eax,-0xc(%ebp)
    sys_call(&args);
80000219:	8d 45 ec             	lea    -0x14(%ebp),%eax
8000021c:	50                   	push   %eax
8000021d:	e8 4d ff ff ff       	call   8000016f <sys_call>
80000222:	83 c4 04             	add    $0x4,%esp
}
80000225:	90                   	nop
80000226:	c9                   	leave  
80000227:	c3                   	ret    

80000228 <fork>:

int fork(void){
80000228:	55                   	push   %ebp
80000229:	89 e5                	mov    %esp,%ebp
8000022b:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_FORK;
8000022e:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
    return sys_call(&args);
80000235:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000238:	50                   	push   %eax
80000239:	e8 31 ff ff ff       	call   8000016f <sys_call>
8000023e:	83 c4 04             	add    $0x4,%esp
}
80000241:	c9                   	leave  
80000242:	c3                   	ret    

80000243 <execve>:

int execve(const char* name,char* const* argv,char* const* env){
80000243:	55                   	push   %ebp
80000244:	89 e5                	mov    %esp,%ebp
80000246:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_EXECVE;
80000249:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%ebp)
    args.arg0=(int)name;
80000250:	8b 45 08             	mov    0x8(%ebp),%eax
80000253:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=(int)argv;
80000256:	8b 45 0c             	mov    0xc(%ebp),%eax
80000259:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2=(int)env;
8000025c:	8b 45 10             	mov    0x10(%ebp),%eax
8000025f:	89 45 f8             	mov    %eax,-0x8(%ebp)

    sys_call(&args);
80000262:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000265:	50                   	push   %eax
80000266:	e8 04 ff ff ff       	call   8000016f <sys_call>
8000026b:	83 c4 04             	add    $0x4,%esp
}
8000026e:	90                   	nop
8000026f:	c9                   	leave  
80000270:	c3                   	ret    

80000271 <yield>:

int yield(void){
80000271:	55                   	push   %ebp
80000272:	89 e5                	mov    %esp,%ebp
80000274:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_YIELD;
80000277:	c7 45 ec 04 00 00 00 	movl   $0x4,-0x14(%ebp)

    return sys_call(&args);
8000027e:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000281:	50                   	push   %eax
80000282:	e8 e8 fe ff ff       	call   8000016f <sys_call>
80000287:	83 c4 04             	add    $0x4,%esp
}
8000028a:	c9                   	leave  
8000028b:	c3                   	ret    

8000028c <open>:

int open(const char*name,int flags, ...){
8000028c:	55                   	push   %ebp
8000028d:	89 e5                	mov    %esp,%ebp
8000028f:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_OPEN;
80000292:	c7 45 ec 32 00 00 00 	movl   $0x32,-0x14(%ebp)
    args.arg0=(int)name;
80000299:	8b 45 08             	mov    0x8(%ebp),%eax
8000029c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=(int)flags;
8000029f:	8b 45 0c             	mov    0xc(%ebp),%eax
800002a2:	89 45 f4             	mov    %eax,-0xc(%ebp)

    return sys_call(&args);
800002a5:	8d 45 ec             	lea    -0x14(%ebp),%eax
800002a8:	50                   	push   %eax
800002a9:	e8 c1 fe ff ff       	call   8000016f <sys_call>
800002ae:	83 c4 04             	add    $0x4,%esp
}
800002b1:	c9                   	leave  
800002b2:	c3                   	ret    

800002b3 <read>:

int read(int file,char* ptr,int len){
800002b3:	55                   	push   %ebp
800002b4:	89 e5                	mov    %esp,%ebp
800002b6:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_READ;
800002b9:	c7 45 ec 33 00 00 00 	movl   $0x33,-0x14(%ebp)
    args.arg0=(int)file;
800002c0:	8b 45 08             	mov    0x8(%ebp),%eax
800002c3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=(int)ptr;
800002c6:	8b 45 0c             	mov    0xc(%ebp),%eax
800002c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2=(int)len;
800002cc:	8b 45 10             	mov    0x10(%ebp),%eax
800002cf:	89 45 f8             	mov    %eax,-0x8(%ebp)

    return sys_call(&args);
800002d2:	8d 45 ec             	lea    -0x14(%ebp),%eax
800002d5:	50                   	push   %eax
800002d6:	e8 94 fe ff ff       	call   8000016f <sys_call>
800002db:	83 c4 04             	add    $0x4,%esp
}
800002de:	c9                   	leave  
800002df:	c3                   	ret    

800002e0 <write>:

int write(int file,char*ptr,int len){
800002e0:	55                   	push   %ebp
800002e1:	89 e5                	mov    %esp,%ebp
800002e3:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_WRITE;
800002e6:	c7 45 ec 34 00 00 00 	movl   $0x34,-0x14(%ebp)
    args.arg0=(int)file;
800002ed:	8b 45 08             	mov    0x8(%ebp),%eax
800002f0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=(int)ptr;
800002f3:	8b 45 0c             	mov    0xc(%ebp),%eax
800002f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2=(int)len;
800002f9:	8b 45 10             	mov    0x10(%ebp),%eax
800002fc:	89 45 f8             	mov    %eax,-0x8(%ebp)

    return sys_call(&args);
800002ff:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000302:	50                   	push   %eax
80000303:	e8 67 fe ff ff       	call   8000016f <sys_call>
80000308:	83 c4 04             	add    $0x4,%esp
}
8000030b:	c9                   	leave  
8000030c:	c3                   	ret    

8000030d <close>:

int close(int file){
8000030d:	55                   	push   %ebp
8000030e:	89 e5                	mov    %esp,%ebp
80000310:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_CLOSE;
80000313:	c7 45 ec 35 00 00 00 	movl   $0x35,-0x14(%ebp)
    args.arg0=(int)file;
8000031a:	8b 45 08             	mov    0x8(%ebp),%eax
8000031d:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return sys_call(&args);
80000320:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000323:	50                   	push   %eax
80000324:	e8 46 fe ff ff       	call   8000016f <sys_call>
80000329:	83 c4 04             	add    $0x4,%esp
}
8000032c:	c9                   	leave  
8000032d:	c3                   	ret    

8000032e <lseek>:

int lseek(int file,int ptr,int dir){
8000032e:	55                   	push   %ebp
8000032f:	89 e5                	mov    %esp,%ebp
80000331:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_LSEEK;
80000334:	c7 45 ec 36 00 00 00 	movl   $0x36,-0x14(%ebp)
    args.arg0=(int)file;
8000033b:	8b 45 08             	mov    0x8(%ebp),%eax
8000033e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=(int)ptr;
80000341:	8b 45 0c             	mov    0xc(%ebp),%eax
80000344:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2=(int)dir;
80000347:	8b 45 10             	mov    0x10(%ebp),%eax
8000034a:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return sys_call(&args);
8000034d:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000350:	50                   	push   %eax
80000351:	e8 19 fe ff ff       	call   8000016f <sys_call>
80000356:	83 c4 04             	add    $0x4,%esp
}
80000359:	c9                   	leave  
8000035a:	c3                   	ret    

8000035b <isatty>:

int isatty(int file){
8000035b:	55                   	push   %ebp
8000035c:	89 e5                	mov    %esp,%ebp
8000035e:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_ISATTY;
80000361:	c7 45 ec 37 00 00 00 	movl   $0x37,-0x14(%ebp)
    args.arg0=(int)file;
80000368:	8b 45 08             	mov    0x8(%ebp),%eax
8000036b:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return sys_call(&args);
8000036e:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000371:	50                   	push   %eax
80000372:	e8 f8 fd ff ff       	call   8000016f <sys_call>
80000377:	83 c4 04             	add    $0x4,%esp
}
8000037a:	c9                   	leave  
8000037b:	c3                   	ret    

8000037c <fstat>:

int fstat(int file,struct stat* st){
8000037c:	55                   	push   %ebp
8000037d:	89 e5                	mov    %esp,%ebp
8000037f:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_FSTAT;
80000382:	c7 45 ec 39 00 00 00 	movl   $0x39,-0x14(%ebp)
    args.arg0=(int)file;
80000389:	8b 45 08             	mov    0x8(%ebp),%eax
8000038c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=(int)st;
8000038f:	8b 45 0c             	mov    0xc(%ebp),%eax
80000392:	89 45 f4             	mov    %eax,-0xc(%ebp)

    return sys_call(&args);
80000395:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000398:	50                   	push   %eax
80000399:	e8 d1 fd ff ff       	call   8000016f <sys_call>
8000039e:	83 c4 04             	add    $0x4,%esp
}
800003a1:	c9                   	leave  
800003a2:	c3                   	ret    

800003a3 <sbrk>:

void* sbrk(ptrdiff_t incr){
800003a3:	55                   	push   %ebp
800003a4:	89 e5                	mov    %esp,%ebp
800003a6:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_SBRK;
800003a9:	c7 45 ec 38 00 00 00 	movl   $0x38,-0x14(%ebp)
    args.arg0=(int)incr;
800003b0:	8b 45 08             	mov    0x8(%ebp),%eax
800003b3:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return (void*)sys_call(&args);
800003b6:	8d 45 ec             	lea    -0x14(%ebp),%eax
800003b9:	50                   	push   %eax
800003ba:	e8 b0 fd ff ff       	call   8000016f <sys_call>
800003bf:	83 c4 04             	add    $0x4,%esp
800003c2:	c9                   	leave  
800003c3:	c3                   	ret    
