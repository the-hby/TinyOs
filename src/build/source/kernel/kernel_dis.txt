
E:/CppProject/TinyOs/src/build/source/kernel/kernel.elf:     file format elf32-i386
E:/CppProject/TinyOs/src/build/source/kernel/kernel.elf
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00010000

Program Header:
    LOAD off    0x00001000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x00006560 memsz 0x00006560 flags r-x
    LOAD off    0x00008000 vaddr 0x00017000 paddr 0x00017000 align 2**12
         filesz 0x0000009c memsz 0x000553e0 flags rw-
    LOAD off    0x00009000 vaddr 0x80000000 paddr 0x0006c3e0 align 2**12
         filesz 0x00000344 memsz 0x00000344 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000058c8  00010000  00010000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00000c80  000158e0  000158e0  000068e0  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         0000009c  00017000  00017000  00008000  2**5
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          000543e0  00018000  00018000  0000809c  2**12
                  ALLOC
  4 .first_task   00000344  80000000  0006c3e0  00009000  2**0
                  CONTENTS, ALLOC, LOAD, CODE
  5 .debug_line   00003218  00000000  00000000  00009344  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000bbe5  00000000  00000000  0000c55c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002738  00000000  00000000  00018141  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 000002e0  00000000  00000000  0001a880  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_ranges 000000a8  00000000  00000000  0001ab60  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000021ab  00000000  00000000  0001ac08  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      00000011  00000000  00000000  0001cdb3  2**0
                  CONTENTS, READONLY
 12 .debug_frame  000021e8  00000000  00000000  0001cdc4  2**2
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
000158e0 l    d  .rodata	00000000 .rodata
00017000 l    d  .data	00000000 .data
00018000 l    d  .bss	00000000 .bss
80000000 l    d  .first_task	00000000 .first_task
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 CMakeFiles/kernel.dir/init/start.S.obj
00010013 l       .text	00000000 gdt_reload
00000000 l    df *ABS*	00000000 memory.c
000102e5 l     F .text	00000011 read_cr0
000102f6 l     F .text	0000000c write_cr0
00010302 l     F .text	0000000c write_cr3
0001030e l     F .text	0000000c write_cr4
0001031a l     F .text	00000011 read_cr4
0001032b l     F .text	0000000d down2
00010338 l     F .text	00000017 up2
0001034f l     F .text	0000003e mmu_set_page_dir
0001038d l     F .text	0000000b pde_index
00010398 l     F .text	00000010 pte_index
000103a8 l     F .text	00000010 pde_paddr
000103b8 l     F .text	00000010 pte_paddr
000103c8 l     F .text	0000000f get_pte_perm
00018000 l     O .bss	00000028 paddr_alloc
00019000 l     O .bss	00001000 kernel_page_dir
000103d7 l     F .text	00000058 addr_alloc_init
0001042f l     F .text	00000067 addr_alloc_page
00010496 l     F .text	00000062 addr_free_page
000104f8 l     F .text	00000037 total_mem_size
000159f8 l     O .rodata	00000012 __func__.2522
00017000 l     O .data	00000050 kernel_map.2533
00015a0c l     O .rodata	0000000c __func__.2553
00010946 l     F .text	00000013 curr_page_dir
00015a18 l     O .rodata	00000011 __func__.2594
00015a2c l     O .rodata	00000009 __func__.2654
00000000 l    df *ABS*	00000000 syscall.c
00015a40 l     O .rodata	00000194 sys_table
00000000 l    df *ABS*	00000000 task.c
00010eab l     F .text	00000011 read_cr0
00010ebc l     F .text	0000000c write_cr0
00010ec8 l     F .text	00000007 hlt
00010ecf l     F .text	00000017 write_tr
00010ee6 l     F .text	0000000c write_cr3
00010ef2 l     F .text	0000000c write_cr4
00010efe l     F .text	00000011 read_cr4
00010f0f l     F .text	0000001b list_node_init
00010f2a l     F .text	0000000b list_node_next
00010f35 l     F .text	0000000b list_count
00010f40 l     F .text	0000000a list_first
00010f4a l     F .text	0000003e mmu_set_page_dir
0001a000 l     O .bss	000005b8 task_manager
0001a5c0 l     O .bss	00001000 idle_task_stack
0001b5c0 l     O .bss	00016200 task_table
000317c0 l     O .bss	00000014 table_mutex
00010f88 l     F .text	0000019b tss_init
00015d18 l     O .rodata	0000000a __func__.2846
00011340 l     F .text	0000000a idle_task_entry
00015d24 l     O .rodata	00000010 __func__.2877
00011859 l     F .text	00000068 alloc_task
000118c1 l     F .text	00000033 free_task
00011a65 l     F .text	000000fe load_phdr
00011b63 l     F .text	000001be load_elf_file
00011d21 l     F .text	000000f3 copy_args
00015d34 l     O .rodata	0000000a __func__.2999
00000000 l    df *ABS*	00000000 cpu.c
0001206b l     F .text	00000028 lgdt
00012093 l     F .text	0000001a far_jump
000317e0 l     O .bss	00000800 gdt_table
00031fe0 l     O .bss	00000014 mutex
00000000 l    df *ABS*	00000000 irq.c
000122e2 l     F .text	00000007 cli
000122e9 l     F .text	00000007 sti
000122f0 l     F .text	0000001d inb
0001230d l     F .text	0000001f outb
0001232c l     F .text	00000028 lidt
00012354 l     F .text	00000007 hlt
0001235b l     F .text	00000010 read_eflags
0001236b l     F .text	0000000b write_eflags
00012376 l     F .text	00000011 read_cr2
00012387 l     F .text	00000093 init_pic
00032000 l     O .bss	00000400 idt_table
0001272a l     F .text	000000f8 dump_core_regs
00012822 l     F .text	0000003f do_default_handler
00000000 l    df *ABS*	00000000 console.c
00012c36 l     F .text	0000001d inb
00012c53 l     F .text	0000001f outb
00032400 l     O .bss	000002a0 console_buf
000326a0 l     O .bss	00000004 curr_console_idx
00012c72 l     F .text	00000074 read_cursor_pos
00012ce6 l     F .text	000000ba update_cursor_pos
00012da0 l     F .text	00000093 erase_rows
00012e33 l     F .text	00000089 scroll_up
00012ebc l     F .text	00000086 clear_display
00012f42 l     F .text	00000010 move_to_col0
00012f52 l     F .text	00000038 move_next_line
00012f8a l     F .text	00000076 move_forward
00013000 l     F .text	00000078 move_backword
00013149 l     F .text	00000095 show_char
000131de l     F .text	0000003a erase_backword
00013218 l     F .text	0000001e save_cursor
00013236 l     F .text	0000001e restore_cursor
00013254 l     F .text	00000029 clear_esc_param
0001327d l     F .text	00000071 write_esc
000132ee l     F .text	00000099 set_font_style
00016300 l     O .rodata	00000020 color_table.2432
00013387 l     F .text	00000051 erase_in_display
000133d8 l     F .text	0000001e move_cursor
000133f6 l     F .text	00000037 move_left
0001342d l     F .text	00000049 move_right
00013476 l     F .text	000000f4 write_esc_square
0001356a l     F .text	000000a2 write_normal
00000000 l    df *ABS*	00000000 dev.c
00017050 l     O .data	00000004 dev_desc_tbl
000326c0 l     O .bss	00000a00 dev_tb
000137b1 l     F .text	0000003c is_devid_bad
00000000 l    df *ABS*	00000000 kbd.c
00013aa5 l     F .text	0000001d inb
000330c0 l     O .bss	00000004 kbd_stat
00016320 l     O .rodata	00000074 map_table
000330c4 l     O .bss	00000004 inited.2306
00013b11 l     F .text	0000001a is_make_code
00013b2b l     F .text	00000015 get_key
00013b40 l     F .text	0000003c do_fx_key
00013b7c l     F .text	000001d3 do_normal_key
000330c8 l     O .bss	00000004 recv_state.2353
00000000 l    df *ABS*	00000000 time.c
00013e73 l     F .text	0000001f outb
000330cc l     O .bss	00000004 sys_tick
00013eba l     F .text	00000060 init_pit
00000000 l    df *ABS*	00000000 tty.c
000330e0 l     O .bss	000022a0 tty_devs
00035380 l     O .bss	00000004 curr_tty
00013f32 l     F .text	0000004f get_tty
00000000 l    df *ABS*	00000000 file.c
000353a0 l     O .bss	0001c000 file_table
000513a0 l     O .bss	00000014 file_alloc_mutex
00000000 l    df *ABS*	00000000 fs.c
0001456f l     F .text	0000001d inb
0001458c l     F .text	0000001f inw
000145ab l     F .text	0000001f outb
000513c0 l     O .bss	00019000 TEMP_ADDR
0006a3c0 l     O .bss	00000004 temp_pos
000145ca l     F .text	0000012f read_disk
000146f9 l     F .text	00000021 is_path_valid
00000000 l    df *ABS*	00000000 init.c
000164fc l     O .rodata	00000013 __func__.2915
00000000 l    df *ABS*	00000000 mutex.c
00014aec l     F .text	0000000b list_count
00000000 l    df *ABS*	00000000 sem.c
00014c73 l     F .text	0000000b list_count
00000000 l    df *ABS*	00000000 bitmap.c
00000000 l    df *ABS*	00000000 kilb.c
0001502d l     F .text	00000007 hlt
00017098 l     O .data	00000004 num2ch.2085
00000000 l    df *ABS*	00000000 list.c
000155eb l     F .text	00000013 list_is_empty
00000000 l    df *ABS*	00000000 log.c
0006a3c4 l     O .bss	00000014 mutex
0006a3d8 l     O .bss	00000004 log_dev_id
00000000 l    df *ABS*	00000000 first_task.c
00000000 l    df *ABS*	00000000 lib_syscall.c
800000ce l     F .first_task	0000004c sys_call
00014e25 g     F .text	0000004f bitmap_get_bit
000151a0 g     F .text	0000004f kernel_memcpy
00014972 g     F .text	0000000a sys_close
000115cf g     F .text	0000000a task_current
800001d0 g     F .first_task	0000001b yield
00012425 g     F .text	0000000b irq_enable_global
00015682 g     F .text	00000064 list_insert_last
00011fc3 g     F .text	00000031 task_file
000102a8 g       .text	00000000 exception_handler_kbd
00010cf6 g     F .text	0000010c sys_sbrk
000117df g     F .text	00000064 sys_msleep
00012995 g     F .text	0000001c do_handler_segment_not_present
00011527 g     F .text	00000036 task_set_ready
00014f5f g     F .text	0000001b bitmap_is_set
000151ef g     F .text	00000041 kernel_memset
00013989 g     F .text	0000004c dev_write
0001494e g     F .text	00000024 sys_lseek
00013ac2 g     F .text	0000004f kbd_init
0001026a g       .text	00000000 exception_handler_virtual_exception
00010e1c g     F .text	0000008f do_handler_syscall
00012205 g     F .text	0000001e cpu_init
000157e3 g     F .text	0000002f log_init
000118f4 g     F .text	00000171 sys_fork
00014ac2 g     F .text	0000002a init_main
0001020f g       .text	00000000 exception_handler_alignment_check
000122ac g     F .text	00000036 gdt_free_sel
00010e02 g     F .text	0000001a sys_print_msg
00015034 g     F .text	00000047 kernel_strcpy
00013d4f g     F .text	00000064 do_e0_key
00017000 g       .data	00000000 s_data
800001a2 g     F .first_task	0000002e execve
80000144 g     F .first_task	0000001b getpid
00012430 g     F .text	0000008b irq_enable
0001002b g       .text	00000000 exception_handler_unknown
000100a7 g       .text	00000000 exception_handler_breakpoint
000128ed g     F .text	0000001c do_handler_overflow
00012b72 g     F .text	0000001c do_handler_alignment_check
000105df g     F .text	0000009d memory_create_map
0001487a g     F .text	00000087 sys_read
000136f9 g     F .text	000000b8 console_select
000101b6 g       .text	00000000 exception_handler_general_protection
000129cd g     F .text	000000b5 do_handler_general_protection
00014d93 g     F .text	00000029 sem_count
80000012 g     F .first_task	0000009c first_task_main
0001287d g     F .text	0000001c do_handler_divider
00014e74 g     F .text	000000eb bitmap_set_bit
0001295d g     F .text	0000001c do_handler_double_fault
00012a82 g     F .text	000000d4 do_handler_page_fault
800002ba g     F .first_task	00000021 isatty
00010142 g       .text	00000000 exception_handler_double_fault
00012be2 g     F .text	0000002b pic_send_eoi
0001151d g     F .text	0000000a task_first_task
00010000 g       .text	00000000 s_text
000107c8 g     F .text	00000085 memory_create_uvm
00014ca1 g     F .text	0000006e sem_wait
00010901 g     F .text	00000025 memory_alloc_page_for
00010199 g       .text	00000000 exception_handler_stack_segment_fault
80000000 g       .first_task	00000000 first_task_entry
00014986 g     F .text	0000000a sys_fstat
0001393d g     F .text	0000004c dev_read
00012bc6 g     F .text	0000001c do_handler_virtual_exception
000100c6 g       .text	00000000 exception_handler_overflow
8000028d g     F .first_task	0000002d lseek
00010289 g       .text	00000000 exception_handler_time
0006a3e0 g     O .bss	00002000 stack
00014990 g     F .text	0000000e fs_init
00010959 g     F .text	00000099 memory_free_page
0006c3e0 g       *ABS*	00000000 s_first_task
00012045 g     F .text	00000026 task_remove_fd
000143d3 g     F .text	0000000a tty_control
00013078 g     F .text	000000d1 console_init
000141cf g     F .text	00000107 tty_read
0001129c g     F .text	00000086 task_uninit
0001084d g     F .text	000000b4 memory_alloc_for_page_dir
00014042 g     F .text	0000008d tty_fifo_get
000100e5 g       .text	00000000 exception_handler_bound_range
000143e3 g     F .text	0000006d tty_in
00014d0f g     F .text	00000084 sem_notify
00010c74 g     F .text	00000082 memory_copy_uvm_data
000139d5 g     F .text	0000004c dev_control
00013db3 g     F .text	000000c0 do_handler_kbd
00012925 g     F .text	0000001c do_handler_invalid_opcode
0001015f g       .text	00000000 exception_handler_invalid_tss
00012b56 g     F .text	0000001c do_handler_fpu_error
00011431 g     F .text	000000ec task_first_init
00012b8e g     F .text	0000001c do_handler_machine_check
8000023f g     F .first_task	0000002d write
0001471a g     F .text	00000160 sys_open
00012899 g     F .text	0000001c do_handler_Debug
800002db g     F .first_task	00000027 fstat
0001497c g     F .text	0000000a sys_isatty
00015623 g     F .text	0000005f list_insert_first
000137ed g     F .text	00000150 dev_open
000117bd g     F .text	00000022 task_set_wakeup
000128b5 g     F .text	0000001c do_handler_NMI
0001004a g       .text	00000000 exception_handler_divider
00013f81 g     F .text	00000037 tty_fifo_init
0001507b g     F .text	00000070 kernel_strncpy
0001241a g     F .text	0000000b irq_disable_global
000115d9 g     F .text	00000061 sys_sched_yield
00014901 g     F .text	0000004d sys_write
0006c724 g       *ABS*	00000000 mem_free_start
00014a27 g     F .text	00000035 kernel_init
00014c7e g     F .text	00000023 sem_init
00010000 g       .text	00000000 _start
000153f7 g     F .text	0000014b kernel_vsprintf
000155a5 g     F .text	00000046 get_file_name
00010123 g       .text	00000000 exception_handler_device_unavailable
00010104 g       .text	00000000 exception_handler_invalid_opcode
00013a21 g     F .text	00000084 dev_close
0006c3e0 g       .bss	00000000 e_data
80000212 g     F .first_task	0000002d read
00014b25 g     F .text	0000008f mutex_lock
00011ff4 g     F .text	00000051 task_alloc_fd
00015578 g     F .text	0000002d string_count
0001022c g       .text	00000000 exception_handler_machine_check
000142d6 g     F .text	000000fd tty_write
00012979 g     F .text	0000001c do_handler_invalid_tss
00000000 g       .text	00000000 kernel_base
00013fb8 g     F .text	0000008a tty_fifo_put
0006c724 g       *ABS*	00000000 e_first_task
00011781 g     F .text	0000003c task_set_sleep
0001499e g     F .text	00000089 sys_dup
00015542 g     F .text	00000036 panic
000126f0 g     F .text	0000003a irq_install
00012133 g     F .text	0000008b init_gdt
000140cf g     F .text	00000100 tty_open
80000187 g     F .first_task	0000001b fork
00012c0d g     F .text	00000018 irq_enter_protection
00014af7 g     F .text	0000002e mutex_init
000124bb g     F .text	00000087 irq_disable
80000302 g     F .first_task	00000021 sbrk
0001024b g       .text	00000000 exception_handler_smd_exception
000109f2 g     F .text	000000e7 memory_destroy_uvm
00014dbc g     F .text	00000016 bitmap_byte_count
00012941 g     F .text	0000001c do_handler_device_unavailable
0001163a g     F .text	0000005b task_dispatch
00010ad9 g     F .text	00000155 memory_copy_uvm
000143dd g     F .text	00000006 tty_close
00014a5c g     F .text	00000066 move_to_first_task
00012298 g     F .text	00000014 switch_to_tss
0001360c g     F .text	000000e7 console_write
80000323 g     F .first_task	00000021 dup
0001158a g     F .text	00000045 task_next_run
00015230 g     F .text	00000064 kernel_memcmp
0001067c g     F .text	000000a7 create_kernel_table
000155fe g     F .text	00000025 list_init
00012baa g     F .text	0000001c do_handler_smd_exception
000101d3 g       .text	00000000 exception_handler_page_fault
0001155d g     F .text	0000002d task_set_block
00012861 g     F .text	0000001c do_handler_unknown
00010926 g     F .text	00000020 memory_alloc_page
000101f0 g       .text	00000000 exception_handler_fpu_error
00011322 g     F .text	0000001e task_switch_from_to
00012542 g     F .text	000001ae irq_init
00014bb4 g     F .text	000000bf mutex_unlock
0001453f g     F .text	00000030 file_table_init
00012c25 g     F .text	00000011 irq_leave_protection
000144fd g     F .text	00000042 file_free
8000015f g     F .first_task	00000028 print_msg
00015165 g     F .text	0000003b kernel_strlen
000120ad g     F .text	00000086 segment_desc_set
00012909 g     F .text	0000001c do_handler_bound_range
000102c7 g       .text	00000000 exception_handler_syscall
000156e6 g     F .text	00000078 list_remove_first
00016560 g       .rodata	00000000 e_text
000150eb g     F .text	0000007a kernel_strncmp
00014dd2 g     F .text	00000053 bitmap_init
0001017c g       .text	00000000 exception_handler_segment_not_present
00010088 g       .text	00000000 exception_handler_NMI
00014f7a g     F .text	000000b3 bitmap_alloc_nbits
00014479 g     F .text	00000084 file_alloc
0001134a g     F .text	000000e7 task_manager_init
0001126f g     F .text	0000002d task_start
00010069 g       .text	00000000 exception_handler_Debug
00011695 g     F .text	000000ec task_time_tick
00010723 g     F .text	000000a5 memory_init
00011e14 g     F .text	000001af sys_execve
00014450 g     F .text	00000029 tty_select
000136f3 g     F .text	00000006 console_close
00010c2e g     F .text	00000046 memory_get_paddr
000129b1 g     F .text	0000001c do_handler_stack_segment_fault
000128d1 g     F .text	0000001c do_handler_breakpoint
00015812 g     F .text	000000b6 log_printf
00011123 g     F .text	0000014c task_init
800001eb g     F .first_task	00000027 open
00015294 g     F .text	00000024 kernel_sprintf
00011843 g     F .text	00000016 sys_getpid
00012223 g     F .text	00000075 gdt_alloc_desc
000152b8 g     F .text	0000013f kernel_itoa
0001575e g     F .text	00000085 list_remove
000121be g     F .text	00000047 gate_desc_set
8000011a g     F .first_task	0000002a msleep
8000026c g     F .first_task	00000021 close
0001052f g     F .text	000000b0 find_pte
00013e92 g     F .text	00000028 do_handler_time
00013f1a g     F .text	00000018 time_init
00017060 g     O .data	00000038 dev_tty_desc



Disassembly of section .text:

00010000 <_start>:
_start:
    // 从栈中取出参数,参数保存在%eax中,最终传递给kernel_init函数
    // 参数位于load_32.c中
    // 以下三步可以简写为: mov 4(%esp),%eax
    // 传递的是boot_info
    push %ebp
   10000:	55                   	push   %ebp
    mov %esp,%ebp
   10001:	89 e5                	mov    %esp,%ebp
    mov 0x8(%ebp),%eax
   10003:	8b 45 08             	mov    0x8(%ebp),%eax
    
    push %eax
   10006:	50                   	push   %eax

    // kernel_init 位于init.c中
    call kernel_init
   10007:	e8 1b 4a 00 00       	call   14a27 <kernel_init>

    // 加载到对应选择子以及偏移量
    jmp $KERNEL_SELECTOR_CS,$gdt_reload
   1000c:	ea 13 00 01 00 08 00 	ljmp   $0x8,$0x10013

00010013 <gdt_reload>:
gdt_reload:
    // 初始化寄存器
    mov $KERNEL_SELECTOR_DS,%ax
   10013:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
   10017:	8e d8                	mov    %eax,%ds
	mov %ax, %ss
   10019:	8e d0                	mov    %eax,%ss
	mov %ax, %es
   1001b:	8e c0                	mov    %eax,%es
	mov %ax, %fs
   1001d:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
   1001f:	8e e8                	mov    %eax,%gs
    mov $(stack+KERNEL_STACK_SIZE),%esp
   10021:	bc e0 c3 06 00       	mov    $0x6c3e0,%esp
    jmp init_main
   10026:	e9 97 4a 00 00       	jmp    14ac2 <init_main>

0001002b <exception_handler_unknown>:
    iret

// 宏的结束
.endm

exception_handler unknown,-1,0
   1002b:	6a 00                	push   $0x0
   1002d:	6a ff                	push   $0xffffffff
   1002f:	60                   	pusha  
   10030:	1e                   	push   %ds
   10031:	06                   	push   %es
   10032:	0f a0                	push   %fs
   10034:	0f a8                	push   %gs
   10036:	54                   	push   %esp
   10037:	e8 25 28 00 00       	call   12861 <do_handler_unknown>
   1003c:	83 c4 04             	add    $0x4,%esp
   1003f:	0f a9                	pop    %gs
   10041:	0f a1                	pop    %fs
   10043:	07                   	pop    %es
   10044:	1f                   	pop    %ds
   10045:	61                   	popa   
   10046:	83 c4 08             	add    $0x8,%esp
   10049:	cf                   	iret   

0001004a <exception_handler_divider>:
exception_handler divider,0,0
   1004a:	6a 00                	push   $0x0
   1004c:	6a 00                	push   $0x0
   1004e:	60                   	pusha  
   1004f:	1e                   	push   %ds
   10050:	06                   	push   %es
   10051:	0f a0                	push   %fs
   10053:	0f a8                	push   %gs
   10055:	54                   	push   %esp
   10056:	e8 22 28 00 00       	call   1287d <do_handler_divider>
   1005b:	83 c4 04             	add    $0x4,%esp
   1005e:	0f a9                	pop    %gs
   10060:	0f a1                	pop    %fs
   10062:	07                   	pop    %es
   10063:	1f                   	pop    %ds
   10064:	61                   	popa   
   10065:	83 c4 08             	add    $0x8,%esp
   10068:	cf                   	iret   

00010069 <exception_handler_Debug>:
exception_handler Debug, 1, 0
   10069:	6a 00                	push   $0x0
   1006b:	6a 01                	push   $0x1
   1006d:	60                   	pusha  
   1006e:	1e                   	push   %ds
   1006f:	06                   	push   %es
   10070:	0f a0                	push   %fs
   10072:	0f a8                	push   %gs
   10074:	54                   	push   %esp
   10075:	e8 1f 28 00 00       	call   12899 <do_handler_Debug>
   1007a:	83 c4 04             	add    $0x4,%esp
   1007d:	0f a9                	pop    %gs
   1007f:	0f a1                	pop    %fs
   10081:	07                   	pop    %es
   10082:	1f                   	pop    %ds
   10083:	61                   	popa   
   10084:	83 c4 08             	add    $0x8,%esp
   10087:	cf                   	iret   

00010088 <exception_handler_NMI>:
exception_handler NMI, 2, 0
   10088:	6a 00                	push   $0x0
   1008a:	6a 02                	push   $0x2
   1008c:	60                   	pusha  
   1008d:	1e                   	push   %ds
   1008e:	06                   	push   %es
   1008f:	0f a0                	push   %fs
   10091:	0f a8                	push   %gs
   10093:	54                   	push   %esp
   10094:	e8 1c 28 00 00       	call   128b5 <do_handler_NMI>
   10099:	83 c4 04             	add    $0x4,%esp
   1009c:	0f a9                	pop    %gs
   1009e:	0f a1                	pop    %fs
   100a0:	07                   	pop    %es
   100a1:	1f                   	pop    %ds
   100a2:	61                   	popa   
   100a3:	83 c4 08             	add    $0x8,%esp
   100a6:	cf                   	iret   

000100a7 <exception_handler_breakpoint>:
exception_handler breakpoint, 3, 0
   100a7:	6a 00                	push   $0x0
   100a9:	6a 03                	push   $0x3
   100ab:	60                   	pusha  
   100ac:	1e                   	push   %ds
   100ad:	06                   	push   %es
   100ae:	0f a0                	push   %fs
   100b0:	0f a8                	push   %gs
   100b2:	54                   	push   %esp
   100b3:	e8 19 28 00 00       	call   128d1 <do_handler_breakpoint>
   100b8:	83 c4 04             	add    $0x4,%esp
   100bb:	0f a9                	pop    %gs
   100bd:	0f a1                	pop    %fs
   100bf:	07                   	pop    %es
   100c0:	1f                   	pop    %ds
   100c1:	61                   	popa   
   100c2:	83 c4 08             	add    $0x8,%esp
   100c5:	cf                   	iret   

000100c6 <exception_handler_overflow>:
exception_handler overflow, 4, 0
   100c6:	6a 00                	push   $0x0
   100c8:	6a 04                	push   $0x4
   100ca:	60                   	pusha  
   100cb:	1e                   	push   %ds
   100cc:	06                   	push   %es
   100cd:	0f a0                	push   %fs
   100cf:	0f a8                	push   %gs
   100d1:	54                   	push   %esp
   100d2:	e8 16 28 00 00       	call   128ed <do_handler_overflow>
   100d7:	83 c4 04             	add    $0x4,%esp
   100da:	0f a9                	pop    %gs
   100dc:	0f a1                	pop    %fs
   100de:	07                   	pop    %es
   100df:	1f                   	pop    %ds
   100e0:	61                   	popa   
   100e1:	83 c4 08             	add    $0x8,%esp
   100e4:	cf                   	iret   

000100e5 <exception_handler_bound_range>:
exception_handler bound_range, 5, 0
   100e5:	6a 00                	push   $0x0
   100e7:	6a 05                	push   $0x5
   100e9:	60                   	pusha  
   100ea:	1e                   	push   %ds
   100eb:	06                   	push   %es
   100ec:	0f a0                	push   %fs
   100ee:	0f a8                	push   %gs
   100f0:	54                   	push   %esp
   100f1:	e8 13 28 00 00       	call   12909 <do_handler_bound_range>
   100f6:	83 c4 04             	add    $0x4,%esp
   100f9:	0f a9                	pop    %gs
   100fb:	0f a1                	pop    %fs
   100fd:	07                   	pop    %es
   100fe:	1f                   	pop    %ds
   100ff:	61                   	popa   
   10100:	83 c4 08             	add    $0x8,%esp
   10103:	cf                   	iret   

00010104 <exception_handler_invalid_opcode>:
exception_handler invalid_opcode, 6, 0
   10104:	6a 00                	push   $0x0
   10106:	6a 06                	push   $0x6
   10108:	60                   	pusha  
   10109:	1e                   	push   %ds
   1010a:	06                   	push   %es
   1010b:	0f a0                	push   %fs
   1010d:	0f a8                	push   %gs
   1010f:	54                   	push   %esp
   10110:	e8 10 28 00 00       	call   12925 <do_handler_invalid_opcode>
   10115:	83 c4 04             	add    $0x4,%esp
   10118:	0f a9                	pop    %gs
   1011a:	0f a1                	pop    %fs
   1011c:	07                   	pop    %es
   1011d:	1f                   	pop    %ds
   1011e:	61                   	popa   
   1011f:	83 c4 08             	add    $0x8,%esp
   10122:	cf                   	iret   

00010123 <exception_handler_device_unavailable>:
exception_handler device_unavailable, 7, 0
   10123:	6a 00                	push   $0x0
   10125:	6a 07                	push   $0x7
   10127:	60                   	pusha  
   10128:	1e                   	push   %ds
   10129:	06                   	push   %es
   1012a:	0f a0                	push   %fs
   1012c:	0f a8                	push   %gs
   1012e:	54                   	push   %esp
   1012f:	e8 0d 28 00 00       	call   12941 <do_handler_device_unavailable>
   10134:	83 c4 04             	add    $0x4,%esp
   10137:	0f a9                	pop    %gs
   10139:	0f a1                	pop    %fs
   1013b:	07                   	pop    %es
   1013c:	1f                   	pop    %ds
   1013d:	61                   	popa   
   1013e:	83 c4 08             	add    $0x8,%esp
   10141:	cf                   	iret   

00010142 <exception_handler_double_fault>:
exception_handler double_fault, 8, 1
   10142:	6a 08                	push   $0x8
   10144:	60                   	pusha  
   10145:	1e                   	push   %ds
   10146:	06                   	push   %es
   10147:	0f a0                	push   %fs
   10149:	0f a8                	push   %gs
   1014b:	54                   	push   %esp
   1014c:	e8 0c 28 00 00       	call   1295d <do_handler_double_fault>
   10151:	83 c4 04             	add    $0x4,%esp
   10154:	0f a9                	pop    %gs
   10156:	0f a1                	pop    %fs
   10158:	07                   	pop    %es
   10159:	1f                   	pop    %ds
   1015a:	61                   	popa   
   1015b:	83 c4 08             	add    $0x8,%esp
   1015e:	cf                   	iret   

0001015f <exception_handler_invalid_tss>:
exception_handler invalid_tss, 10, 1
   1015f:	6a 0a                	push   $0xa
   10161:	60                   	pusha  
   10162:	1e                   	push   %ds
   10163:	06                   	push   %es
   10164:	0f a0                	push   %fs
   10166:	0f a8                	push   %gs
   10168:	54                   	push   %esp
   10169:	e8 0b 28 00 00       	call   12979 <do_handler_invalid_tss>
   1016e:	83 c4 04             	add    $0x4,%esp
   10171:	0f a9                	pop    %gs
   10173:	0f a1                	pop    %fs
   10175:	07                   	pop    %es
   10176:	1f                   	pop    %ds
   10177:	61                   	popa   
   10178:	83 c4 08             	add    $0x8,%esp
   1017b:	cf                   	iret   

0001017c <exception_handler_segment_not_present>:
exception_handler segment_not_present, 11, 1
   1017c:	6a 0b                	push   $0xb
   1017e:	60                   	pusha  
   1017f:	1e                   	push   %ds
   10180:	06                   	push   %es
   10181:	0f a0                	push   %fs
   10183:	0f a8                	push   %gs
   10185:	54                   	push   %esp
   10186:	e8 0a 28 00 00       	call   12995 <do_handler_segment_not_present>
   1018b:	83 c4 04             	add    $0x4,%esp
   1018e:	0f a9                	pop    %gs
   10190:	0f a1                	pop    %fs
   10192:	07                   	pop    %es
   10193:	1f                   	pop    %ds
   10194:	61                   	popa   
   10195:	83 c4 08             	add    $0x8,%esp
   10198:	cf                   	iret   

00010199 <exception_handler_stack_segment_fault>:
exception_handler stack_segment_fault, 12, 1
   10199:	6a 0c                	push   $0xc
   1019b:	60                   	pusha  
   1019c:	1e                   	push   %ds
   1019d:	06                   	push   %es
   1019e:	0f a0                	push   %fs
   101a0:	0f a8                	push   %gs
   101a2:	54                   	push   %esp
   101a3:	e8 09 28 00 00       	call   129b1 <do_handler_stack_segment_fault>
   101a8:	83 c4 04             	add    $0x4,%esp
   101ab:	0f a9                	pop    %gs
   101ad:	0f a1                	pop    %fs
   101af:	07                   	pop    %es
   101b0:	1f                   	pop    %ds
   101b1:	61                   	popa   
   101b2:	83 c4 08             	add    $0x8,%esp
   101b5:	cf                   	iret   

000101b6 <exception_handler_general_protection>:
exception_handler general_protection, 13, 1
   101b6:	6a 0d                	push   $0xd
   101b8:	60                   	pusha  
   101b9:	1e                   	push   %ds
   101ba:	06                   	push   %es
   101bb:	0f a0                	push   %fs
   101bd:	0f a8                	push   %gs
   101bf:	54                   	push   %esp
   101c0:	e8 08 28 00 00       	call   129cd <do_handler_general_protection>
   101c5:	83 c4 04             	add    $0x4,%esp
   101c8:	0f a9                	pop    %gs
   101ca:	0f a1                	pop    %fs
   101cc:	07                   	pop    %es
   101cd:	1f                   	pop    %ds
   101ce:	61                   	popa   
   101cf:	83 c4 08             	add    $0x8,%esp
   101d2:	cf                   	iret   

000101d3 <exception_handler_page_fault>:
exception_handler page_fault, 14, 1
   101d3:	6a 0e                	push   $0xe
   101d5:	60                   	pusha  
   101d6:	1e                   	push   %ds
   101d7:	06                   	push   %es
   101d8:	0f a0                	push   %fs
   101da:	0f a8                	push   %gs
   101dc:	54                   	push   %esp
   101dd:	e8 a0 28 00 00       	call   12a82 <do_handler_page_fault>
   101e2:	83 c4 04             	add    $0x4,%esp
   101e5:	0f a9                	pop    %gs
   101e7:	0f a1                	pop    %fs
   101e9:	07                   	pop    %es
   101ea:	1f                   	pop    %ds
   101eb:	61                   	popa   
   101ec:	83 c4 08             	add    $0x8,%esp
   101ef:	cf                   	iret   

000101f0 <exception_handler_fpu_error>:
exception_handler fpu_error, 16, 0
   101f0:	6a 00                	push   $0x0
   101f2:	6a 10                	push   $0x10
   101f4:	60                   	pusha  
   101f5:	1e                   	push   %ds
   101f6:	06                   	push   %es
   101f7:	0f a0                	push   %fs
   101f9:	0f a8                	push   %gs
   101fb:	54                   	push   %esp
   101fc:	e8 55 29 00 00       	call   12b56 <do_handler_fpu_error>
   10201:	83 c4 04             	add    $0x4,%esp
   10204:	0f a9                	pop    %gs
   10206:	0f a1                	pop    %fs
   10208:	07                   	pop    %es
   10209:	1f                   	pop    %ds
   1020a:	61                   	popa   
   1020b:	83 c4 08             	add    $0x8,%esp
   1020e:	cf                   	iret   

0001020f <exception_handler_alignment_check>:
exception_handler alignment_check, 17, 1
   1020f:	6a 11                	push   $0x11
   10211:	60                   	pusha  
   10212:	1e                   	push   %ds
   10213:	06                   	push   %es
   10214:	0f a0                	push   %fs
   10216:	0f a8                	push   %gs
   10218:	54                   	push   %esp
   10219:	e8 54 29 00 00       	call   12b72 <do_handler_alignment_check>
   1021e:	83 c4 04             	add    $0x4,%esp
   10221:	0f a9                	pop    %gs
   10223:	0f a1                	pop    %fs
   10225:	07                   	pop    %es
   10226:	1f                   	pop    %ds
   10227:	61                   	popa   
   10228:	83 c4 08             	add    $0x8,%esp
   1022b:	cf                   	iret   

0001022c <exception_handler_machine_check>:
exception_handler machine_check, 18, 0
   1022c:	6a 00                	push   $0x0
   1022e:	6a 12                	push   $0x12
   10230:	60                   	pusha  
   10231:	1e                   	push   %ds
   10232:	06                   	push   %es
   10233:	0f a0                	push   %fs
   10235:	0f a8                	push   %gs
   10237:	54                   	push   %esp
   10238:	e8 51 29 00 00       	call   12b8e <do_handler_machine_check>
   1023d:	83 c4 04             	add    $0x4,%esp
   10240:	0f a9                	pop    %gs
   10242:	0f a1                	pop    %fs
   10244:	07                   	pop    %es
   10245:	1f                   	pop    %ds
   10246:	61                   	popa   
   10247:	83 c4 08             	add    $0x8,%esp
   1024a:	cf                   	iret   

0001024b <exception_handler_smd_exception>:
exception_handler smd_exception, 19, 0
   1024b:	6a 00                	push   $0x0
   1024d:	6a 13                	push   $0x13
   1024f:	60                   	pusha  
   10250:	1e                   	push   %ds
   10251:	06                   	push   %es
   10252:	0f a0                	push   %fs
   10254:	0f a8                	push   %gs
   10256:	54                   	push   %esp
   10257:	e8 4e 29 00 00       	call   12baa <do_handler_smd_exception>
   1025c:	83 c4 04             	add    $0x4,%esp
   1025f:	0f a9                	pop    %gs
   10261:	0f a1                	pop    %fs
   10263:	07                   	pop    %es
   10264:	1f                   	pop    %ds
   10265:	61                   	popa   
   10266:	83 c4 08             	add    $0x8,%esp
   10269:	cf                   	iret   

0001026a <exception_handler_virtual_exception>:
exception_handler virtual_exception, 20, 0
   1026a:	6a 00                	push   $0x0
   1026c:	6a 14                	push   $0x14
   1026e:	60                   	pusha  
   1026f:	1e                   	push   %ds
   10270:	06                   	push   %es
   10271:	0f a0                	push   %fs
   10273:	0f a8                	push   %gs
   10275:	54                   	push   %esp
   10276:	e8 4b 29 00 00       	call   12bc6 <do_handler_virtual_exception>
   1027b:	83 c4 04             	add    $0x4,%esp
   1027e:	0f a9                	pop    %gs
   10280:	0f a1                	pop    %fs
   10282:	07                   	pop    %es
   10283:	1f                   	pop    %ds
   10284:	61                   	popa   
   10285:	83 c4 08             	add    $0x8,%esp
   10288:	cf                   	iret   

00010289 <exception_handler_time>:
exception_handler time,0x20,0
   10289:	6a 00                	push   $0x0
   1028b:	6a 20                	push   $0x20
   1028d:	60                   	pusha  
   1028e:	1e                   	push   %ds
   1028f:	06                   	push   %es
   10290:	0f a0                	push   %fs
   10292:	0f a8                	push   %gs
   10294:	54                   	push   %esp
   10295:	e8 f8 3b 00 00       	call   13e92 <do_handler_time>
   1029a:	83 c4 04             	add    $0x4,%esp
   1029d:	0f a9                	pop    %gs
   1029f:	0f a1                	pop    %fs
   102a1:	07                   	pop    %es
   102a2:	1f                   	pop    %ds
   102a3:	61                   	popa   
   102a4:	83 c4 08             	add    $0x8,%esp
   102a7:	cf                   	iret   

000102a8 <exception_handler_kbd>:
exception_handler kbd,0x21,0
   102a8:	6a 00                	push   $0x0
   102aa:	6a 21                	push   $0x21
   102ac:	60                   	pusha  
   102ad:	1e                   	push   %ds
   102ae:	06                   	push   %es
   102af:	0f a0                	push   %fs
   102b1:	0f a8                	push   %gs
   102b3:	54                   	push   %esp
   102b4:	e8 fa 3a 00 00       	call   13db3 <do_handler_kbd>
   102b9:	83 c4 04             	add    $0x4,%esp
   102bc:	0f a9                	pop    %gs
   102be:	0f a1                	pop    %fs
   102c0:	07                   	pop    %es
   102c1:	1f                   	pop    %ds
   102c2:	61                   	popa   
   102c3:	83 c4 08             	add    $0x8,%esp
   102c6:	cf                   	iret   

000102c7 <exception_handler_syscall>:

    .global exception_handler_syscall
    .extern do_handler_syscall
exception_handler_syscall:
    pusha
   102c7:	60                   	pusha  
    push %ds
   102c8:	1e                   	push   %ds
    push %es
   102c9:	06                   	push   %es
    push %fs
   102ca:	0f a0                	push   %fs
    push %gs
   102cc:	0f a8                	push   %gs
    pushf
   102ce:	9c                   	pushf  

    mov %esp,%eax
   102cf:	89 e0                	mov    %esp,%eax
    push %eax
   102d1:	50                   	push   %eax

    call do_handler_syscall
   102d2:	e8 45 0b 00 00       	call   10e1c <do_handler_syscall>
    add $4,%esp
   102d7:	83 c4 04             	add    $0x4,%esp
    
    popf
   102da:	9d                   	popf   
    pop %gs
   102db:	0f a9                	pop    %gs
    pop %fs
   102dd:	0f a1                	pop    %fs
    pop %es
   102df:	07                   	pop    %es
    pop %ds
   102e0:	1f                   	pop    %ds
    popa
   102e1:	61                   	popa   

   102e2:	ca 14 00             	lret   $0x14

000102e5 <read_cr0>:
        :[g]"m"(gdt)
    );
}

// 设置读cr0寄存器
static inline uint32_t read_cr0(void){
   102e5:	55                   	push   %ebp
   102e6:	89 e5                	mov    %esp,%ebp
   102e8:	83 ec 10             	sub    $0x10,%esp
    uint32_t cr0;
    __asm__ __volatile__(
   102eb:	0f 20 c0             	mov    %cr0,%eax
   102ee:	89 45 fc             	mov    %eax,-0x4(%ebp)
        "mov %%cr0, %[v]"
        :[v]"=r"(cr0)
        :
    );
    return cr0;
   102f1:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   102f4:	c9                   	leave  
   102f5:	c3                   	ret    

000102f6 <write_cr0>:

// 设置写cr0寄存器
static inline void write_cr0(uint32_t v){
   102f6:	55                   	push   %ebp
   102f7:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   102f9:	8b 45 08             	mov    0x8(%ebp),%eax
   102fc:	0f 22 c0             	mov    %eax,%cr0
        "mov %[v],%%cr0"
        :
        :[v]"r"(v)
    );
}
   102ff:	90                   	nop
   10300:	5d                   	pop    %ebp
   10301:	c3                   	ret    

00010302 <write_cr3>:
        :
        :"a"(eflags)
    );
}

static inline void write_cr3(uint32_t v){
   10302:	55                   	push   %ebp
   10303:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   10305:	8b 45 08             	mov    0x8(%ebp),%eax
   10308:	0f 22 d8             	mov    %eax,%cr3
        "mov %[v],%%cr3"
        :
        :[v]"r"(v)
    );
}
   1030b:	90                   	nop
   1030c:	5d                   	pop    %ebp
   1030d:	c3                   	ret    

0001030e <write_cr4>:
        :
    );
    return cr3;
}

static inline void write_cr4(uint32_t v){
   1030e:	55                   	push   %ebp
   1030f:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   10311:	8b 45 08             	mov    0x8(%ebp),%eax
   10314:	0f 22 e0             	mov    %eax,%cr4
        "mov %[v],%%cr4"
        :
        :[v]"r"(v)
    );
}
   10317:	90                   	nop
   10318:	5d                   	pop    %ebp
   10319:	c3                   	ret    

0001031a <read_cr4>:

static inline uint32_t read_cr4(void){
   1031a:	55                   	push   %ebp
   1031b:	89 e5                	mov    %esp,%ebp
   1031d:	83 ec 10             	sub    $0x10,%esp
    uint32_t cr4;
    __asm__ __volatile__(
   10320:	0f 20 e0             	mov    %cr4,%eax
   10323:	89 45 fc             	mov    %eax,-0x4(%ebp)
        "mov %%cr4,%[v]"
        :[v]"=r"(cr4)
        :
    );
    return cr4;
   10326:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   10329:	c9                   	leave  
   1032a:	c3                   	ret    

0001032b <down2>:
#include <stdarg.h>
#include "comm/types.h"
#include "tools/log.h"
#include "comm/cpu_instr.h"

static inline uint32_t down2(uint32_t size,uint32_t bound){
   1032b:	55                   	push   %ebp
   1032c:	89 e5                	mov    %esp,%ebp
    return size & ~(bound-1);
   1032e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10331:	f7 d8                	neg    %eax
   10333:	23 45 08             	and    0x8(%ebp),%eax
}
   10336:	5d                   	pop    %ebp
   10337:	c3                   	ret    

00010338 <up2>:

static inline uint32_t up2(uint32_t size,uint32_t bound){
   10338:	55                   	push   %ebp
   10339:	89 e5                	mov    %esp,%ebp
    return (size+bound-1) & ~(bound-1);
   1033b:	8b 55 08             	mov    0x8(%ebp),%edx
   1033e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10341:	01 d0                	add    %edx,%eax
   10343:	8d 50 ff             	lea    -0x1(%eax),%edx
   10346:	8b 45 0c             	mov    0xc(%ebp),%eax
   10349:	f7 d8                	neg    %eax
   1034b:	21 d0                	and    %edx,%eax
}
   1034d:	5d                   	pop    %ebp
   1034e:	c3                   	ret    

0001034f <mmu_set_page_dir>:
        uint32_t phy_pt_addr : 20;
    };

}pte_t;

static inline void mmu_set_page_dir(uint32_t paddr){
   1034f:	55                   	push   %ebp
   10350:	89 e5                	mov    %esp,%ebp
   10352:	83 ec 10             	sub    $0x10,%esp
    uint32_t cr4=read_cr4();
   10355:	e8 c0 ff ff ff       	call   1031a <read_cr4>
   1035a:	89 45 fc             	mov    %eax,-0x4(%ebp)
	write_cr4(cr4|CR4_PSE);
   1035d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10360:	83 c8 10             	or     $0x10,%eax
   10363:	50                   	push   %eax
   10364:	e8 a5 ff ff ff       	call   1030e <write_cr4>
   10369:	83 c4 04             	add    $0x4,%esp
	write_cr3(paddr);
   1036c:	ff 75 08             	pushl  0x8(%ebp)
   1036f:	e8 8e ff ff ff       	call   10302 <write_cr3>
   10374:	83 c4 04             	add    $0x4,%esp
	write_cr0(read_cr0()|CR0_PG);
   10377:	e8 69 ff ff ff       	call   102e5 <read_cr0>
   1037c:	0d 00 00 00 80       	or     $0x80000000,%eax
   10381:	50                   	push   %eax
   10382:	e8 6f ff ff ff       	call   102f6 <write_cr0>
   10387:	83 c4 04             	add    $0x4,%esp
}
   1038a:	90                   	nop
   1038b:	c9                   	leave  
   1038c:	c3                   	ret    

0001038d <pde_index>:

static inline uint32_t pde_index(uint32_t vaddr){
   1038d:	55                   	push   %ebp
   1038e:	89 e5                	mov    %esp,%ebp
    return vaddr >> 22;
   10390:	8b 45 08             	mov    0x8(%ebp),%eax
   10393:	c1 e8 16             	shr    $0x16,%eax
}
   10396:	5d                   	pop    %ebp
   10397:	c3                   	ret    

00010398 <pte_index>:

static inline uint32_t pte_index(uint32_t vaddr){
   10398:	55                   	push   %ebp
   10399:	89 e5                	mov    %esp,%ebp
    return (vaddr >> 12)  & 0x3FF;
   1039b:	8b 45 08             	mov    0x8(%ebp),%eax
   1039e:	c1 e8 0c             	shr    $0xc,%eax
   103a1:	25 ff 03 00 00       	and    $0x3ff,%eax
}
   103a6:	5d                   	pop    %ebp
   103a7:	c3                   	ret    

000103a8 <pde_paddr>:

static inline uint32_t pde_paddr(pde_t* pde){
   103a8:	55                   	push   %ebp
   103a9:	89 e5                	mov    %esp,%ebp
    return pde->phy_pt_addr << 12;
   103ab:	8b 45 08             	mov    0x8(%ebp),%eax
   103ae:	8b 00                	mov    (%eax),%eax
   103b0:	c1 e8 0c             	shr    $0xc,%eax
   103b3:	c1 e0 0c             	shl    $0xc,%eax
}
   103b6:	5d                   	pop    %ebp
   103b7:	c3                   	ret    

000103b8 <pte_paddr>:

static inline uint32_t pte_paddr(pte_t* pte){
   103b8:	55                   	push   %ebp
   103b9:	89 e5                	mov    %esp,%ebp
    return pte->phy_pt_addr << 12;
   103bb:	8b 45 08             	mov    0x8(%ebp),%eax
   103be:	8b 00                	mov    (%eax),%eax
   103c0:	c1 e8 0c             	shr    $0xc,%eax
   103c3:	c1 e0 0c             	shl    $0xc,%eax
}
   103c6:	5d                   	pop    %ebp
   103c7:	c3                   	ret    

000103c8 <get_pte_perm>:

static inline uint32_t get_pte_perm(pte_t* pte){
   103c8:	55                   	push   %ebp
   103c9:	89 e5                	mov    %esp,%ebp
    return (pte->v & 0x1FF);
   103cb:	8b 45 08             	mov    0x8(%ebp),%eax
   103ce:	8b 00                	mov    (%eax),%eax
   103d0:	25 ff 01 00 00       	and    $0x1ff,%eax
}
   103d5:	5d                   	pop    %ebp
   103d6:	c3                   	ret    

000103d7 <addr_alloc_init>:

static addr_alloc_t paddr_alloc;
static pde_t kernel_page_dir[PDE_CNT] __attribute__((aligned(MEM_PAGE_SIZE)));

static void addr_alloc_init(addr_alloc_t* alloc,uint8_t* bits,
    uint32_t start,uint32_t size,uint32_t page_size){
   103d7:	55                   	push   %ebp
   103d8:	89 e5                	mov    %esp,%ebp
   103da:	83 ec 08             	sub    $0x8,%esp
        mutex_init(&alloc->mutex);
   103dd:	8b 45 08             	mov    0x8(%ebp),%eax
   103e0:	83 ec 0c             	sub    $0xc,%esp
   103e3:	50                   	push   %eax
   103e4:	e8 0e 47 00 00       	call   14af7 <mutex_init>
   103e9:	83 c4 10             	add    $0x10,%esp
        alloc->start=start;
   103ec:	8b 45 08             	mov    0x8(%ebp),%eax
   103ef:	8b 55 10             	mov    0x10(%ebp),%edx
   103f2:	89 50 1c             	mov    %edx,0x1c(%eax)
        alloc->size=size;
   103f5:	8b 45 08             	mov    0x8(%ebp),%eax
   103f8:	8b 55 14             	mov    0x14(%ebp),%edx
   103fb:	89 50 20             	mov    %edx,0x20(%eax)
        alloc->page_size=page_size;
   103fe:	8b 45 08             	mov    0x8(%ebp),%eax
   10401:	8b 55 18             	mov    0x18(%ebp),%edx
   10404:	89 50 24             	mov    %edx,0x24(%eax)
        bitmap_init(&alloc->bitmap,bits,alloc->size/page_size,0);
   10407:	8b 45 08             	mov    0x8(%ebp),%eax
   1040a:	8b 40 20             	mov    0x20(%eax),%eax
   1040d:	ba 00 00 00 00       	mov    $0x0,%edx
   10412:	f7 75 18             	divl   0x18(%ebp)
   10415:	89 c2                	mov    %eax,%edx
   10417:	8b 45 08             	mov    0x8(%ebp),%eax
   1041a:	83 c0 14             	add    $0x14,%eax
   1041d:	6a 00                	push   $0x0
   1041f:	52                   	push   %edx
   10420:	ff 75 0c             	pushl  0xc(%ebp)
   10423:	50                   	push   %eax
   10424:	e8 a9 49 00 00       	call   14dd2 <bitmap_init>
   10429:	83 c4 10             	add    $0x10,%esp
}
   1042c:	90                   	nop
   1042d:	c9                   	leave  
   1042e:	c3                   	ret    

0001042f <addr_alloc_page>:

static uint32_t addr_alloc_page(addr_alloc_t* alloc,int page_count){
   1042f:	55                   	push   %ebp
   10430:	89 e5                	mov    %esp,%ebp
   10432:	83 ec 18             	sub    $0x18,%esp
    uint32_t addr=0;
   10435:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    mutex_lock(&alloc->mutex);
   1043c:	8b 45 08             	mov    0x8(%ebp),%eax
   1043f:	83 ec 0c             	sub    $0xc,%esp
   10442:	50                   	push   %eax
   10443:	e8 dd 46 00 00       	call   14b25 <mutex_lock>
   10448:	83 c4 10             	add    $0x10,%esp
    int page_index=bitmap_alloc_nbits(&alloc->bitmap,0,page_count);
   1044b:	8b 45 08             	mov    0x8(%ebp),%eax
   1044e:	83 c0 14             	add    $0x14,%eax
   10451:	83 ec 04             	sub    $0x4,%esp
   10454:	ff 75 0c             	pushl  0xc(%ebp)
   10457:	6a 00                	push   $0x0
   10459:	50                   	push   %eax
   1045a:	e8 1b 4b 00 00       	call   14f7a <bitmap_alloc_nbits>
   1045f:	83 c4 10             	add    $0x10,%esp
   10462:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(page_index>=0){
   10465:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10469:	78 17                	js     10482 <addr_alloc_page+0x53>
        addr=alloc->start+page_index*alloc->page_size;
   1046b:	8b 45 08             	mov    0x8(%ebp),%eax
   1046e:	8b 50 1c             	mov    0x1c(%eax),%edx
   10471:	8b 45 08             	mov    0x8(%ebp),%eax
   10474:	8b 48 24             	mov    0x24(%eax),%ecx
   10477:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1047a:	0f af c1             	imul   %ecx,%eax
   1047d:	01 d0                	add    %edx,%eax
   1047f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    mutex_unlock(&alloc->mutex);
   10482:	8b 45 08             	mov    0x8(%ebp),%eax
   10485:	83 ec 0c             	sub    $0xc,%esp
   10488:	50                   	push   %eax
   10489:	e8 26 47 00 00       	call   14bb4 <mutex_unlock>
   1048e:	83 c4 10             	add    $0x10,%esp
    return addr;
   10491:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10494:	c9                   	leave  
   10495:	c3                   	ret    

00010496 <addr_free_page>:


static void addr_free_page(addr_alloc_t* alloc,uint32_t addr,int page_count){
   10496:	55                   	push   %ebp
   10497:	89 e5                	mov    %esp,%ebp
   10499:	53                   	push   %ebx
   1049a:	83 ec 14             	sub    $0x14,%esp
    mutex_lock(&alloc->mutex);
   1049d:	8b 45 08             	mov    0x8(%ebp),%eax
   104a0:	83 ec 0c             	sub    $0xc,%esp
   104a3:	50                   	push   %eax
   104a4:	e8 7c 46 00 00       	call   14b25 <mutex_lock>
   104a9:	83 c4 10             	add    $0x10,%esp
    uint32_t pg_index=(addr-alloc->start)/alloc->page_size;
   104ac:	8b 45 08             	mov    0x8(%ebp),%eax
   104af:	8b 40 1c             	mov    0x1c(%eax),%eax
   104b2:	8b 55 0c             	mov    0xc(%ebp),%edx
   104b5:	89 d1                	mov    %edx,%ecx
   104b7:	29 c1                	sub    %eax,%ecx
   104b9:	8b 45 08             	mov    0x8(%ebp),%eax
   104bc:	8b 58 24             	mov    0x24(%eax),%ebx
   104bf:	89 c8                	mov    %ecx,%eax
   104c1:	ba 00 00 00 00       	mov    $0x0,%edx
   104c6:	f7 f3                	div    %ebx
   104c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    bitmap_set_bit(&alloc->bitmap,pg_index,page_count,0);
   104cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   104ce:	8b 55 08             	mov    0x8(%ebp),%edx
   104d1:	83 c2 14             	add    $0x14,%edx
   104d4:	6a 00                	push   $0x0
   104d6:	ff 75 10             	pushl  0x10(%ebp)
   104d9:	50                   	push   %eax
   104da:	52                   	push   %edx
   104db:	e8 94 49 00 00       	call   14e74 <bitmap_set_bit>
   104e0:	83 c4 10             	add    $0x10,%esp
    mutex_unlock(&alloc->mutex);
   104e3:	8b 45 08             	mov    0x8(%ebp),%eax
   104e6:	83 ec 0c             	sub    $0xc,%esp
   104e9:	50                   	push   %eax
   104ea:	e8 c5 46 00 00       	call   14bb4 <mutex_unlock>
   104ef:	83 c4 10             	add    $0x10,%esp
}
   104f2:	90                   	nop
   104f3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   104f6:	c9                   	leave  
   104f7:	c3                   	ret    

000104f8 <total_mem_size>:

static uint32_t total_mem_size(boot_info_t* boot_info){
   104f8:	55                   	push   %ebp
   104f9:	89 e5                	mov    %esp,%ebp
   104fb:	83 ec 10             	sub    $0x10,%esp
    uint32_t mem_size=0;
   104fe:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    for(int i=0;i<boot_info->ram_region_count;i++){
   10505:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1050c:	eb 11                	jmp    1051f <total_mem_size+0x27>
        mem_size+=boot_info->ram_region_cfg[i].size;
   1050e:	8b 45 08             	mov    0x8(%ebp),%eax
   10511:	8b 55 f8             	mov    -0x8(%ebp),%edx
   10514:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
   10518:	01 45 fc             	add    %eax,-0x4(%ebp)
    for(int i=0;i<boot_info->ram_region_count;i++){
   1051b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   1051f:	8b 45 08             	mov    0x8(%ebp),%eax
   10522:	8b 40 50             	mov    0x50(%eax),%eax
   10525:	39 45 f8             	cmp    %eax,-0x8(%ebp)
   10528:	7c e4                	jl     1050e <total_mem_size+0x16>
    }
    return mem_size;
   1052a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   1052d:	c9                   	leave  
   1052e:	c3                   	ret    

0001052f <find_pte>:

pte_t* find_pte(pde_t*page_dir,uint32_t vaddr,int alloc){
   1052f:	55                   	push   %ebp
   10530:	89 e5                	mov    %esp,%ebp
   10532:	83 ec 18             	sub    $0x18,%esp
    pte_t* page_table;
    pde_t* pde=page_dir+pde_index(vaddr);
   10535:	ff 75 0c             	pushl  0xc(%ebp)
   10538:	e8 50 fe ff ff       	call   1038d <pde_index>
   1053d:	83 c4 04             	add    $0x4,%esp
   10540:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10547:	8b 45 08             	mov    0x8(%ebp),%eax
   1054a:	01 d0                	add    %edx,%eax
   1054c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(pde->present){
   1054f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10552:	0f b6 00             	movzbl (%eax),%eax
   10555:	83 e0 01             	and    $0x1,%eax
   10558:	84 c0                	test   %al,%al
   1055a:	74 10                	je     1056c <find_pte+0x3d>
        page_table=(pte_t*)pde_paddr(pde);
   1055c:	ff 75 f0             	pushl  -0x10(%ebp)
   1055f:	e8 44 fe ff ff       	call   103a8 <pde_paddr>
   10564:	83 c4 04             	add    $0x4,%esp
   10567:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1056a:	eb 57                	jmp    105c3 <find_pte+0x94>
    }
    else{
        if(alloc==0){
   1056c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   10570:	75 07                	jne    10579 <find_pte+0x4a>
            return (pte_t*)0;
   10572:	b8 00 00 00 00       	mov    $0x0,%eax
   10577:	eb 64                	jmp    105dd <find_pte+0xae>
        }
        uint32_t pg_paddr=addr_alloc_page(&paddr_alloc,1);
   10579:	83 ec 08             	sub    $0x8,%esp
   1057c:	6a 01                	push   $0x1
   1057e:	68 00 80 01 00       	push   $0x18000
   10583:	e8 a7 fe ff ff       	call   1042f <addr_alloc_page>
   10588:	83 c4 10             	add    $0x10,%esp
   1058b:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(pg_paddr==0) return (pte_t*)0;
   1058e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10592:	75 07                	jne    1059b <find_pte+0x6c>
   10594:	b8 00 00 00 00       	mov    $0x0,%eax
   10599:	eb 42                	jmp    105dd <find_pte+0xae>
        pde->v=pg_paddr | PTE_P | PDE_W | PDE_U;
   1059b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1059e:	83 c8 07             	or     $0x7,%eax
   105a1:	89 c2                	mov    %eax,%edx
   105a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   105a6:	89 10                	mov    %edx,(%eax)
        page_table=(pte_t*)pg_paddr;
   105a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   105ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
        kernel_memset(page_table,0,MEM_PAGE_SIZE);
   105ae:	83 ec 04             	sub    $0x4,%esp
   105b1:	68 00 10 00 00       	push   $0x1000
   105b6:	6a 00                	push   $0x0
   105b8:	ff 75 f4             	pushl  -0xc(%ebp)
   105bb:	e8 2f 4c 00 00       	call   151ef <kernel_memset>
   105c0:	83 c4 10             	add    $0x10,%esp
    }

    return page_table+pte_index(vaddr);
   105c3:	83 ec 0c             	sub    $0xc,%esp
   105c6:	ff 75 0c             	pushl  0xc(%ebp)
   105c9:	e8 ca fd ff ff       	call   10398 <pte_index>
   105ce:	83 c4 10             	add    $0x10,%esp
   105d1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   105d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   105db:	01 d0                	add    %edx,%eax
}
   105dd:	c9                   	leave  
   105de:	c3                   	ret    

000105df <memory_create_map>:

int memory_create_map(pde_t* page_dir,uint32_t vaddr,uint32_t paddr,int count,uint32_t perm){
   105df:	55                   	push   %ebp
   105e0:	89 e5                	mov    %esp,%ebp
   105e2:	83 ec 18             	sub    $0x18,%esp
    for(int i=0;i<count;i++){
   105e5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   105ec:	eb 7b                	jmp    10669 <memory_create_map+0x8a>
        pte_t* pte=find_pte(page_dir,vaddr,1);
   105ee:	83 ec 04             	sub    $0x4,%esp
   105f1:	6a 01                	push   $0x1
   105f3:	ff 75 0c             	pushl  0xc(%ebp)
   105f6:	ff 75 08             	pushl  0x8(%ebp)
   105f9:	e8 31 ff ff ff       	call   1052f <find_pte>
   105fe:	83 c4 10             	add    $0x10,%esp
   10601:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(pte==(pte_t*)0){
   10604:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10608:	75 17                	jne    10621 <memory_create_map+0x42>
            log_printf("create pte failed.pte==0");
   1060a:	83 ec 0c             	sub    $0xc,%esp
   1060d:	68 e0 58 01 00       	push   $0x158e0
   10612:	e8 fb 51 00 00       	call   15812 <log_printf>
   10617:	83 c4 10             	add    $0x10,%esp
            return -1;
   1061a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1061f:	eb 59                	jmp    1067a <memory_create_map+0x9b>
        }
        ASSERT(pte->present==0);
   10621:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10624:	0f b6 00             	movzbl (%eax),%eax
   10627:	83 e0 01             	and    $0x1,%eax
   1062a:	84 c0                	test   %al,%al
   1062c:	74 19                	je     10647 <memory_create_map+0x68>
   1062e:	68 f9 58 01 00       	push   $0x158f9
   10633:	68 f8 59 01 00       	push   $0x159f8
   10638:	6a 48                	push   $0x48
   1063a:	68 0c 59 01 00       	push   $0x1590c
   1063f:	e8 fe 4e 00 00       	call   15542 <panic>
   10644:	83 c4 10             	add    $0x10,%esp
        pte->v=paddr | perm | PTE_P;
   10647:	8b 45 10             	mov    0x10(%ebp),%eax
   1064a:	0b 45 18             	or     0x18(%ebp),%eax
   1064d:	83 c8 01             	or     $0x1,%eax
   10650:	89 c2                	mov    %eax,%edx
   10652:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10655:	89 10                	mov    %edx,(%eax)
        vaddr+=MEM_PAGE_SIZE;
   10657:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
        paddr+=MEM_PAGE_SIZE;
   1065e:	81 45 10 00 10 00 00 	addl   $0x1000,0x10(%ebp)
    for(int i=0;i<count;i++){
   10665:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10669:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1066c:	3b 45 14             	cmp    0x14(%ebp),%eax
   1066f:	0f 8c 79 ff ff ff    	jl     105ee <memory_create_map+0xf>
    }
    return 0;
   10675:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1067a:	c9                   	leave  
   1067b:	c3                   	ret    

0001067c <create_kernel_table>:

void create_kernel_table(void){
   1067c:	55                   	push   %ebp
   1067d:	89 e5                	mov    %esp,%ebp
   1067f:	83 ec 28             	sub    $0x28,%esp
        {s_data,(void*)(MEM_EBDA_START-1),s_data,PTE_W},
        {(void*)CONSOLE_DISP_ADDR,(void*)CONSOLE_DISP_END,(void*)CONSOLE_DISP_ADDR, PTE_W},
        {(void*)MEM_EXT_START,(void*)MEM_EXT_END,(void*)MEM_EXT_START,PTE_W},
    };

    for(int i=0;i<sizeof(kernel_map)/sizeof(memory_map_t);i++){
   10682:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   10689:	e9 86 00 00 00       	jmp    10714 <create_kernel_table+0x98>
        memory_map_t* map=kernel_map+i;
   1068e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10691:	c1 e0 04             	shl    $0x4,%eax
   10694:	05 00 70 01 00       	add    $0x17000,%eax
   10699:	89 45 f0             	mov    %eax,-0x10(%ebp)

        uint32_t vstart=down2((uint32_t)map->vstart,MEM_PAGE_SIZE);
   1069c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1069f:	8b 00                	mov    (%eax),%eax
   106a1:	68 00 10 00 00       	push   $0x1000
   106a6:	50                   	push   %eax
   106a7:	e8 7f fc ff ff       	call   1032b <down2>
   106ac:	83 c4 08             	add    $0x8,%esp
   106af:	89 45 ec             	mov    %eax,-0x14(%ebp)
        uint32_t vend=up2((uint32_t)map->vend,MEM_PAGE_SIZE);
   106b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   106b5:	8b 40 04             	mov    0x4(%eax),%eax
   106b8:	68 00 10 00 00       	push   $0x1000
   106bd:	50                   	push   %eax
   106be:	e8 75 fc ff ff       	call   10338 <up2>
   106c3:	83 c4 08             	add    $0x8,%esp
   106c6:	89 45 e8             	mov    %eax,-0x18(%ebp)
        uint32_t paddr=down2((uint32_t)map->pstart,MEM_PAGE_SIZE);
   106c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   106cc:	8b 40 08             	mov    0x8(%eax),%eax
   106cf:	68 00 10 00 00       	push   $0x1000
   106d4:	50                   	push   %eax
   106d5:	e8 51 fc ff ff       	call   1032b <down2>
   106da:	83 c4 08             	add    $0x8,%esp
   106dd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        int page_count=(vend-vstart) / MEM_PAGE_SIZE;
   106e0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   106e3:	2b 45 ec             	sub    -0x14(%ebp),%eax
   106e6:	c1 e8 0c             	shr    $0xc,%eax
   106e9:	89 45 e0             	mov    %eax,-0x20(%ebp)
        
        
        memory_create_map(kernel_page_dir,vstart,(uint32_t)map->pstart,page_count,map->perm);
   106ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
   106ef:	8b 40 0c             	mov    0xc(%eax),%eax
   106f2:	8b 55 f0             	mov    -0x10(%ebp),%edx
   106f5:	8b 52 08             	mov    0x8(%edx),%edx
   106f8:	83 ec 0c             	sub    $0xc,%esp
   106fb:	50                   	push   %eax
   106fc:	ff 75 e0             	pushl  -0x20(%ebp)
   106ff:	52                   	push   %edx
   10700:	ff 75 ec             	pushl  -0x14(%ebp)
   10703:	68 00 90 01 00       	push   $0x19000
   10708:	e8 d2 fe ff ff       	call   105df <memory_create_map>
   1070d:	83 c4 20             	add    $0x20,%esp
    for(int i=0;i<sizeof(kernel_map)/sizeof(memory_map_t);i++){
   10710:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10714:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10717:	83 f8 04             	cmp    $0x4,%eax
   1071a:	0f 86 6e ff ff ff    	jbe    1068e <create_kernel_table+0x12>
    }
}
   10720:	90                   	nop
   10721:	c9                   	leave  
   10722:	c3                   	ret    

00010723 <memory_init>:

void memory_init(boot_info_t* boot_info){
   10723:	55                   	push   %ebp
   10724:	89 e5                	mov    %esp,%ebp
   10726:	83 ec 18             	sub    $0x18,%esp
   extern uint8_t* mem_free_start;
   uint8_t* mem_free=(uint8_t*)&mem_free_start;
   10729:	c7 45 f4 24 c7 06 00 	movl   $0x6c724,-0xc(%ebp)
   uint32_t mem_up1MB_free=total_mem_size(boot_info)-MEM_EXT_START;
   10730:	ff 75 08             	pushl  0x8(%ebp)
   10733:	e8 c0 fd ff ff       	call   104f8 <total_mem_size>
   10738:	83 c4 04             	add    $0x4,%esp
   1073b:	2d 00 00 10 00       	sub    $0x100000,%eax
   10740:	89 45 f0             	mov    %eax,-0x10(%ebp)
   mem_up1MB_free=down2(mem_up1MB_free,MEM_PAGE_SIZE);
   10743:	68 00 10 00 00       	push   $0x1000
   10748:	ff 75 f0             	pushl  -0x10(%ebp)
   1074b:	e8 db fb ff ff       	call   1032b <down2>
   10750:	83 c4 08             	add    $0x8,%esp
   10753:	89 45 f0             	mov    %eax,-0x10(%ebp)
   addr_alloc_init(&paddr_alloc,mem_free,MEM_EXT_START,mem_up1MB_free,MEM_PAGE_SIZE);
   10756:	83 ec 0c             	sub    $0xc,%esp
   10759:	68 00 10 00 00       	push   $0x1000
   1075e:	ff 75 f0             	pushl  -0x10(%ebp)
   10761:	68 00 00 10 00       	push   $0x100000
   10766:	ff 75 f4             	pushl  -0xc(%ebp)
   10769:	68 00 80 01 00       	push   $0x18000
   1076e:	e8 64 fc ff ff       	call   103d7 <addr_alloc_init>
   10773:	83 c4 20             	add    $0x20,%esp
   mem_free+=bitmap_byte_count(paddr_alloc.size/MEM_PAGE_SIZE);
   10776:	a1 20 80 01 00       	mov    0x18020,%eax
   1077b:	c1 e8 0c             	shr    $0xc,%eax
   1077e:	83 ec 0c             	sub    $0xc,%esp
   10781:	50                   	push   %eax
   10782:	e8 35 46 00 00       	call   14dbc <bitmap_byte_count>
   10787:	83 c4 10             	add    $0x10,%esp
   1078a:	01 45 f4             	add    %eax,-0xc(%ebp)
   ASSERT(mem_free < (uint8_t *)MEM_EBDA_START);
   1078d:	81 7d f4 ff ff 07 00 	cmpl   $0x7ffff,-0xc(%ebp)
   10794:	76 19                	jbe    107af <memory_init+0x8c>
   10796:	68 44 59 01 00       	push   $0x15944
   1079b:	68 0c 5a 01 00       	push   $0x15a0c
   107a0:	6a 6e                	push   $0x6e
   107a2:	68 0c 59 01 00       	push   $0x1590c
   107a7:	e8 96 4d 00 00       	call   15542 <panic>
   107ac:	83 c4 10             	add    $0x10,%esp
   create_kernel_table();
   107af:	e8 c8 fe ff ff       	call   1067c <create_kernel_table>
   mmu_set_page_dir((uint32_t)kernel_page_dir);
   107b4:	b8 00 90 01 00       	mov    $0x19000,%eax
   107b9:	83 ec 0c             	sub    $0xc,%esp
   107bc:	50                   	push   %eax
   107bd:	e8 8d fb ff ff       	call   1034f <mmu_set_page_dir>
   107c2:	83 c4 10             	add    $0x10,%esp
}
   107c5:	90                   	nop
   107c6:	c9                   	leave  
   107c7:	c3                   	ret    

000107c8 <memory_create_uvm>:

uint32_t memory_create_uvm(void){
   107c8:	55                   	push   %ebp
   107c9:	89 e5                	mov    %esp,%ebp
   107cb:	83 ec 18             	sub    $0x18,%esp
    pde_t* page_dir=(pde_t*)addr_alloc_page(&paddr_alloc,1);
   107ce:	83 ec 08             	sub    $0x8,%esp
   107d1:	6a 01                	push   $0x1
   107d3:	68 00 80 01 00       	push   $0x18000
   107d8:	e8 52 fc ff ff       	call   1042f <addr_alloc_page>
   107dd:	83 c4 10             	add    $0x10,%esp
   107e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(page_dir==0){
   107e3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   107e7:	75 07                	jne    107f0 <memory_create_uvm+0x28>
        return 0;
   107e9:	b8 00 00 00 00       	mov    $0x0,%eax
   107ee:	eb 5b                	jmp    1084b <memory_create_uvm+0x83>
    }
    kernel_memset((void*)page_dir,0,MEM_PAGE_SIZE);
   107f0:	83 ec 04             	sub    $0x4,%esp
   107f3:	68 00 10 00 00       	push   $0x1000
   107f8:	6a 00                	push   $0x0
   107fa:	ff 75 f0             	pushl  -0x10(%ebp)
   107fd:	e8 ed 49 00 00       	call   151ef <kernel_memset>
   10802:	83 c4 10             	add    $0x10,%esp
    uint32_t user_pde_start=pde_index(MEMORY_TASK_BASE);
   10805:	83 ec 0c             	sub    $0xc,%esp
   10808:	68 00 00 00 80       	push   $0x80000000
   1080d:	e8 7b fb ff ff       	call   1038d <pde_index>
   10812:	83 c4 10             	add    $0x10,%esp
   10815:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for(int i=0;i<user_pde_start;i++){
   10818:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1081f:	eb 1f                	jmp    10840 <memory_create_uvm+0x78>
        page_dir[i].v=kernel_page_dir[i].v;
   10821:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10824:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1082b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1082e:	01 c2                	add    %eax,%edx
   10830:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10833:	8b 04 85 00 90 01 00 	mov    0x19000(,%eax,4),%eax
   1083a:	89 02                	mov    %eax,(%edx)
    for(int i=0;i<user_pde_start;i++){
   1083c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10840:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10843:	39 45 ec             	cmp    %eax,-0x14(%ebp)
   10846:	77 d9                	ja     10821 <memory_create_uvm+0x59>
    }

    return (uint32_t)page_dir;
   10848:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   1084b:	c9                   	leave  
   1084c:	c3                   	ret    

0001084d <memory_alloc_for_page_dir>:

int memory_alloc_for_page_dir(uint32_t page_dir,uint32_t vaddr,uint32_t size,int perm){
   1084d:	55                   	push   %ebp
   1084e:	89 e5                	mov    %esp,%ebp
   10850:	83 ec 28             	sub    $0x28,%esp
    uint32_t curr_vaddr=vaddr;
   10853:	8b 45 0c             	mov    0xc(%ebp),%eax
   10856:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int page_count=up2(size,MEM_PAGE_SIZE) / MEM_PAGE_SIZE;
   10859:	68 00 10 00 00       	push   $0x1000
   1085e:	ff 75 10             	pushl  0x10(%ebp)
   10861:	e8 d2 fa ff ff       	call   10338 <up2>
   10866:	83 c4 08             	add    $0x8,%esp
   10869:	c1 e8 0c             	shr    $0xc,%eax
   1086c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for(int i=0;i<page_count;i++){
   1086f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   10876:	eb 7b                	jmp    108f3 <memory_alloc_for_page_dir+0xa6>
        uint32_t paddr=addr_alloc_page(&paddr_alloc,1);
   10878:	83 ec 08             	sub    $0x8,%esp
   1087b:	6a 01                	push   $0x1
   1087d:	68 00 80 01 00       	push   $0x18000
   10882:	e8 a8 fb ff ff       	call   1042f <addr_alloc_page>
   10887:	83 c4 10             	add    $0x10,%esp
   1088a:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if(paddr==0){
   1088d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   10891:	75 17                	jne    108aa <memory_alloc_for_page_dir+0x5d>
            log_printf("mem alloc failed. no memory");
   10893:	83 ec 0c             	sub    $0xc,%esp
   10896:	68 69 59 01 00       	push   $0x15969
   1089b:	e8 72 4f 00 00       	call   15812 <log_printf>
   108a0:	83 c4 10             	add    $0x10,%esp
            return 0;
   108a3:	b8 00 00 00 00       	mov    $0x0,%eax
   108a8:	eb 55                	jmp    108ff <memory_alloc_for_page_dir+0xb2>
        }

        int err=memory_create_map((pde_t*)page_dir,curr_vaddr,paddr,1,perm);
   108aa:	8b 55 14             	mov    0x14(%ebp),%edx
   108ad:	8b 45 08             	mov    0x8(%ebp),%eax
   108b0:	83 ec 0c             	sub    $0xc,%esp
   108b3:	52                   	push   %edx
   108b4:	6a 01                	push   $0x1
   108b6:	ff 75 e8             	pushl  -0x18(%ebp)
   108b9:	ff 75 f4             	pushl  -0xc(%ebp)
   108bc:	50                   	push   %eax
   108bd:	e8 1d fd ff ff       	call   105df <memory_create_map>
   108c2:	83 c4 20             	add    $0x20,%esp
   108c5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(err < 0){
   108c8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   108cc:	79 1a                	jns    108e8 <memory_alloc_for_page_dir+0x9b>
            log_printf("create memory failed. err=%d",err);
   108ce:	83 ec 08             	sub    $0x8,%esp
   108d1:	ff 75 e4             	pushl  -0x1c(%ebp)
   108d4:	68 85 59 01 00       	push   $0x15985
   108d9:	e8 34 4f 00 00       	call   15812 <log_printf>
   108de:	83 c4 10             	add    $0x10,%esp
            return 0;
   108e1:	b8 00 00 00 00       	mov    $0x0,%eax
   108e6:	eb 17                	jmp    108ff <memory_alloc_for_page_dir+0xb2>
        }

        curr_vaddr+=MEM_PAGE_SIZE;
   108e8:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
    for(int i=0;i<page_count;i++){
   108ef:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   108f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   108f6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   108f9:	0f 8c 79 ff ff ff    	jl     10878 <memory_alloc_for_page_dir+0x2b>

    }
}
   108ff:	c9                   	leave  
   10900:	c3                   	ret    

00010901 <memory_alloc_page_for>:

int memory_alloc_page_for(uint32_t addr,uint32_t size,int perm){
   10901:	55                   	push   %ebp
   10902:	89 e5                	mov    %esp,%ebp
   10904:	83 ec 08             	sub    $0x8,%esp
    return memory_alloc_for_page_dir(task_current()->tss.cr3,addr,size,perm);
   10907:	e8 c3 0c 00 00       	call   115cf <task_current>
   1090c:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
   10912:	ff 75 10             	pushl  0x10(%ebp)
   10915:	ff 75 0c             	pushl  0xc(%ebp)
   10918:	ff 75 08             	pushl  0x8(%ebp)
   1091b:	50                   	push   %eax
   1091c:	e8 2c ff ff ff       	call   1084d <memory_alloc_for_page_dir>
   10921:	83 c4 10             	add    $0x10,%esp
}
   10924:	c9                   	leave  
   10925:	c3                   	ret    

00010926 <memory_alloc_page>:

uint32_t memory_alloc_page(void){
   10926:	55                   	push   %ebp
   10927:	89 e5                	mov    %esp,%ebp
   10929:	83 ec 18             	sub    $0x18,%esp
    uint32_t addr=addr_alloc_page(&paddr_alloc,1);
   1092c:	83 ec 08             	sub    $0x8,%esp
   1092f:	6a 01                	push   $0x1
   10931:	68 00 80 01 00       	push   $0x18000
   10936:	e8 f4 fa ff ff       	call   1042f <addr_alloc_page>
   1093b:	83 c4 10             	add    $0x10,%esp
   1093e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return addr;
   10941:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10944:	c9                   	leave  
   10945:	c3                   	ret    

00010946 <curr_page_dir>:

static pde_t* curr_page_dir(void){
   10946:	55                   	push   %ebp
   10947:	89 e5                	mov    %esp,%ebp
   10949:	83 ec 08             	sub    $0x8,%esp
    return (pde_t*)(task_current()->tss.cr3);
   1094c:	e8 7e 0c 00 00       	call   115cf <task_current>
   10951:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
}
   10957:	c9                   	leave  
   10958:	c3                   	ret    

00010959 <memory_free_page>:

void memory_free_page(uint32_t addr){
   10959:	55                   	push   %ebp
   1095a:	89 e5                	mov    %esp,%ebp
   1095c:	83 ec 18             	sub    $0x18,%esp
    if(addr < MEMORY_TASK_BASE){
   1095f:	8b 45 08             	mov    0x8(%ebp),%eax
   10962:	85 c0                	test   %eax,%eax
   10964:	78 17                	js     1097d <memory_free_page+0x24>
        addr_free_page(&paddr_alloc,addr,1);
   10966:	83 ec 04             	sub    $0x4,%esp
   10969:	6a 01                	push   $0x1
   1096b:	ff 75 08             	pushl  0x8(%ebp)
   1096e:	68 00 80 01 00       	push   $0x18000
   10973:	e8 1e fb ff ff       	call   10496 <addr_free_page>
   10978:	83 c4 10             	add    $0x10,%esp
        pte_t* pte=find_pte(curr_page_dir(),addr,0);
        ASSERT((pte==(pte_t*)0) &&  pte->present);
        addr_free_page(&paddr_alloc,pte_paddr(pte),1);
        pte->v=0;
    }
}
   1097b:	eb 72                	jmp    109ef <memory_free_page+0x96>
        pte_t* pte=find_pte(curr_page_dir(),addr,0);
   1097d:	e8 c4 ff ff ff       	call   10946 <curr_page_dir>
   10982:	83 ec 04             	sub    $0x4,%esp
   10985:	6a 00                	push   $0x0
   10987:	ff 75 08             	pushl  0x8(%ebp)
   1098a:	50                   	push   %eax
   1098b:	e8 9f fb ff ff       	call   1052f <find_pte>
   10990:	83 c4 10             	add    $0x10,%esp
   10993:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ASSERT((pte==(pte_t*)0) &&  pte->present);
   10996:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1099a:	75 0d                	jne    109a9 <memory_free_page+0x50>
   1099c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1099f:	0f b6 00             	movzbl (%eax),%eax
   109a2:	83 e0 01             	and    $0x1,%eax
   109a5:	84 c0                	test   %al,%al
   109a7:	75 1c                	jne    109c5 <memory_free_page+0x6c>
   109a9:	68 a4 59 01 00       	push   $0x159a4
   109ae:	68 18 5a 01 00       	push   $0x15a18
   109b3:	68 a9 00 00 00       	push   $0xa9
   109b8:	68 0c 59 01 00       	push   $0x1590c
   109bd:	e8 80 4b 00 00       	call   15542 <panic>
   109c2:	83 c4 10             	add    $0x10,%esp
        addr_free_page(&paddr_alloc,pte_paddr(pte),1);
   109c5:	83 ec 0c             	sub    $0xc,%esp
   109c8:	ff 75 f4             	pushl  -0xc(%ebp)
   109cb:	e8 e8 f9 ff ff       	call   103b8 <pte_paddr>
   109d0:	83 c4 10             	add    $0x10,%esp
   109d3:	83 ec 04             	sub    $0x4,%esp
   109d6:	6a 01                	push   $0x1
   109d8:	50                   	push   %eax
   109d9:	68 00 80 01 00       	push   $0x18000
   109de:	e8 b3 fa ff ff       	call   10496 <addr_free_page>
   109e3:	83 c4 10             	add    $0x10,%esp
        pte->v=0;
   109e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   109e9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
   109ef:	90                   	nop
   109f0:	c9                   	leave  
   109f1:	c3                   	ret    

000109f2 <memory_destroy_uvm>:

void memory_destroy_uvm(uint32_t page_dir){
   109f2:	55                   	push   %ebp
   109f3:	89 e5                	mov    %esp,%ebp
   109f5:	83 ec 28             	sub    $0x28,%esp
    uint32_t user_pde_start=pde_index(MEMORY_TASK_BASE);
   109f8:	68 00 00 00 80       	push   $0x80000000
   109fd:	e8 8b f9 ff ff       	call   1038d <pde_index>
   10a02:	83 c4 04             	add    $0x4,%esp
   10a05:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    pde_t* pde=(pde_t*)page_dir+user_pde_start;
   10a08:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10a0b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10a12:	8b 45 08             	mov    0x8(%ebp),%eax
   10a15:	01 d0                	add    %edx,%eax
   10a17:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for(int i=user_pde_start;i<PDE_CNT;i++,pde++){
   10a1a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10a1d:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10a20:	e9 8f 00 00 00       	jmp    10ab4 <memory_destroy_uvm+0xc2>
        if(!pde->present){
   10a25:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10a28:	0f b6 00             	movzbl (%eax),%eax
   10a2b:	83 e0 01             	and    $0x1,%eax
   10a2e:	84 c0                	test   %al,%al
   10a30:	74 79                	je     10aab <memory_destroy_uvm+0xb9>
            continue;
        }

        pte_t* pte=(pte_t*)pde_paddr(pde);
   10a32:	ff 75 f4             	pushl  -0xc(%ebp)
   10a35:	e8 6e f9 ff ff       	call   103a8 <pde_paddr>
   10a3a:	83 c4 04             	add    $0x4,%esp
   10a3d:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(int j=0;j<PTE_CNT;j++,pte++){
   10a40:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   10a47:	eb 36                	jmp    10a7f <memory_destroy_uvm+0x8d>
            if(!pte->present){
   10a49:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10a4c:	0f b6 00             	movzbl (%eax),%eax
   10a4f:	83 e0 01             	and    $0x1,%eax
   10a52:	84 c0                	test   %al,%al
   10a54:	74 20                	je     10a76 <memory_destroy_uvm+0x84>
                continue;
            }

            addr_free_page(&paddr_alloc,pte_paddr(pte),1);
   10a56:	ff 75 ec             	pushl  -0x14(%ebp)
   10a59:	e8 5a f9 ff ff       	call   103b8 <pte_paddr>
   10a5e:	83 c4 04             	add    $0x4,%esp
   10a61:	83 ec 04             	sub    $0x4,%esp
   10a64:	6a 01                	push   $0x1
   10a66:	50                   	push   %eax
   10a67:	68 00 80 01 00       	push   $0x18000
   10a6c:	e8 25 fa ff ff       	call   10496 <addr_free_page>
   10a71:	83 c4 10             	add    $0x10,%esp
   10a74:	eb 01                	jmp    10a77 <memory_destroy_uvm+0x85>
                continue;
   10a76:	90                   	nop
        for(int j=0;j<PTE_CNT;j++,pte++){
   10a77:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   10a7b:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
   10a7f:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
   10a86:	7e c1                	jle    10a49 <memory_destroy_uvm+0x57>
        }

        addr_free_page(&paddr_alloc,(uint32_t)pde_paddr(pde),1);
   10a88:	83 ec 0c             	sub    $0xc,%esp
   10a8b:	ff 75 f4             	pushl  -0xc(%ebp)
   10a8e:	e8 15 f9 ff ff       	call   103a8 <pde_paddr>
   10a93:	83 c4 10             	add    $0x10,%esp
   10a96:	83 ec 04             	sub    $0x4,%esp
   10a99:	6a 01                	push   $0x1
   10a9b:	50                   	push   %eax
   10a9c:	68 00 80 01 00       	push   $0x18000
   10aa1:	e8 f0 f9 ff ff       	call   10496 <addr_free_page>
   10aa6:	83 c4 10             	add    $0x10,%esp
   10aa9:	eb 01                	jmp    10aac <memory_destroy_uvm+0xba>
            continue;
   10aab:	90                   	nop
    for(int i=user_pde_start;i<PDE_CNT;i++,pde++){
   10aac:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   10ab0:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
   10ab4:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
   10abb:	0f 8e 64 ff ff ff    	jle    10a25 <memory_destroy_uvm+0x33>
    }

    addr_free_page(&paddr_alloc,page_dir,1);
   10ac1:	83 ec 04             	sub    $0x4,%esp
   10ac4:	6a 01                	push   $0x1
   10ac6:	ff 75 08             	pushl  0x8(%ebp)
   10ac9:	68 00 80 01 00       	push   $0x18000
   10ace:	e8 c3 f9 ff ff       	call   10496 <addr_free_page>
   10ad3:	83 c4 10             	add    $0x10,%esp
}
   10ad6:	90                   	nop
   10ad7:	c9                   	leave  
   10ad8:	c3                   	ret    

00010ad9 <memory_copy_uvm>:

uint32_t memory_copy_uvm(uint32_t page_dir){
   10ad9:	55                   	push   %ebp
   10ada:	89 e5                	mov    %esp,%ebp
   10adc:	83 ec 38             	sub    $0x38,%esp
    uint32_t to_page_dir=memory_create_uvm();
   10adf:	e8 e4 fc ff ff       	call   107c8 <memory_create_uvm>
   10ae4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(to_page_dir == 0){
   10ae7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   10aeb:	0f 84 1b 01 00 00    	je     10c0c <memory_copy_uvm+0x133>
        goto copy_uvm_failed;
    }

    uint32_t user_pde_start=pde_index(MEMORY_TASK_BASE);
   10af1:	83 ec 0c             	sub    $0xc,%esp
   10af4:	68 00 00 00 80       	push   $0x80000000
   10af9:	e8 8f f8 ff ff       	call   1038d <pde_index>
   10afe:	83 c4 10             	add    $0x10,%esp
   10b01:	89 45 e0             	mov    %eax,-0x20(%ebp)
    pde_t* pde=(pde_t*)page_dir+user_pde_start;
   10b04:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10b07:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10b0e:	8b 45 08             	mov    0x8(%ebp),%eax
   10b11:	01 d0                	add    %edx,%eax
   10b13:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for(int i=user_pde_start;i<PDE_CNT;i++,pde++){
   10b16:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10b19:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10b1c:	e9 d9 00 00 00       	jmp    10bfa <memory_copy_uvm+0x121>
        if(!pde->present){
   10b21:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10b24:	0f b6 00             	movzbl (%eax),%eax
   10b27:	83 e0 01             	and    $0x1,%eax
   10b2a:	84 c0                	test   %al,%al
   10b2c:	0f 84 bf 00 00 00    	je     10bf1 <memory_copy_uvm+0x118>
            continue;
        }

        pte_t*pte=(pte_t*)pde_paddr(pde);
   10b32:	83 ec 0c             	sub    $0xc,%esp
   10b35:	ff 75 f4             	pushl  -0xc(%ebp)
   10b38:	e8 6b f8 ff ff       	call   103a8 <pde_paddr>
   10b3d:	83 c4 10             	add    $0x10,%esp
   10b40:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(int j=0;j<PTE_CNT;j++,pte++){
   10b43:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   10b4a:	e9 93 00 00 00       	jmp    10be2 <memory_copy_uvm+0x109>
            if(!pte->present){
   10b4f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10b52:	0f b6 00             	movzbl (%eax),%eax
   10b55:	83 e0 01             	and    $0x1,%eax
   10b58:	84 c0                	test   %al,%al
   10b5a:	74 7d                	je     10bd9 <memory_copy_uvm+0x100>
                continue;
            }

            uint32_t page=addr_alloc_page(&paddr_alloc,1);
   10b5c:	83 ec 08             	sub    $0x8,%esp
   10b5f:	6a 01                	push   $0x1
   10b61:	68 00 80 01 00       	push   $0x18000
   10b66:	e8 c4 f8 ff ff       	call   1042f <addr_alloc_page>
   10b6b:	83 c4 10             	add    $0x10,%esp
   10b6e:	89 45 dc             	mov    %eax,-0x24(%ebp)
            if(page==0) {
   10b71:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   10b75:	0f 84 94 00 00 00    	je     10c0f <memory_copy_uvm+0x136>
                goto copy_uvm_failed;
            }
            uint32_t vaddr=(i<<22) | (j<<12);
   10b7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10b7e:	c1 e0 16             	shl    $0x16,%eax
   10b81:	89 c2                	mov    %eax,%edx
   10b83:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b86:	c1 e0 0c             	shl    $0xc,%eax
   10b89:	09 d0                	or     %edx,%eax
   10b8b:	89 45 d8             	mov    %eax,-0x28(%ebp)
            int err=memory_create_map((pde_t*)to_page_dir,vaddr,page,1,get_pte_perm(pte));
   10b8e:	83 ec 0c             	sub    $0xc,%esp
   10b91:	ff 75 ec             	pushl  -0x14(%ebp)
   10b94:	e8 2f f8 ff ff       	call   103c8 <get_pte_perm>
   10b99:	83 c4 10             	add    $0x10,%esp
   10b9c:	89 c2                	mov    %eax,%edx
   10b9e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10ba1:	83 ec 0c             	sub    $0xc,%esp
   10ba4:	52                   	push   %edx
   10ba5:	6a 01                	push   $0x1
   10ba7:	ff 75 dc             	pushl  -0x24(%ebp)
   10baa:	ff 75 d8             	pushl  -0x28(%ebp)
   10bad:	50                   	push   %eax
   10bae:	e8 2c fa ff ff       	call   105df <memory_create_map>
   10bb3:	83 c4 20             	add    $0x20,%esp
   10bb6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            if(err < 0){
   10bb9:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   10bbd:	78 53                	js     10c12 <memory_copy_uvm+0x139>
                goto copy_uvm_failed;
            }

            kernel_memcpy((void*)page,(void*)vaddr,MEM_PAGE_SIZE);
   10bbf:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10bc2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10bc5:	83 ec 04             	sub    $0x4,%esp
   10bc8:	68 00 10 00 00       	push   $0x1000
   10bcd:	52                   	push   %edx
   10bce:	50                   	push   %eax
   10bcf:	e8 cc 45 00 00       	call   151a0 <kernel_memcpy>
   10bd4:	83 c4 10             	add    $0x10,%esp
   10bd7:	eb 01                	jmp    10bda <memory_copy_uvm+0x101>
                continue;
   10bd9:	90                   	nop
        for(int j=0;j<PTE_CNT;j++,pte++){
   10bda:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   10bde:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
   10be2:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
   10be9:	0f 8e 60 ff ff ff    	jle    10b4f <memory_copy_uvm+0x76>
   10bef:	eb 01                	jmp    10bf2 <memory_copy_uvm+0x119>
            continue;
   10bf1:	90                   	nop
    for(int i=user_pde_start;i<PDE_CNT;i++,pde++){
   10bf2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   10bf6:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
   10bfa:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
   10c01:	0f 8e 1a ff ff ff    	jle    10b21 <memory_copy_uvm+0x48>
        }
    }

    return to_page_dir;
   10c07:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10c0a:	eb 20                	jmp    10c2c <memory_copy_uvm+0x153>
        goto copy_uvm_failed;
   10c0c:	90                   	nop
   10c0d:	eb 04                	jmp    10c13 <memory_copy_uvm+0x13a>
                goto copy_uvm_failed;
   10c0f:	90                   	nop
   10c10:	eb 01                	jmp    10c13 <memory_copy_uvm+0x13a>
                goto copy_uvm_failed;
   10c12:	90                   	nop
copy_uvm_failed:
    if(to_page_dir){
   10c13:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   10c17:	74 0e                	je     10c27 <memory_copy_uvm+0x14e>
        memory_destroy_uvm(to_page_dir);
   10c19:	83 ec 0c             	sub    $0xc,%esp
   10c1c:	ff 75 e4             	pushl  -0x1c(%ebp)
   10c1f:	e8 ce fd ff ff       	call   109f2 <memory_destroy_uvm>
   10c24:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   10c27:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   10c2c:	c9                   	leave  
   10c2d:	c3                   	ret    

00010c2e <memory_get_paddr>:

uint32_t memory_get_paddr(uint32_t page_dir,uint32_t vaddr){
   10c2e:	55                   	push   %ebp
   10c2f:	89 e5                	mov    %esp,%ebp
   10c31:	83 ec 18             	sub    $0x18,%esp
    pte_t* pte=find_pte((pde_t*)page_dir,vaddr,0);
   10c34:	8b 45 08             	mov    0x8(%ebp),%eax
   10c37:	83 ec 04             	sub    $0x4,%esp
   10c3a:	6a 00                	push   $0x0
   10c3c:	ff 75 0c             	pushl  0xc(%ebp)
   10c3f:	50                   	push   %eax
   10c40:	e8 ea f8 ff ff       	call   1052f <find_pte>
   10c45:	83 c4 10             	add    $0x10,%esp
   10c48:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!pte){
   10c4b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10c4f:	75 07                	jne    10c58 <memory_get_paddr+0x2a>
        return 0;
   10c51:	b8 00 00 00 00       	mov    $0x0,%eax
   10c56:	eb 1a                	jmp    10c72 <memory_get_paddr+0x44>
    }

    return pte_paddr(pte) + (vaddr & (MEM_PAGE_SIZE-1));
   10c58:	83 ec 0c             	sub    $0xc,%esp
   10c5b:	ff 75 f4             	pushl  -0xc(%ebp)
   10c5e:	e8 55 f7 ff ff       	call   103b8 <pte_paddr>
   10c63:	83 c4 10             	add    $0x10,%esp
   10c66:	89 c2                	mov    %eax,%edx
   10c68:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c6b:	25 ff 0f 00 00       	and    $0xfff,%eax
   10c70:	01 d0                	add    %edx,%eax
}
   10c72:	c9                   	leave  
   10c73:	c3                   	ret    

00010c74 <memory_copy_uvm_data>:

int memory_copy_uvm_data(uint32_t to,uint32_t page_dir,uint32_t from,uint32_t size){
   10c74:	55                   	push   %ebp
   10c75:	89 e5                	mov    %esp,%ebp
   10c77:	83 ec 18             	sub    $0x18,%esp
    while(size > 0){
   10c7a:	eb 6d                	jmp    10ce9 <memory_copy_uvm_data+0x75>
        uint32_t to_paddr=memory_get_paddr(page_dir,to);
   10c7c:	83 ec 08             	sub    $0x8,%esp
   10c7f:	ff 75 08             	pushl  0x8(%ebp)
   10c82:	ff 75 0c             	pushl  0xc(%ebp)
   10c85:	e8 a4 ff ff ff       	call   10c2e <memory_get_paddr>
   10c8a:	83 c4 10             	add    $0x10,%esp
   10c8d:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(to_paddr == 0){
   10c90:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10c94:	75 07                	jne    10c9d <memory_copy_uvm_data+0x29>
            return -1;
   10c96:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10c9b:	eb 57                	jmp    10cf4 <memory_copy_uvm_data+0x80>
        }

        uint32_t offset_in_page=to_paddr & (MEM_PAGE_SIZE-1);
   10c9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10ca0:	25 ff 0f 00 00       	and    $0xfff,%eax
   10ca5:	89 45 ec             	mov    %eax,-0x14(%ebp)
        uint32_t curr_size=MEM_PAGE_SIZE-offset_in_page;
   10ca8:	b8 00 10 00 00       	mov    $0x1000,%eax
   10cad:	2b 45 ec             	sub    -0x14(%ebp),%eax
   10cb0:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(curr_size > size){
   10cb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10cb6:	3b 45 14             	cmp    0x14(%ebp),%eax
   10cb9:	76 06                	jbe    10cc1 <memory_copy_uvm_data+0x4d>
            curr_size = size;
   10cbb:	8b 45 14             	mov    0x14(%ebp),%eax
   10cbe:	89 45 f4             	mov    %eax,-0xc(%ebp)
        }

        kernel_memcpy((void*)to_paddr,(void*)from,curr_size);
   10cc1:	8b 55 10             	mov    0x10(%ebp),%edx
   10cc4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10cc7:	83 ec 04             	sub    $0x4,%esp
   10cca:	ff 75 f4             	pushl  -0xc(%ebp)
   10ccd:	52                   	push   %edx
   10cce:	50                   	push   %eax
   10ccf:	e8 cc 44 00 00       	call   151a0 <kernel_memcpy>
   10cd4:	83 c4 10             	add    $0x10,%esp
        size -= curr_size;
   10cd7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10cda:	29 45 14             	sub    %eax,0x14(%ebp)
        to += curr_size;
   10cdd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10ce0:	01 45 08             	add    %eax,0x8(%ebp)
        from += curr_size;
   10ce3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10ce6:	01 45 10             	add    %eax,0x10(%ebp)
    while(size > 0){
   10ce9:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   10ced:	75 8d                	jne    10c7c <memory_copy_uvm_data+0x8>
    }
    return 0;
   10cef:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10cf4:	c9                   	leave  
   10cf5:	c3                   	ret    

00010cf6 <sys_sbrk>:

char* sys_sbrk(int incr){
   10cf6:	55                   	push   %ebp
   10cf7:	89 e5                	mov    %esp,%ebp
   10cf9:	83 ec 38             	sub    $0x38,%esp
    task_t* task=task_current();
   10cfc:	e8 ce 08 00 00       	call   115cf <task_current>
   10d01:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint8_t*pre_heap_end=(uint8_t*) task->heap_end;
   10d04:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10d07:	8b 40 10             	mov    0x10(%eax),%eax
   10d0a:	89 45 ec             	mov    %eax,-0x14(%ebp)

    ASSERT(incr>=0);
   10d0d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   10d11:	79 1c                	jns    10d2f <sys_sbrk+0x39>
   10d13:	68 c5 59 01 00       	push   $0x159c5
   10d18:	68 2c 5a 01 00       	push   $0x15a2c
   10d1d:	68 13 01 00 00       	push   $0x113
   10d22:	68 0c 59 01 00       	push   $0x1590c
   10d27:	e8 16 48 00 00       	call   15542 <panic>
   10d2c:	83 c4 10             	add    $0x10,%esp

    int pre_incr=incr;
   10d2f:	8b 45 08             	mov    0x8(%ebp),%eax
   10d32:	89 45 e8             	mov    %eax,-0x18(%ebp)

    if(incr==0){
   10d35:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   10d39:	75 1b                	jne    10d56 <sys_sbrk+0x60>
        log_printf("sbrk(0): end=0x%x",pre_heap_end);
   10d3b:	83 ec 08             	sub    $0x8,%esp
   10d3e:	ff 75 ec             	pushl  -0x14(%ebp)
   10d41:	68 cd 59 01 00       	push   $0x159cd
   10d46:	e8 c7 4a 00 00       	call   15812 <log_printf>
   10d4b:	83 c4 10             	add    $0x10,%esp
        return pre_heap_end;
   10d4e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10d51:	e9 aa 00 00 00       	jmp    10e00 <sys_sbrk+0x10a>
    }

    uint32_t start=task->heap_end;
   10d56:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10d59:	8b 40 10             	mov    0x10(%eax),%eax
   10d5c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t end=start+incr;
   10d5f:	8b 55 08             	mov    0x8(%ebp),%edx
   10d62:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d65:	01 d0                	add    %edx,%eax
   10d67:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    int start_offset=start % MEM_PAGE_SIZE;
   10d6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d6d:	25 ff 0f 00 00       	and    $0xfff,%eax
   10d72:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(start_offset){
   10d75:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   10d79:	74 37                	je     10db2 <sys_sbrk+0xbc>
        if(start_offset+incr <= MEM_PAGE_SIZE){
   10d7b:	8b 55 e0             	mov    -0x20(%ebp),%edx
   10d7e:	8b 45 08             	mov    0x8(%ebp),%eax
   10d81:	01 d0                	add    %edx,%eax
   10d83:	3d 00 10 00 00       	cmp    $0x1000,%eax
   10d88:	7f 0e                	jg     10d98 <sys_sbrk+0xa2>
            task->heap_end=end;
   10d8a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10d8d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   10d90:	89 50 10             	mov    %edx,0x10(%eax)
            return pre_heap_end;
   10d93:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10d96:	eb 68                	jmp    10e00 <sys_sbrk+0x10a>
        }
        else{
            uint32_t curr_size=MEM_PAGE_SIZE - start_offset;
   10d98:	b8 00 10 00 00       	mov    $0x1000,%eax
   10d9d:	2b 45 e0             	sub    -0x20(%ebp),%eax
   10da0:	89 45 dc             	mov    %eax,-0x24(%ebp)
            start+=curr_size;
   10da3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10da6:	01 45 f4             	add    %eax,-0xc(%ebp)
            incr-=curr_size;
   10da9:	8b 45 08             	mov    0x8(%ebp),%eax
   10dac:	2b 45 dc             	sub    -0x24(%ebp),%eax
   10daf:	89 45 08             	mov    %eax,0x8(%ebp)
        }
    }

    if(incr){
   10db2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   10db6:	74 3c                	je     10df4 <sys_sbrk+0xfe>
        uint32_t curr_size=end-start;
   10db8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10dbb:	2b 45 f4             	sub    -0xc(%ebp),%eax
   10dbe:	89 45 d8             	mov    %eax,-0x28(%ebp)
        int err=memory_alloc_page_for(start,curr_size,PTE_P | PTE_U | PTE_W);
   10dc1:	83 ec 04             	sub    $0x4,%esp
   10dc4:	6a 07                	push   $0x7
   10dc6:	ff 75 d8             	pushl  -0x28(%ebp)
   10dc9:	ff 75 f4             	pushl  -0xc(%ebp)
   10dcc:	e8 30 fb ff ff       	call   10901 <memory_alloc_page_for>
   10dd1:	83 c4 10             	add    $0x10,%esp
   10dd4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        if(err<0){
   10dd7:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   10ddb:	79 17                	jns    10df4 <sys_sbrk+0xfe>
            log_printf("sbrk: alloc mem failed.");
   10ddd:	83 ec 0c             	sub    $0xc,%esp
   10de0:	68 df 59 01 00       	push   $0x159df
   10de5:	e8 28 4a 00 00       	call   15812 <log_printf>
   10dea:	83 c4 10             	add    $0x10,%esp
            return (char*)-1;
   10ded:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10df2:	eb 0c                	jmp    10e00 <sys_sbrk+0x10a>
        }
    }

    task->heap_end=end;
   10df4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10df7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   10dfa:	89 50 10             	mov    %edx,0x10(%eax)
    return (char*)pre_heap_end;
   10dfd:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10e00:	c9                   	leave  
   10e01:	c3                   	ret    

00010e02 <sys_print_msg>:

// @brief 系统调用的函数指针，统一以这种方式定义
typedef int (*syscall_handler_t)(uint32_t arg0,uint32_t arg1,uint32_t arg2,uint32_t arg3);


void sys_print_msg(char* fmt,int arg){
   10e02:	55                   	push   %ebp
   10e03:	89 e5                	mov    %esp,%ebp
   10e05:	83 ec 08             	sub    $0x8,%esp
    log_printf(fmt,arg);
   10e08:	83 ec 08             	sub    $0x8,%esp
   10e0b:	ff 75 0c             	pushl  0xc(%ebp)
   10e0e:	ff 75 08             	pushl  0x8(%ebp)
   10e11:	e8 fc 49 00 00       	call   15812 <log_printf>
   10e16:	83 c4 10             	add    $0x10,%esp
}
   10e19:	90                   	nop
   10e1a:	c9                   	leave  
   10e1b:	c3                   	ret    

00010e1c <do_handler_syscall>:
    [SYS_DUP]=(syscall_handler_t)sys_dup,
    [SYS_PRINT_MSG]=(syscall_handler_t)sys_print_msg,
};


void do_handler_syscall(syscall_frame_t*frame){
   10e1c:	55                   	push   %ebp
   10e1d:	89 e5                	mov    %esp,%ebp
   10e1f:	53                   	push   %ebx
   10e20:	83 ec 14             	sub    $0x14,%esp
    if(frame->func_id < sizeof(sys_table)/sizeof(sys_table[0])){
   10e23:	8b 45 08             	mov    0x8(%ebp),%eax
   10e26:	8b 40 3c             	mov    0x3c(%eax),%eax
   10e29:	83 f8 64             	cmp    $0x64,%eax
   10e2c:	77 48                	ja     10e76 <do_handler_syscall+0x5a>
        syscall_handler_t handler=sys_table[frame->func_id];
   10e2e:	8b 45 08             	mov    0x8(%ebp),%eax
   10e31:	8b 40 3c             	mov    0x3c(%eax),%eax
   10e34:	8b 04 85 40 5a 01 00 	mov    0x15a40(,%eax,4),%eax
   10e3b:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(handler){
   10e3e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10e42:	74 32                	je     10e76 <do_handler_syscall+0x5a>
            int ret=handler(frame->arg0,frame->arg1,frame->arg2,frame->arg3);
   10e44:	8b 45 08             	mov    0x8(%ebp),%eax
   10e47:	8b 58 4c             	mov    0x4c(%eax),%ebx
   10e4a:	8b 45 08             	mov    0x8(%ebp),%eax
   10e4d:	8b 48 48             	mov    0x48(%eax),%ecx
   10e50:	8b 45 08             	mov    0x8(%ebp),%eax
   10e53:	8b 50 44             	mov    0x44(%eax),%edx
   10e56:	8b 45 08             	mov    0x8(%ebp),%eax
   10e59:	8b 40 40             	mov    0x40(%eax),%eax
   10e5c:	53                   	push   %ebx
   10e5d:	51                   	push   %ecx
   10e5e:	52                   	push   %edx
   10e5f:	50                   	push   %eax
   10e60:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10e63:	ff d0                	call   *%eax
   10e65:	83 c4 10             	add    $0x10,%esp
   10e68:	89 45 f0             	mov    %eax,-0x10(%ebp)
            frame->eax=ret;
   10e6b:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10e6e:	8b 45 08             	mov    0x8(%ebp),%eax
   10e71:	89 50 30             	mov    %edx,0x30(%eax)
            return;
   10e74:	eb 30                	jmp    10ea6 <do_handler_syscall+0x8a>
        }
    }

    task_t* task=task_current();
   10e76:	e8 54 07 00 00       	call   115cf <task_current>
   10e7b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    log_printf("task: %s, Unknown syscall: %d",task->name,frame->func_id);
   10e7e:	8b 45 08             	mov    0x8(%ebp),%eax
   10e81:	8b 40 3c             	mov    0x3c(%eax),%eax
   10e84:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10e87:	83 c2 20             	add    $0x20,%edx
   10e8a:	83 ec 04             	sub    $0x4,%esp
   10e8d:	50                   	push   %eax
   10e8e:	52                   	push   %edx
   10e8f:	68 d4 5b 01 00       	push   $0x15bd4
   10e94:	e8 79 49 00 00       	call   15812 <log_printf>
   10e99:	83 c4 10             	add    $0x10,%esp
    frame->eax=-1;
   10e9c:	8b 45 08             	mov    0x8(%ebp),%eax
   10e9f:	c7 40 30 ff ff ff ff 	movl   $0xffffffff,0x30(%eax)
   10ea6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10ea9:	c9                   	leave  
   10eaa:	c3                   	ret    

00010eab <read_cr0>:
static inline uint32_t read_cr0(void){
   10eab:	55                   	push   %ebp
   10eac:	89 e5                	mov    %esp,%ebp
   10eae:	83 ec 10             	sub    $0x10,%esp
    __asm__ __volatile__(
   10eb1:	0f 20 c0             	mov    %cr0,%eax
   10eb4:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return cr0;
   10eb7:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   10eba:	c9                   	leave  
   10ebb:	c3                   	ret    

00010ebc <write_cr0>:
static inline void write_cr0(uint32_t v){
   10ebc:	55                   	push   %ebp
   10ebd:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   10ebf:	8b 45 08             	mov    0x8(%ebp),%eax
   10ec2:	0f 22 c0             	mov    %eax,%cr0
}
   10ec5:	90                   	nop
   10ec6:	5d                   	pop    %ebp
   10ec7:	c3                   	ret    

00010ec8 <hlt>:
static inline void hlt(void){
   10ec8:	55                   	push   %ebp
   10ec9:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile("hlt");
   10ecb:	f4                   	hlt    
}
   10ecc:	90                   	nop
   10ecd:	5d                   	pop    %ebp
   10ece:	c3                   	ret    

00010ecf <write_tr>:
static inline void write_tr(uint16_t tss_sel){
   10ecf:	55                   	push   %ebp
   10ed0:	89 e5                	mov    %esp,%ebp
   10ed2:	83 ec 04             	sub    $0x4,%esp
   10ed5:	8b 45 08             	mov    0x8(%ebp),%eax
   10ed8:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    __asm__ __volatile__(
   10edc:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
   10ee0:	0f 00 d8             	ltr    %ax
}
   10ee3:	90                   	nop
   10ee4:	c9                   	leave  
   10ee5:	c3                   	ret    

00010ee6 <write_cr3>:
static inline void write_cr3(uint32_t v){
   10ee6:	55                   	push   %ebp
   10ee7:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   10ee9:	8b 45 08             	mov    0x8(%ebp),%eax
   10eec:	0f 22 d8             	mov    %eax,%cr3
}
   10eef:	90                   	nop
   10ef0:	5d                   	pop    %ebp
   10ef1:	c3                   	ret    

00010ef2 <write_cr4>:
static inline void write_cr4(uint32_t v){
   10ef2:	55                   	push   %ebp
   10ef3:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   10ef5:	8b 45 08             	mov    0x8(%ebp),%eax
   10ef8:	0f 22 e0             	mov    %eax,%cr4
}
   10efb:	90                   	nop
   10efc:	5d                   	pop    %ebp
   10efd:	c3                   	ret    

00010efe <read_cr4>:
static inline uint32_t read_cr4(void){
   10efe:	55                   	push   %ebp
   10eff:	89 e5                	mov    %esp,%ebp
   10f01:	83 ec 10             	sub    $0x10,%esp
    __asm__ __volatile__(
   10f04:	0f 20 e0             	mov    %cr4,%eax
   10f07:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return cr4;
   10f0a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   10f0d:	c9                   	leave  
   10f0e:	c3                   	ret    

00010f0f <list_node_init>:
typedef struct _list_node_t{
    struct _list_node_t*pre;
    struct _list_node_t*next;
}list_node_t;

static inline void list_node_init(list_node_t* node){
   10f0f:	55                   	push   %ebp
   10f10:	89 e5                	mov    %esp,%ebp
    node->pre=node->next=(list_node_t*)0;
   10f12:	8b 45 08             	mov    0x8(%ebp),%eax
   10f15:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   10f1c:	8b 45 08             	mov    0x8(%ebp),%eax
   10f1f:	8b 50 04             	mov    0x4(%eax),%edx
   10f22:	8b 45 08             	mov    0x8(%ebp),%eax
   10f25:	89 10                	mov    %edx,(%eax)
}
   10f27:	90                   	nop
   10f28:	5d                   	pop    %ebp
   10f29:	c3                   	ret    

00010f2a <list_node_next>:

static inline list_node_t* list_node_pre(list_node_t* node){
    return node->pre;
}

static inline list_node_t* list_node_next(list_node_t* node){
   10f2a:	55                   	push   %ebp
   10f2b:	89 e5                	mov    %esp,%ebp
    return node->next;
   10f2d:	8b 45 08             	mov    0x8(%ebp),%eax
   10f30:	8b 40 04             	mov    0x4(%eax),%eax
}
   10f33:	5d                   	pop    %ebp
   10f34:	c3                   	ret    

00010f35 <list_count>:
void list_init(list_t* list);
static inline int list_is_empty(list_t* list){
    return list->count==0;
}

static inline int list_count(list_t* list){
   10f35:	55                   	push   %ebp
   10f36:	89 e5                	mov    %esp,%ebp
    return list->count;
   10f38:	8b 45 08             	mov    0x8(%ebp),%eax
   10f3b:	8b 40 08             	mov    0x8(%eax),%eax
}
   10f3e:	5d                   	pop    %ebp
   10f3f:	c3                   	ret    

00010f40 <list_first>:

static inline list_node_t* list_first(list_t* list){
   10f40:	55                   	push   %ebp
   10f41:	89 e5                	mov    %esp,%ebp
    return list->first;
   10f43:	8b 45 08             	mov    0x8(%ebp),%eax
   10f46:	8b 00                	mov    (%eax),%eax
}
   10f48:	5d                   	pop    %ebp
   10f49:	c3                   	ret    

00010f4a <mmu_set_page_dir>:
static inline void mmu_set_page_dir(uint32_t paddr){
   10f4a:	55                   	push   %ebp
   10f4b:	89 e5                	mov    %esp,%ebp
   10f4d:	83 ec 10             	sub    $0x10,%esp
    uint32_t cr4=read_cr4();
   10f50:	e8 a9 ff ff ff       	call   10efe <read_cr4>
   10f55:	89 45 fc             	mov    %eax,-0x4(%ebp)
	write_cr4(cr4|CR4_PSE);
   10f58:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10f5b:	83 c8 10             	or     $0x10,%eax
   10f5e:	50                   	push   %eax
   10f5f:	e8 8e ff ff ff       	call   10ef2 <write_cr4>
   10f64:	83 c4 04             	add    $0x4,%esp
	write_cr3(paddr);
   10f67:	ff 75 08             	pushl  0x8(%ebp)
   10f6a:	e8 77 ff ff ff       	call   10ee6 <write_cr3>
   10f6f:	83 c4 04             	add    $0x4,%esp
	write_cr0(read_cr0()|CR0_PG);
   10f72:	e8 34 ff ff ff       	call   10eab <read_cr0>
   10f77:	0d 00 00 00 80       	or     $0x80000000,%eax
   10f7c:	50                   	push   %eax
   10f7d:	e8 3a ff ff ff       	call   10ebc <write_cr0>
   10f82:	83 c4 04             	add    $0x4,%esp
}
   10f85:	90                   	nop
   10f86:	c9                   	leave  
   10f87:	c3                   	ret    

00010f88 <tss_init>:
static task_manager_t task_manager;
static uint32_t idle_task_stack[IDLE_TASK_SIZE];
static task_t task_table[TASK_NR];
static mutex_t table_mutex;

static int tss_init(task_t* task,int flag,uint32_t entry,uint32_t esp){
   10f88:	55                   	push   %ebp
   10f89:	89 e5                	mov    %esp,%ebp
   10f8b:	83 ec 28             	sub    $0x28,%esp
    int tss_sel=gdt_alloc_desc();
   10f8e:	e8 90 12 00 00       	call   12223 <gdt_alloc_desc>
   10f93:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(tss_sel<0){
   10f96:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10f9a:	79 1a                	jns    10fb6 <tss_init+0x2e>
        log_printf("alloc tss failed.\n");
   10f9c:	83 ec 0c             	sub    $0xc,%esp
   10f9f:	68 f4 5b 01 00       	push   $0x15bf4
   10fa4:	e8 69 48 00 00       	call   15812 <log_printf>
   10fa9:	83 c4 10             	add    $0x10,%esp
        return -1;
   10fac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10fb1:	e9 6b 01 00 00       	jmp    11121 <tss_init+0x199>
    }
    segment_desc_set(tss_sel,(uint32_t)&task->tss,sizeof(tss_t),
   10fb6:	8b 45 08             	mov    0x8(%ebp),%eax
   10fb9:	05 58 02 00 00       	add    $0x258,%eax
   10fbe:	68 89 00 00 00       	push   $0x89
   10fc3:	6a 68                	push   $0x68
   10fc5:	50                   	push   %eax
   10fc6:	ff 75 ec             	pushl  -0x14(%ebp)
   10fc9:	e8 df 10 00 00       	call   120ad <segment_desc_set>
   10fce:	83 c4 10             	add    $0x10,%esp
        SEG_P_PRESENT | SEG_DPL0 | SEG_TYPE_TSS
    );
    kernel_memset(&task->tss,0,sizeof(tss_t));
   10fd1:	8b 45 08             	mov    0x8(%ebp),%eax
   10fd4:	05 58 02 00 00       	add    $0x258,%eax
   10fd9:	83 ec 04             	sub    $0x4,%esp
   10fdc:	6a 68                	push   $0x68
   10fde:	6a 00                	push   $0x0
   10fe0:	50                   	push   %eax
   10fe1:	e8 09 42 00 00       	call   151ef <kernel_memset>
   10fe6:	83 c4 10             	add    $0x10,%esp

    uint32_t kernel_stack=memory_alloc_page();
   10fe9:	e8 38 f9 ff ff       	call   10926 <memory_alloc_page>
   10fee:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(kernel_stack == 0){
   10ff1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   10ff5:	0f 84 fb 00 00 00    	je     110f6 <tss_init+0x16e>
        goto tss_init_failed;
    }
    
    int code_sel,data_sel;
    if(flag & TASK_FLAGS_SYSTEM){
   10ffb:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ffe:	83 e0 01             	and    $0x1,%eax
   11001:	85 c0                	test   %eax,%eax
   11003:	74 10                	je     11015 <tss_init+0x8d>
        code_sel=KERNEL_SELECTOR_CS;
   11005:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%ebp)
        data_sel=KERNEL_SELECTOR_DS;
   1100c:	c7 45 f0 10 00 00 00 	movl   $0x10,-0x10(%ebp)
   11013:	eb 16                	jmp    1102b <tss_init+0xa3>
    }
    else{
        code_sel=task_manager.app_code_sel | SEG_CPL3;
   11015:	a1 b0 a5 01 00       	mov    0x1a5b0,%eax
   1101a:	83 c8 03             	or     $0x3,%eax
   1101d:	89 45 f4             	mov    %eax,-0xc(%ebp)
        data_sel=task_manager.app_data_sel | SEG_CPL3;
   11020:	a1 b4 a5 01 00       	mov    0x1a5b4,%eax
   11025:	83 c8 03             	or     $0x3,%eax
   11028:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    task->tss.eip=entry;
   1102b:	8b 45 08             	mov    0x8(%ebp),%eax
   1102e:	8b 55 10             	mov    0x10(%ebp),%edx
   11031:	89 90 78 02 00 00    	mov    %edx,0x278(%eax)
    task->tss.esp=esp;
   11037:	8b 45 08             	mov    0x8(%ebp),%eax
   1103a:	8b 55 14             	mov    0x14(%ebp),%edx
   1103d:	89 90 90 02 00 00    	mov    %edx,0x290(%eax)
    task->tss.esp0=kernel_stack+MEM_PAGE_SIZE;
   11043:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11046:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
   1104c:	8b 45 08             	mov    0x8(%ebp),%eax
   1104f:	89 90 5c 02 00 00    	mov    %edx,0x25c(%eax)
    task->tss.ss=data_sel;
   11055:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11058:	8b 45 08             	mov    0x8(%ebp),%eax
   1105b:	89 90 a8 02 00 00    	mov    %edx,0x2a8(%eax)
    task->tss.ss0=KERNEL_SELECTOR_DS;
   11061:	8b 45 08             	mov    0x8(%ebp),%eax
   11064:	c7 80 60 02 00 00 10 	movl   $0x10,0x260(%eax)
   1106b:	00 00 00 
    task->tss.es=task->tss.ds=task->tss.fs=task->tss.gs=data_sel;
   1106e:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11071:	8b 45 08             	mov    0x8(%ebp),%eax
   11074:	89 90 b4 02 00 00    	mov    %edx,0x2b4(%eax)
   1107a:	8b 45 08             	mov    0x8(%ebp),%eax
   1107d:	8b 90 b4 02 00 00    	mov    0x2b4(%eax),%edx
   11083:	8b 45 08             	mov    0x8(%ebp),%eax
   11086:	89 90 b0 02 00 00    	mov    %edx,0x2b0(%eax)
   1108c:	8b 45 08             	mov    0x8(%ebp),%eax
   1108f:	8b 90 b0 02 00 00    	mov    0x2b0(%eax),%edx
   11095:	8b 45 08             	mov    0x8(%ebp),%eax
   11098:	89 90 ac 02 00 00    	mov    %edx,0x2ac(%eax)
   1109e:	8b 45 08             	mov    0x8(%ebp),%eax
   110a1:	8b 90 ac 02 00 00    	mov    0x2ac(%eax),%edx
   110a7:	8b 45 08             	mov    0x8(%ebp),%eax
   110aa:	89 90 a0 02 00 00    	mov    %edx,0x2a0(%eax)
    task->tss.cs=code_sel;
   110b0:	8b 55 f4             	mov    -0xc(%ebp),%edx
   110b3:	8b 45 08             	mov    0x8(%ebp),%eax
   110b6:	89 90 a4 02 00 00    	mov    %edx,0x2a4(%eax)
    task->tss.eflags=EFLAGS_DEFAULT | EFLAGS_IF;
   110bc:	8b 45 08             	mov    0x8(%ebp),%eax
   110bf:	c7 80 7c 02 00 00 02 	movl   $0x202,0x27c(%eax)
   110c6:	02 00 00 

    uint32_t page_dir=memory_create_uvm();
   110c9:	e8 fa f6 ff ff       	call   107c8 <memory_create_uvm>
   110ce:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(page_dir == 0){
   110d1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   110d5:	74 22                	je     110f9 <tss_init+0x171>
        goto tss_init_failed;
    }
    task->tss.cr3=page_dir;
   110d7:	8b 45 08             	mov    0x8(%ebp),%eax
   110da:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   110dd:	89 90 74 02 00 00    	mov    %edx,0x274(%eax)
    task->tss_sel=tss_sel;
   110e3:	8b 45 08             	mov    0x8(%ebp),%eax
   110e6:	8b 55 ec             	mov    -0x14(%ebp),%edx
   110e9:	89 90 c0 02 00 00    	mov    %edx,0x2c0(%eax)
    return 0;
   110ef:	b8 00 00 00 00       	mov    $0x0,%eax
   110f4:	eb 2b                	jmp    11121 <tss_init+0x199>
        goto tss_init_failed;
   110f6:	90                   	nop
   110f7:	eb 01                	jmp    110fa <tss_init+0x172>
        goto tss_init_failed;
   110f9:	90                   	nop
tss_init_failed:
    gdt_free_sel(tss_sel);
   110fa:	83 ec 0c             	sub    $0xc,%esp
   110fd:	ff 75 ec             	pushl  -0x14(%ebp)
   11100:	e8 a7 11 00 00       	call   122ac <gdt_free_sel>
   11105:	83 c4 10             	add    $0x10,%esp
    if(kernel_stack){
   11108:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1110c:	74 0e                	je     1111c <tss_init+0x194>
        memory_free_page(kernel_stack);
   1110e:	83 ec 0c             	sub    $0xc,%esp
   11111:	ff 75 e8             	pushl  -0x18(%ebp)
   11114:	e8 40 f8 ff ff       	call   10959 <memory_free_page>
   11119:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   1111c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
   11121:	c9                   	leave  
   11122:	c3                   	ret    

00011123 <task_init>:

int task_init(task_t* task,const char*name,int flag,uint32_t entry,uint32_t esp){
   11123:	55                   	push   %ebp
   11124:	89 e5                	mov    %esp,%ebp
   11126:	83 ec 18             	sub    $0x18,%esp
    ASSERT(task!=(task_t*)0);
   11129:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1112d:	75 19                	jne    11148 <task_init+0x25>
   1112f:	68 07 5c 01 00       	push   $0x15c07
   11134:	68 18 5d 01 00       	push   $0x15d18
   11139:	6a 41                	push   $0x41
   1113b:	68 18 5c 01 00       	push   $0x15c18
   11140:	e8 fd 43 00 00       	call   15542 <panic>
   11145:	83 c4 10             	add    $0x10,%esp
    int err=tss_init(task,flag,entry,esp);
   11148:	ff 75 18             	pushl  0x18(%ebp)
   1114b:	ff 75 14             	pushl  0x14(%ebp)
   1114e:	ff 75 10             	pushl  0x10(%ebp)
   11151:	ff 75 08             	pushl  0x8(%ebp)
   11154:	e8 2f fe ff ff       	call   10f88 <tss_init>
   11159:	83 c4 10             	add    $0x10,%esp
   1115c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(err<0){
   1115f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11163:	79 18                	jns    1117d <task_init+0x5a>
        log_printf("init task failed.");
   11165:	83 ec 0c             	sub    $0xc,%esp
   11168:	68 4b 5c 01 00       	push   $0x15c4b
   1116d:	e8 a0 46 00 00       	call   15812 <log_printf>
   11172:	83 c4 10             	add    $0x10,%esp
        return err;
   11175:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11178:	e9 f0 00 00 00       	jmp    1126d <task_init+0x14a>
    }
    kernel_strncpy(task->name,name,TASK_NAME_SIZE);
   1117d:	8b 45 08             	mov    0x8(%ebp),%eax
   11180:	83 c0 20             	add    $0x20,%eax
   11183:	83 ec 04             	sub    $0x4,%esp
   11186:	6a 20                	push   $0x20
   11188:	ff 75 0c             	pushl  0xc(%ebp)
   1118b:	50                   	push   %eax
   1118c:	e8 ea 3e 00 00       	call   1507b <kernel_strncpy>
   11191:	83 c4 10             	add    $0x10,%esp

    task->state=TASK_CREATED;
   11194:	8b 45 08             	mov    0x8(%ebp),%eax
   11197:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    task->time_ticks=TASK_TIME_SLICE_DEFAULT;
   1119d:	8b 45 08             	mov    0x8(%ebp),%eax
   111a0:	c7 40 1c 0a 00 00 00 	movl   $0xa,0x1c(%eax)
    task->slice_ticks=task->time_ticks;
   111a7:	8b 45 08             	mov    0x8(%ebp),%eax
   111aa:	8b 50 1c             	mov    0x1c(%eax),%edx
   111ad:	8b 45 08             	mov    0x8(%ebp),%eax
   111b0:	89 50 18             	mov    %edx,0x18(%eax)
    task->sleep_ticks=0;
   111b3:	8b 45 08             	mov    0x8(%ebp),%eax
   111b6:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
    
    list_node_init(&task->all_node);
   111bd:	8b 45 08             	mov    0x8(%ebp),%eax
   111c0:	05 48 02 00 00       	add    $0x248,%eax
   111c5:	83 ec 0c             	sub    $0xc,%esp
   111c8:	50                   	push   %eax
   111c9:	e8 41 fd ff ff       	call   10f0f <list_node_init>
   111ce:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->run_node);
   111d1:	8b 45 08             	mov    0x8(%ebp),%eax
   111d4:	05 40 02 00 00       	add    $0x240,%eax
   111d9:	83 ec 0c             	sub    $0xc,%esp
   111dc:	50                   	push   %eax
   111dd:	e8 2d fd ff ff       	call   10f0f <list_node_init>
   111e2:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->wait_node);
   111e5:	8b 45 08             	mov    0x8(%ebp),%eax
   111e8:	05 50 02 00 00       	add    $0x250,%eax
   111ed:	83 ec 0c             	sub    $0xc,%esp
   111f0:	50                   	push   %eax
   111f1:	e8 19 fd ff ff       	call   10f0f <list_node_init>
   111f6:	83 c4 10             	add    $0x10,%esp
    
    irq_state_t state=irq_enter_protection();
   111f9:	e8 0f 1a 00 00       	call   12c0d <irq_enter_protection>
   111fe:	89 45 f0             	mov    %eax,-0x10(%ebp)

    task->pid=(uint32_t)task;
   11201:	8b 55 08             	mov    0x8(%ebp),%edx
   11204:	8b 45 08             	mov    0x8(%ebp),%eax
   11207:	89 50 04             	mov    %edx,0x4(%eax)
    task->parent=(task_t*)0;
   1120a:	8b 45 08             	mov    0x8(%ebp),%eax
   1120d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    task->heap_start=0;
   11214:	8b 45 08             	mov    0x8(%ebp),%eax
   11217:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    task->heap_end=0;
   1121e:	8b 45 08             	mov    0x8(%ebp),%eax
   11221:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

    // 对task->file_table进行初始化
    kernel_memset(&task->file_table,0,sizeof(task->file_table));
   11228:	8b 45 08             	mov    0x8(%ebp),%eax
   1122b:	83 c0 40             	add    $0x40,%eax
   1122e:	83 ec 04             	sub    $0x4,%esp
   11231:	68 00 02 00 00       	push   $0x200
   11236:	6a 00                	push   $0x0
   11238:	50                   	push   %eax
   11239:	e8 b1 3f 00 00       	call   151ef <kernel_memset>
   1123e:	83 c4 10             	add    $0x10,%esp

    list_insert_last(&task_manager.task_list,&task->all_node);
   11241:	8b 45 08             	mov    0x8(%ebp),%eax
   11244:	05 48 02 00 00       	add    $0x248,%eax
   11249:	83 ec 08             	sub    $0x8,%esp
   1124c:	50                   	push   %eax
   1124d:	68 10 a0 01 00       	push   $0x1a010
   11252:	e8 2b 44 00 00       	call   15682 <list_insert_last>
   11257:	83 c4 10             	add    $0x10,%esp
    irq_leave_protection(state);
   1125a:	83 ec 0c             	sub    $0xc,%esp
   1125d:	ff 75 f0             	pushl  -0x10(%ebp)
   11260:	e8 c0 19 00 00       	call   12c25 <irq_leave_protection>
   11265:	83 c4 10             	add    $0x10,%esp

    return 0;
   11268:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1126d:	c9                   	leave  
   1126e:	c3                   	ret    

0001126f <task_start>:

void task_start(task_t* task){
   1126f:	55                   	push   %ebp
   11270:	89 e5                	mov    %esp,%ebp
   11272:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   11275:	e8 93 19 00 00       	call   12c0d <irq_enter_protection>
   1127a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_set_ready(task);
   1127d:	83 ec 0c             	sub    $0xc,%esp
   11280:	ff 75 08             	pushl  0x8(%ebp)
   11283:	e8 9f 02 00 00       	call   11527 <task_set_ready>
   11288:	83 c4 10             	add    $0x10,%esp
    irq_leave_protection(state);
   1128b:	83 ec 0c             	sub    $0xc,%esp
   1128e:	ff 75 f4             	pushl  -0xc(%ebp)
   11291:	e8 8f 19 00 00       	call   12c25 <irq_leave_protection>
   11296:	83 c4 10             	add    $0x10,%esp
}
   11299:	90                   	nop
   1129a:	c9                   	leave  
   1129b:	c3                   	ret    

0001129c <task_uninit>:

void task_uninit(task_t* task){
   1129c:	55                   	push   %ebp
   1129d:	89 e5                	mov    %esp,%ebp
   1129f:	83 ec 08             	sub    $0x8,%esp
    if(task->tss_sel){
   112a2:	8b 45 08             	mov    0x8(%ebp),%eax
   112a5:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
   112ab:	85 c0                	test   %eax,%eax
   112ad:	74 15                	je     112c4 <task_uninit+0x28>
        gdt_free_sel(task->tss_sel);
   112af:	8b 45 08             	mov    0x8(%ebp),%eax
   112b2:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
   112b8:	83 ec 0c             	sub    $0xc,%esp
   112bb:	50                   	push   %eax
   112bc:	e8 eb 0f 00 00       	call   122ac <gdt_free_sel>
   112c1:	83 c4 10             	add    $0x10,%esp
    }

    if(task->tss.esp0){
   112c4:	8b 45 08             	mov    0x8(%ebp),%eax
   112c7:	8b 80 5c 02 00 00    	mov    0x25c(%eax),%eax
   112cd:	85 c0                	test   %eax,%eax
   112cf:	74 1a                	je     112eb <task_uninit+0x4f>
        memory_free_page(task->tss.esp-MEM_PAGE_SIZE);
   112d1:	8b 45 08             	mov    0x8(%ebp),%eax
   112d4:	8b 80 90 02 00 00    	mov    0x290(%eax),%eax
   112da:	2d 00 10 00 00       	sub    $0x1000,%eax
   112df:	83 ec 0c             	sub    $0xc,%esp
   112e2:	50                   	push   %eax
   112e3:	e8 71 f6 ff ff       	call   10959 <memory_free_page>
   112e8:	83 c4 10             	add    $0x10,%esp
    }

    if(task->tss.cr3){
   112eb:	8b 45 08             	mov    0x8(%ebp),%eax
   112ee:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
   112f4:	85 c0                	test   %eax,%eax
   112f6:	74 15                	je     1130d <task_uninit+0x71>
        memory_destroy_uvm(task->tss.cr3);
   112f8:	8b 45 08             	mov    0x8(%ebp),%eax
   112fb:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
   11301:	83 ec 0c             	sub    $0xc,%esp
   11304:	50                   	push   %eax
   11305:	e8 e8 f6 ff ff       	call   109f2 <memory_destroy_uvm>
   1130a:	83 c4 10             	add    $0x10,%esp
    }

    kernel_memset(task,0,sizeof(task));
   1130d:	83 ec 04             	sub    $0x4,%esp
   11310:	6a 04                	push   $0x4
   11312:	6a 00                	push   $0x0
   11314:	ff 75 08             	pushl  0x8(%ebp)
   11317:	e8 d3 3e 00 00       	call   151ef <kernel_memset>
   1131c:	83 c4 10             	add    $0x10,%esp
}
   1131f:	90                   	nop
   11320:	c9                   	leave  
   11321:	c3                   	ret    

00011322 <task_switch_from_to>:

void task_switch_from_to(task_t*from,task_t*to){
   11322:	55                   	push   %ebp
   11323:	89 e5                	mov    %esp,%ebp
   11325:	83 ec 08             	sub    $0x8,%esp
    switch_to_tss(to->tss_sel);
   11328:	8b 45 0c             	mov    0xc(%ebp),%eax
   1132b:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
   11331:	83 ec 0c             	sub    $0xc,%esp
   11334:	50                   	push   %eax
   11335:	e8 5e 0f 00 00       	call   12298 <switch_to_tss>
   1133a:	83 c4 10             	add    $0x10,%esp
}
   1133d:	90                   	nop
   1133e:	c9                   	leave  
   1133f:	c3                   	ret    

00011340 <idle_task_entry>:

static void idle_task_entry(void){
   11340:	55                   	push   %ebp
   11341:	89 e5                	mov    %esp,%ebp
    for(;;){
        hlt();
   11343:	e8 80 fb ff ff       	call   10ec8 <hlt>
   11348:	eb f9                	jmp    11343 <idle_task_entry+0x3>

0001134a <task_manager_init>:
    }
}

void task_manager_init(void){
   1134a:	55                   	push   %ebp
   1134b:	89 e5                	mov    %esp,%ebp
   1134d:	83 ec 18             	sub    $0x18,%esp

    kernel_memset(task_table,0,sizeof(task_table));
   11350:	83 ec 04             	sub    $0x4,%esp
   11353:	68 00 62 01 00       	push   $0x16200
   11358:	6a 00                	push   $0x0
   1135a:	68 c0 b5 01 00       	push   $0x1b5c0
   1135f:	e8 8b 3e 00 00       	call   151ef <kernel_memset>
   11364:	83 c4 10             	add    $0x10,%esp
    mutex_init(&table_mutex);
   11367:	83 ec 0c             	sub    $0xc,%esp
   1136a:	68 c0 17 03 00       	push   $0x317c0
   1136f:	e8 83 37 00 00       	call   14af7 <mutex_init>
   11374:	83 c4 10             	add    $0x10,%esp

    int sel=gdt_alloc_desc();
   11377:	e8 a7 0e 00 00       	call   12223 <gdt_alloc_desc>
   1137c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    segment_desc_set(sel,0x0,0xFFFFFFFF,
   1137f:	68 f2 40 00 00       	push   $0x40f2
   11384:	6a ff                	push   $0xffffffff
   11386:	6a 00                	push   $0x0
   11388:	ff 75 f4             	pushl  -0xc(%ebp)
   1138b:	e8 1d 0d 00 00       	call   120ad <segment_desc_set>
   11390:	83 c4 10             	add    $0x10,%esp
        SEG_P_PRESENT | SEG_DPL3 | SEG_S_NORMAL | SEG_TYPE_DATA | SEG_TYPE_RW | SEG_D
    );
    task_manager.app_data_sel=sel;
   11393:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11396:	a3 b4 a5 01 00       	mov    %eax,0x1a5b4

    sel=gdt_alloc_desc();
   1139b:	e8 83 0e 00 00       	call   12223 <gdt_alloc_desc>
   113a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    segment_desc_set(sel,0x0,0xFFFFFFFF,
   113a3:	68 fa 40 00 00       	push   $0x40fa
   113a8:	6a ff                	push   $0xffffffff
   113aa:	6a 00                	push   $0x0
   113ac:	ff 75 f4             	pushl  -0xc(%ebp)
   113af:	e8 f9 0c 00 00       	call   120ad <segment_desc_set>
   113b4:	83 c4 10             	add    $0x10,%esp
           SEG_P_PRESENT | SEG_DPL3 | SEG_S_NORMAL |SEG_TYPE_CODE | SEG_TYPE_RW | SEG_D
    );
    task_manager.app_code_sel=sel;
   113b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   113ba:	a3 b0 a5 01 00       	mov    %eax,0x1a5b0

    list_init(&task_manager.ready_list);
   113bf:	83 ec 0c             	sub    $0xc,%esp
   113c2:	68 04 a0 01 00       	push   $0x1a004
   113c7:	e8 32 42 00 00       	call   155fe <list_init>
   113cc:	83 c4 10             	add    $0x10,%esp
    list_init(&task_manager.task_list);
   113cf:	83 ec 0c             	sub    $0xc,%esp
   113d2:	68 10 a0 01 00       	push   $0x1a010
   113d7:	e8 22 42 00 00       	call   155fe <list_init>
   113dc:	83 c4 10             	add    $0x10,%esp
    list_init(&task_manager.sleep_list);
   113df:	83 ec 0c             	sub    $0xc,%esp
   113e2:	68 1c a0 01 00       	push   $0x1a01c
   113e7:	e8 12 42 00 00       	call   155fe <list_init>
   113ec:	83 c4 10             	add    $0x10,%esp
    task_manager.curr_task=(task_t*)0;
   113ef:	c7 05 00 a0 01 00 00 	movl   $0x0,0x1a000
   113f6:	00 00 00 
    task_init(&task_manager.idle_task,"idle_task",TASK_FLAGS_SYSTEM,(uint32_t)idle_task_entry,
    (uint32_t)(idle_task_stack+IDLE_TASK_SIZE));
   113f9:	b8 c0 b5 01 00       	mov    $0x1b5c0,%eax
    task_init(&task_manager.idle_task,"idle_task",TASK_FLAGS_SYSTEM,(uint32_t)idle_task_entry,
   113fe:	89 c2                	mov    %eax,%edx
   11400:	b8 40 13 01 00       	mov    $0x11340,%eax
   11405:	83 ec 0c             	sub    $0xc,%esp
   11408:	52                   	push   %edx
   11409:	50                   	push   %eax
   1140a:	6a 01                	push   $0x1
   1140c:	68 5d 5c 01 00       	push   $0x15c5d
   11411:	68 ec a2 01 00       	push   $0x1a2ec
   11416:	e8 08 fd ff ff       	call   11123 <task_init>
   1141b:	83 c4 20             	add    $0x20,%esp

    task_start(&task_manager.idle_task);
   1141e:	83 ec 0c             	sub    $0xc,%esp
   11421:	68 ec a2 01 00       	push   $0x1a2ec
   11426:	e8 44 fe ff ff       	call   1126f <task_start>
   1142b:	83 c4 10             	add    $0x10,%esp
}
   1142e:	90                   	nop
   1142f:	c9                   	leave  
   11430:	c3                   	ret    

00011431 <task_first_init>:

void task_first_init(void){
   11431:	55                   	push   %ebp
   11432:	89 e5                	mov    %esp,%ebp
   11434:	83 ec 18             	sub    $0x18,%esp
    void first_task_entry(void);
    extern uint8_t s_first_task[],e_first_task[];

    uint32_t copy_size=(uint32_t)(e_first_task-s_first_task);
   11437:	ba 24 c7 06 00       	mov    $0x6c724,%edx
   1143c:	b8 e0 c3 06 00       	mov    $0x6c3e0,%eax
   11441:	29 c2                	sub    %eax,%edx
   11443:	89 d0                	mov    %edx,%eax
   11445:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t alloc_size=10*MEM_PAGE_SIZE;
   11448:	c7 45 f0 00 a0 00 00 	movl   $0xa000,-0x10(%ebp)
    ASSERT(copy_size < alloc_size);
   1144f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11452:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   11455:	72 1c                	jb     11473 <task_first_init+0x42>
   11457:	68 67 5c 01 00       	push   $0x15c67
   1145c:	68 24 5d 01 00       	push   $0x15d24
   11461:	68 a3 00 00 00       	push   $0xa3
   11466:	68 18 5c 01 00       	push   $0x15c18
   1146b:	e8 d2 40 00 00       	call   15542 <panic>
   11470:	83 c4 10             	add    $0x10,%esp

    uint32_t first_start=(uint32_t)first_task_entry;
   11473:	c7 45 ec 00 00 00 80 	movl   $0x80000000,-0x14(%ebp)

    task_init(&task_manager.first_task,"first task",0,first_start,first_start+alloc_size);
   1147a:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1147d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11480:	01 d0                	add    %edx,%eax
   11482:	83 ec 0c             	sub    $0xc,%esp
   11485:	50                   	push   %eax
   11486:	ff 75 ec             	pushl  -0x14(%ebp)
   11489:	6a 00                	push   $0x0
   1148b:	68 7e 5c 01 00       	push   $0x15c7e
   11490:	68 28 a0 01 00       	push   $0x1a028
   11495:	e8 89 fc ff ff       	call   11123 <task_init>
   1149a:	83 c4 20             	add    $0x20,%esp

    task_manager.first_task.heap_start=(uint32_t)e_first_task;
   1149d:	b8 24 c7 06 00       	mov    $0x6c724,%eax
   114a2:	a3 34 a0 01 00       	mov    %eax,0x1a034
    task_manager.first_task.heap_end=(uint32_t)e_first_task;
   114a7:	b8 24 c7 06 00       	mov    $0x6c724,%eax
   114ac:	a3 38 a0 01 00       	mov    %eax,0x1a038

    write_tr(task_manager.first_task.tss_sel);
   114b1:	a1 e8 a2 01 00       	mov    0x1a2e8,%eax
   114b6:	0f b7 c0             	movzwl %ax,%eax
   114b9:	83 ec 0c             	sub    $0xc,%esp
   114bc:	50                   	push   %eax
   114bd:	e8 0d fa ff ff       	call   10ecf <write_tr>
   114c2:	83 c4 10             	add    $0x10,%esp
    task_manager.curr_task=&task_manager.first_task;
   114c5:	c7 05 00 a0 01 00 28 	movl   $0x1a028,0x1a000
   114cc:	a0 01 00 

    mmu_set_page_dir(task_manager.first_task.tss.cr3);
   114cf:	a1 9c a2 01 00       	mov    0x1a29c,%eax
   114d4:	83 ec 0c             	sub    $0xc,%esp
   114d7:	50                   	push   %eax
   114d8:	e8 6d fa ff ff       	call   10f4a <mmu_set_page_dir>
   114dd:	83 c4 10             	add    $0x10,%esp

    memory_alloc_page_for(first_start,alloc_size,PTE_P | PTE_W | PTE_U);
   114e0:	83 ec 04             	sub    $0x4,%esp
   114e3:	6a 07                	push   $0x7
   114e5:	ff 75 f0             	pushl  -0x10(%ebp)
   114e8:	ff 75 ec             	pushl  -0x14(%ebp)
   114eb:	e8 11 f4 ff ff       	call   10901 <memory_alloc_page_for>
   114f0:	83 c4 10             	add    $0x10,%esp
    kernel_memcpy((void*)first_start,s_first_task,copy_size);
   114f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   114f6:	83 ec 04             	sub    $0x4,%esp
   114f9:	ff 75 f4             	pushl  -0xc(%ebp)
   114fc:	68 e0 c3 06 00       	push   $0x6c3e0
   11501:	50                   	push   %eax
   11502:	e8 99 3c 00 00       	call   151a0 <kernel_memcpy>
   11507:	83 c4 10             	add    $0x10,%esp

    task_start(&task_manager.first_task);
   1150a:	83 ec 0c             	sub    $0xc,%esp
   1150d:	68 28 a0 01 00       	push   $0x1a028
   11512:	e8 58 fd ff ff       	call   1126f <task_start>
   11517:	83 c4 10             	add    $0x10,%esp
}
   1151a:	90                   	nop
   1151b:	c9                   	leave  
   1151c:	c3                   	ret    

0001151d <task_first_task>:

task_t* task_first_task(void){
   1151d:	55                   	push   %ebp
   1151e:	89 e5                	mov    %esp,%ebp
    return &task_manager.first_task;
   11520:	b8 28 a0 01 00       	mov    $0x1a028,%eax
}
   11525:	5d                   	pop    %ebp
   11526:	c3                   	ret    

00011527 <task_set_ready>:

void task_set_ready(task_t* task){
   11527:	55                   	push   %ebp
   11528:	89 e5                	mov    %esp,%ebp
   1152a:	83 ec 08             	sub    $0x8,%esp
    if(task==&task_manager.idle_task){
   1152d:	81 7d 08 ec a2 01 00 	cmpl   $0x1a2ec,0x8(%ebp)
   11534:	74 24                	je     1155a <task_set_ready+0x33>
        return;
    }
    list_insert_last(&task_manager.ready_list,&task->run_node);
   11536:	8b 45 08             	mov    0x8(%ebp),%eax
   11539:	05 40 02 00 00       	add    $0x240,%eax
   1153e:	83 ec 08             	sub    $0x8,%esp
   11541:	50                   	push   %eax
   11542:	68 04 a0 01 00       	push   $0x1a004
   11547:	e8 36 41 00 00       	call   15682 <list_insert_last>
   1154c:	83 c4 10             	add    $0x10,%esp
    task->state=TASK_READY;
   1154f:	8b 45 08             	mov    0x8(%ebp),%eax
   11552:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   11558:	eb 01                	jmp    1155b <task_set_ready+0x34>
        return;
   1155a:	90                   	nop
}
   1155b:	c9                   	leave  
   1155c:	c3                   	ret    

0001155d <task_set_block>:

void task_set_block(task_t* task){
   1155d:	55                   	push   %ebp
   1155e:	89 e5                	mov    %esp,%ebp
   11560:	83 ec 08             	sub    $0x8,%esp
    if(task==&task_manager.idle_task){
   11563:	81 7d 08 ec a2 01 00 	cmpl   $0x1a2ec,0x8(%ebp)
   1156a:	74 1b                	je     11587 <task_set_block+0x2a>
        return;
    }
    list_remove(&task_manager.ready_list,&task->run_node);
   1156c:	8b 45 08             	mov    0x8(%ebp),%eax
   1156f:	05 40 02 00 00       	add    $0x240,%eax
   11574:	83 ec 08             	sub    $0x8,%esp
   11577:	50                   	push   %eax
   11578:	68 04 a0 01 00       	push   $0x1a004
   1157d:	e8 dc 41 00 00       	call   1575e <list_remove>
   11582:	83 c4 10             	add    $0x10,%esp
   11585:	eb 01                	jmp    11588 <task_set_block+0x2b>
        return;
   11587:	90                   	nop
}
   11588:	c9                   	leave  
   11589:	c3                   	ret    

0001158a <task_next_run>:

task_t* task_next_run(void){
   1158a:	55                   	push   %ebp
   1158b:	89 e5                	mov    %esp,%ebp
   1158d:	83 ec 10             	sub    $0x10,%esp
    if(list_count(&task_manager.ready_list)==0){
   11590:	68 04 a0 01 00       	push   $0x1a004
   11595:	e8 9b f9 ff ff       	call   10f35 <list_count>
   1159a:	83 c4 04             	add    $0x4,%esp
   1159d:	85 c0                	test   %eax,%eax
   1159f:	75 07                	jne    115a8 <task_next_run+0x1e>
        return &task_manager.idle_task;
   115a1:	b8 ec a2 01 00       	mov    $0x1a2ec,%eax
   115a6:	eb 25                	jmp    115cd <task_next_run+0x43>
    }
    list_node_t* task_node=list_first(&task_manager.ready_list);
   115a8:	68 04 a0 01 00       	push   $0x1a004
   115ad:	e8 8e f9 ff ff       	call   10f40 <list_first>
   115b2:	83 c4 04             	add    $0x4,%esp
   115b5:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return list_node_parent(task_node,task_t,run_node);
   115b8:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   115bc:	74 0a                	je     115c8 <task_next_run+0x3e>
   115be:	8b 45 fc             	mov    -0x4(%ebp),%eax
   115c1:	2d 40 02 00 00       	sub    $0x240,%eax
   115c6:	eb 05                	jmp    115cd <task_next_run+0x43>
   115c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
   115cd:	c9                   	leave  
   115ce:	c3                   	ret    

000115cf <task_current>:

task_t* task_current(void){
   115cf:	55                   	push   %ebp
   115d0:	89 e5                	mov    %esp,%ebp
    return task_manager.curr_task;
   115d2:	a1 00 a0 01 00       	mov    0x1a000,%eax
}
   115d7:	5d                   	pop    %ebp
   115d8:	c3                   	ret    

000115d9 <sys_sched_yield>:

int sys_sched_yield(void){
   115d9:	55                   	push   %ebp
   115da:	89 e5                	mov    %esp,%ebp
   115dc:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   115df:	e8 29 16 00 00       	call   12c0d <irq_enter_protection>
   115e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(list_count(&task_manager.ready_list)>1){
   115e7:	83 ec 0c             	sub    $0xc,%esp
   115ea:	68 04 a0 01 00       	push   $0x1a004
   115ef:	e8 41 f9 ff ff       	call   10f35 <list_count>
   115f4:	83 c4 10             	add    $0x10,%esp
   115f7:	83 f8 01             	cmp    $0x1,%eax
   115fa:	7e 29                	jle    11625 <sys_sched_yield+0x4c>
        task_t* curr_task=task_current();
   115fc:	e8 ce ff ff ff       	call   115cf <task_current>
   11601:	89 45 f0             	mov    %eax,-0x10(%ebp)

        task_set_block(curr_task);
   11604:	83 ec 0c             	sub    $0xc,%esp
   11607:	ff 75 f0             	pushl  -0x10(%ebp)
   1160a:	e8 4e ff ff ff       	call   1155d <task_set_block>
   1160f:	83 c4 10             	add    $0x10,%esp
        task_set_ready(curr_task);
   11612:	83 ec 0c             	sub    $0xc,%esp
   11615:	ff 75 f0             	pushl  -0x10(%ebp)
   11618:	e8 0a ff ff ff       	call   11527 <task_set_ready>
   1161d:	83 c4 10             	add    $0x10,%esp

        task_dispatch();
   11620:	e8 15 00 00 00       	call   1163a <task_dispatch>
    }
    irq_leave_protection(state);
   11625:	83 ec 0c             	sub    $0xc,%esp
   11628:	ff 75 f4             	pushl  -0xc(%ebp)
   1162b:	e8 f5 15 00 00       	call   12c25 <irq_leave_protection>
   11630:	83 c4 10             	add    $0x10,%esp
    return 0;
   11633:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11638:	c9                   	leave  
   11639:	c3                   	ret    

0001163a <task_dispatch>:

void task_dispatch(void){
   1163a:	55                   	push   %ebp
   1163b:	89 e5                	mov    %esp,%ebp
   1163d:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   11640:	e8 c8 15 00 00       	call   12c0d <irq_enter_protection>
   11645:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t* to=task_next_run();
   11648:	e8 3d ff ff ff       	call   1158a <task_next_run>
   1164d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(to!=task_manager.curr_task){
   11650:	a1 00 a0 01 00       	mov    0x1a000,%eax
   11655:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11658:	74 2a                	je     11684 <task_dispatch+0x4a>
        task_t* from=task_current();
   1165a:	e8 70 ff ff ff       	call   115cf <task_current>
   1165f:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_manager.curr_task=to;
   11662:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11665:	a3 00 a0 01 00       	mov    %eax,0x1a000
        to->state=TASK_RUNNING;
   1166a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1166d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        task_switch_from_to(from,to);
   11673:	83 ec 08             	sub    $0x8,%esp
   11676:	ff 75 f0             	pushl  -0x10(%ebp)
   11679:	ff 75 ec             	pushl  -0x14(%ebp)
   1167c:	e8 a1 fc ff ff       	call   11322 <task_switch_from_to>
   11681:	83 c4 10             	add    $0x10,%esp
    }
    irq_leave_protection(state);
   11684:	83 ec 0c             	sub    $0xc,%esp
   11687:	ff 75 f4             	pushl  -0xc(%ebp)
   1168a:	e8 96 15 00 00       	call   12c25 <irq_leave_protection>
   1168f:	83 c4 10             	add    $0x10,%esp
}
   11692:	90                   	nop
   11693:	c9                   	leave  
   11694:	c3                   	ret    

00011695 <task_time_tick>:

void task_time_tick(void){
   11695:	55                   	push   %ebp
   11696:	89 e5                	mov    %esp,%ebp
   11698:	83 ec 28             	sub    $0x28,%esp
    irq_state_t state=irq_enter_protection();
   1169b:	e8 6d 15 00 00       	call   12c0d <irq_enter_protection>
   116a0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    task_t* curr_task=task_current();
   116a3:	e8 27 ff ff ff       	call   115cf <task_current>
   116a8:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(--curr_task->slice_ticks==0){
   116ab:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116ae:	8b 40 18             	mov    0x18(%eax),%eax
   116b1:	8d 50 ff             	lea    -0x1(%eax),%edx
   116b4:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116b7:	89 50 18             	mov    %edx,0x18(%eax)
   116ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116bd:	8b 40 18             	mov    0x18(%eax),%eax
   116c0:	85 c0                	test   %eax,%eax
   116c2:	75 28                	jne    116ec <task_time_tick+0x57>
        curr_task->slice_ticks=curr_task->time_ticks;
   116c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116c7:	8b 50 1c             	mov    0x1c(%eax),%edx
   116ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116cd:	89 50 18             	mov    %edx,0x18(%eax)
        task_set_block(curr_task);
   116d0:	83 ec 0c             	sub    $0xc,%esp
   116d3:	ff 75 ec             	pushl  -0x14(%ebp)
   116d6:	e8 82 fe ff ff       	call   1155d <task_set_block>
   116db:	83 c4 10             	add    $0x10,%esp
        task_set_ready(curr_task);
   116de:	83 ec 0c             	sub    $0xc,%esp
   116e1:	ff 75 ec             	pushl  -0x14(%ebp)
   116e4:	e8 3e fe ff ff       	call   11527 <task_set_ready>
   116e9:	83 c4 10             	add    $0x10,%esp
    }
    list_node_t* curr=list_first(&task_manager.sleep_list);
   116ec:	83 ec 0c             	sub    $0xc,%esp
   116ef:	68 1c a0 01 00       	push   $0x1a01c
   116f4:	e8 47 f8 ff ff       	call   10f40 <list_first>
   116f9:	83 c4 10             	add    $0x10,%esp
   116fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while(curr){
   116ff:	eb 64                	jmp    11765 <task_time_tick+0xd0>
        list_node_t*next=list_node_next(curr);
   11701:	83 ec 0c             	sub    $0xc,%esp
   11704:	ff 75 f4             	pushl  -0xc(%ebp)
   11707:	e8 1e f8 ff ff       	call   10f2a <list_node_next>
   1170c:	83 c4 10             	add    $0x10,%esp
   1170f:	89 45 e8             	mov    %eax,-0x18(%ebp)
        task_t* task=list_node_parent(curr,task_t,run_node);
   11712:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11716:	74 0a                	je     11722 <task_time_tick+0x8d>
   11718:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1171b:	2d 40 02 00 00       	sub    $0x240,%eax
   11720:	eb 05                	jmp    11727 <task_time_tick+0x92>
   11722:	b8 00 00 00 00       	mov    $0x0,%eax
   11727:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(--task->sleep_ticks==0){
   1172a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1172d:	8b 40 14             	mov    0x14(%eax),%eax
   11730:	8d 50 ff             	lea    -0x1(%eax),%edx
   11733:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11736:	89 50 14             	mov    %edx,0x14(%eax)
   11739:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1173c:	8b 40 14             	mov    0x14(%eax),%eax
   1173f:	85 c0                	test   %eax,%eax
   11741:	75 1c                	jne    1175f <task_time_tick+0xca>
            task_set_wakeup(task);
   11743:	83 ec 0c             	sub    $0xc,%esp
   11746:	ff 75 e4             	pushl  -0x1c(%ebp)
   11749:	e8 6f 00 00 00       	call   117bd <task_set_wakeup>
   1174e:	83 c4 10             	add    $0x10,%esp
            task_set_ready(task);
   11751:	83 ec 0c             	sub    $0xc,%esp
   11754:	ff 75 e4             	pushl  -0x1c(%ebp)
   11757:	e8 cb fd ff ff       	call   11527 <task_set_ready>
   1175c:	83 c4 10             	add    $0x10,%esp
        }
        curr=next;
   1175f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11762:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while(curr){
   11765:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11769:	75 96                	jne    11701 <task_time_tick+0x6c>
    }
    task_dispatch();
   1176b:	e8 ca fe ff ff       	call   1163a <task_dispatch>
    irq_leave_protection(state);
   11770:	83 ec 0c             	sub    $0xc,%esp
   11773:	ff 75 f0             	pushl  -0x10(%ebp)
   11776:	e8 aa 14 00 00       	call   12c25 <irq_leave_protection>
   1177b:	83 c4 10             	add    $0x10,%esp
}
   1177e:	90                   	nop
   1177f:	c9                   	leave  
   11780:	c3                   	ret    

00011781 <task_set_sleep>:

void task_set_sleep(task_t* task,uint32_t ticks){
   11781:	55                   	push   %ebp
   11782:	89 e5                	mov    %esp,%ebp
   11784:	83 ec 08             	sub    $0x8,%esp
    if(ticks==0){
   11787:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1178b:	74 2d                	je     117ba <task_set_sleep+0x39>
        return;
    }
    task->sleep_ticks=ticks;
   1178d:	8b 55 0c             	mov    0xc(%ebp),%edx
   11790:	8b 45 08             	mov    0x8(%ebp),%eax
   11793:	89 50 14             	mov    %edx,0x14(%eax)
    task->state=TASK_SLEEP;
   11796:	8b 45 08             	mov    0x8(%ebp),%eax
   11799:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    list_insert_last(&task_manager.sleep_list,&task->run_node);
   1179f:	8b 45 08             	mov    0x8(%ebp),%eax
   117a2:	05 40 02 00 00       	add    $0x240,%eax
   117a7:	83 ec 08             	sub    $0x8,%esp
   117aa:	50                   	push   %eax
   117ab:	68 1c a0 01 00       	push   $0x1a01c
   117b0:	e8 cd 3e 00 00       	call   15682 <list_insert_last>
   117b5:	83 c4 10             	add    $0x10,%esp
   117b8:	eb 01                	jmp    117bb <task_set_sleep+0x3a>
        return;
   117ba:	90                   	nop
}
   117bb:	c9                   	leave  
   117bc:	c3                   	ret    

000117bd <task_set_wakeup>:

void task_set_wakeup(task_t* task){
   117bd:	55                   	push   %ebp
   117be:	89 e5                	mov    %esp,%ebp
   117c0:	83 ec 08             	sub    $0x8,%esp
    list_remove(&task_manager.sleep_list,&task->run_node);
   117c3:	8b 45 08             	mov    0x8(%ebp),%eax
   117c6:	05 40 02 00 00       	add    $0x240,%eax
   117cb:	83 ec 08             	sub    $0x8,%esp
   117ce:	50                   	push   %eax
   117cf:	68 1c a0 01 00       	push   $0x1a01c
   117d4:	e8 85 3f 00 00       	call   1575e <list_remove>
   117d9:	83 c4 10             	add    $0x10,%esp
}
   117dc:	90                   	nop
   117dd:	c9                   	leave  
   117de:	c3                   	ret    

000117df <sys_msleep>:

void sys_msleep (uint32_t ms) {
   117df:	55                   	push   %ebp
   117e0:	89 e5                	mov    %esp,%ebp
   117e2:	83 ec 18             	sub    $0x18,%esp
    if (ms < OS_TICK_MS) {
   117e5:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
   117e9:	77 07                	ja     117f2 <sys_msleep+0x13>
        ms = OS_TICK_MS;
   117eb:	c7 45 08 0a 00 00 00 	movl   $0xa,0x8(%ebp)
    }

    irq_state_t state = irq_enter_protection();
   117f2:	e8 16 14 00 00       	call   12c0d <irq_enter_protection>
   117f7:	89 45 f4             	mov    %eax,-0xc(%ebp)

    task_set_block(task_manager.curr_task);
   117fa:	a1 00 a0 01 00       	mov    0x1a000,%eax
   117ff:	83 ec 0c             	sub    $0xc,%esp
   11802:	50                   	push   %eax
   11803:	e8 55 fd ff ff       	call   1155d <task_set_block>
   11808:	83 c4 10             	add    $0x10,%esp
    task_set_sleep(task_manager.curr_task, (ms + (OS_TICK_MS - 1))/ OS_TICK_MS);
   1180b:	8b 45 08             	mov    0x8(%ebp),%eax
   1180e:	83 c0 09             	add    $0x9,%eax
   11811:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
   11816:	f7 e2                	mul    %edx
   11818:	c1 ea 03             	shr    $0x3,%edx
   1181b:	a1 00 a0 01 00       	mov    0x1a000,%eax
   11820:	83 ec 08             	sub    $0x8,%esp
   11823:	52                   	push   %edx
   11824:	50                   	push   %eax
   11825:	e8 57 ff ff ff       	call   11781 <task_set_sleep>
   1182a:	83 c4 10             	add    $0x10,%esp
    
    task_dispatch();
   1182d:	e8 08 fe ff ff       	call   1163a <task_dispatch>

    irq_leave_protection(state);
   11832:	83 ec 0c             	sub    $0xc,%esp
   11835:	ff 75 f4             	pushl  -0xc(%ebp)
   11838:	e8 e8 13 00 00       	call   12c25 <irq_leave_protection>
   1183d:	83 c4 10             	add    $0x10,%esp
}
   11840:	90                   	nop
   11841:	c9                   	leave  
   11842:	c3                   	ret    

00011843 <sys_getpid>:

int sys_getpid(void){
   11843:	55                   	push   %ebp
   11844:	89 e5                	mov    %esp,%ebp
   11846:	83 ec 10             	sub    $0x10,%esp
    task_t* task=task_current();
   11849:	e8 81 fd ff ff       	call   115cf <task_current>
   1184e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return task->pid;
   11851:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11854:	8b 40 04             	mov    0x4(%eax),%eax
}
   11857:	c9                   	leave  
   11858:	c3                   	ret    

00011859 <alloc_task>:

static task_t* alloc_task(void){
   11859:	55                   	push   %ebp
   1185a:	89 e5                	mov    %esp,%ebp
   1185c:	83 ec 18             	sub    $0x18,%esp
    task_t* task=(task_t*)0;
   1185f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    mutex_lock(&table_mutex);
   11866:	83 ec 0c             	sub    $0xc,%esp
   11869:	68 c0 17 03 00       	push   $0x317c0
   1186e:	e8 b2 32 00 00       	call   14b25 <mutex_lock>
   11873:	83 c4 10             	add    $0x10,%esp
    for(int i=0;i<TASK_NR;i++){
   11876:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1187d:	eb 27                	jmp    118a6 <alloc_task+0x4d>
        task_t* curr=task_table+i;
   1187f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11882:	69 c0 c4 02 00 00    	imul   $0x2c4,%eax,%eax
   11888:	05 c0 b5 01 00       	add    $0x1b5c0,%eax
   1188d:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(curr->pid==0){
   11890:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11893:	8b 40 04             	mov    0x4(%eax),%eax
   11896:	85 c0                	test   %eax,%eax
   11898:	75 08                	jne    118a2 <alloc_task+0x49>
            task=curr;
   1189a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1189d:	89 45 f4             	mov    %eax,-0xc(%ebp)
            break;
   118a0:	eb 0a                	jmp    118ac <alloc_task+0x53>
    for(int i=0;i<TASK_NR;i++){
   118a2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   118a6:	83 7d f0 7f          	cmpl   $0x7f,-0x10(%ebp)
   118aa:	7e d3                	jle    1187f <alloc_task+0x26>
        }
    }   
    mutex_unlock(&table_mutex);
   118ac:	83 ec 0c             	sub    $0xc,%esp
   118af:	68 c0 17 03 00       	push   $0x317c0
   118b4:	e8 fb 32 00 00       	call   14bb4 <mutex_unlock>
   118b9:	83 c4 10             	add    $0x10,%esp

    return task;
   118bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   118bf:	c9                   	leave  
   118c0:	c3                   	ret    

000118c1 <free_task>:

static void free_task(task_t* task){
   118c1:	55                   	push   %ebp
   118c2:	89 e5                	mov    %esp,%ebp
   118c4:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&table_mutex);
   118c7:	83 ec 0c             	sub    $0xc,%esp
   118ca:	68 c0 17 03 00       	push   $0x317c0
   118cf:	e8 51 32 00 00       	call   14b25 <mutex_lock>
   118d4:	83 c4 10             	add    $0x10,%esp
    task->pid=0;
   118d7:	8b 45 08             	mov    0x8(%ebp),%eax
   118da:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    mutex_unlock(&table_mutex);
   118e1:	83 ec 0c             	sub    $0xc,%esp
   118e4:	68 c0 17 03 00       	push   $0x317c0
   118e9:	e8 c6 32 00 00       	call   14bb4 <mutex_unlock>
   118ee:	83 c4 10             	add    $0x10,%esp
}
   118f1:	90                   	nop
   118f2:	c9                   	leave  
   118f3:	c3                   	ret    

000118f4 <sys_fork>:

int sys_fork(void){
   118f4:	55                   	push   %ebp
   118f5:	89 e5                	mov    %esp,%ebp
   118f7:	83 ec 28             	sub    $0x28,%esp
    task_t* parent_task=task_current();
   118fa:	e8 d0 fc ff ff       	call   115cf <task_current>
   118ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t* child_task=alloc_task();
   11902:	e8 52 ff ff ff       	call   11859 <alloc_task>
   11907:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if(child_task==(task_t*)0){
   1190a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1190e:	0f 84 24 01 00 00    	je     11a38 <sys_fork+0x144>
        goto fork_failed;
    }

    syscall_frame_t* frame=(syscall_frame_t*)(parent_task->tss.esp0-sizeof(syscall_frame_t));
   11914:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11917:	8b 80 5c 02 00 00    	mov    0x25c(%eax),%eax
   1191d:	83 e8 58             	sub    $0x58,%eax
   11920:	89 45 ec             	mov    %eax,-0x14(%ebp)
    int err=task_init(child_task,parent_task->name,0,frame->eip,frame->esp+sizeof(uint32_t)*SYSCALL_PARAM_COUNT);
   11923:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11926:	8b 40 50             	mov    0x50(%eax),%eax
   11929:	8d 48 14             	lea    0x14(%eax),%ecx
   1192c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1192f:	8b 40 34             	mov    0x34(%eax),%eax
   11932:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11935:	83 c2 20             	add    $0x20,%edx
   11938:	83 ec 0c             	sub    $0xc,%esp
   1193b:	51                   	push   %ecx
   1193c:	50                   	push   %eax
   1193d:	6a 00                	push   $0x0
   1193f:	52                   	push   %edx
   11940:	ff 75 f0             	pushl  -0x10(%ebp)
   11943:	e8 db f7 ff ff       	call   11123 <task_init>
   11948:	83 c4 20             	add    $0x20,%esp
   1194b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(err < 0){
   1194e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11952:	0f 88 e3 00 00 00    	js     11a3b <sys_fork+0x147>
        goto fork_failed;
    }

    tss_t* tss=&child_task->tss;
   11958:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1195b:	05 58 02 00 00       	add    $0x258,%eax
   11960:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    tss->eax= 0;
   11963:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11966:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
    tss->ebx=frame->ebx;
   1196d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11970:	8b 50 24             	mov    0x24(%eax),%edx
   11973:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11976:	89 50 34             	mov    %edx,0x34(%eax)
    tss->ecx=frame->ecx;
   11979:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1197c:	8b 50 2c             	mov    0x2c(%eax),%edx
   1197f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11982:	89 50 2c             	mov    %edx,0x2c(%eax)
    tss->edx=frame->edx;
   11985:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11988:	8b 50 28             	mov    0x28(%eax),%edx
   1198b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1198e:	89 50 30             	mov    %edx,0x30(%eax)
    tss->esi=frame->esi;
   11991:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11994:	8b 50 18             	mov    0x18(%eax),%edx
   11997:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1199a:	89 50 40             	mov    %edx,0x40(%eax)
    tss->edi=frame->edi;
   1199d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119a0:	8b 50 14             	mov    0x14(%eax),%edx
   119a3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119a6:	89 50 44             	mov    %edx,0x44(%eax)
    tss->ebp=frame->ebp;
   119a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119ac:	8b 50 1c             	mov    0x1c(%eax),%edx
   119af:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119b2:	89 50 3c             	mov    %edx,0x3c(%eax)

    tss->cs=frame->cs;
   119b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119b8:	8b 50 38             	mov    0x38(%eax),%edx
   119bb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119be:	89 50 4c             	mov    %edx,0x4c(%eax)
    tss->ds=frame->ds;
   119c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119c4:	8b 50 10             	mov    0x10(%eax),%edx
   119c7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119ca:	89 50 54             	mov    %edx,0x54(%eax)
    tss->es=frame->es;
   119cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119d0:	8b 50 0c             	mov    0xc(%eax),%edx
   119d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119d6:	89 50 48             	mov    %edx,0x48(%eax)
    tss->fs=frame->fs;
   119d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119dc:	8b 50 08             	mov    0x8(%eax),%edx
   119df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119e2:	89 50 58             	mov    %edx,0x58(%eax)
    tss->gs=frame->gs;
   119e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119e8:	8b 50 04             	mov    0x4(%eax),%edx
   119eb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119ee:	89 50 5c             	mov    %edx,0x5c(%eax)
    tss->eflags=frame->eflags;
   119f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119f4:	8b 10                	mov    (%eax),%edx
   119f6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119f9:	89 50 24             	mov    %edx,0x24(%eax)

    child_task->parent=parent_task;
   119fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   119ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11a02:	89 50 08             	mov    %edx,0x8(%eax)

    if((tss->cr3=memory_copy_uvm(parent_task->tss.cr3))<0){
   11a05:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11a08:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
   11a0e:	83 ec 0c             	sub    $0xc,%esp
   11a11:	50                   	push   %eax
   11a12:	e8 c2 f0 ff ff       	call   10ad9 <memory_copy_uvm>
   11a17:	83 c4 10             	add    $0x10,%esp
   11a1a:	89 c2                	mov    %eax,%edx
   11a1c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11a1f:	89 50 1c             	mov    %edx,0x1c(%eax)
        goto fork_failed;
    }

    task_start(child_task);
   11a22:	83 ec 0c             	sub    $0xc,%esp
   11a25:	ff 75 f0             	pushl  -0x10(%ebp)
   11a28:	e8 42 f8 ff ff       	call   1126f <task_start>
   11a2d:	83 c4 10             	add    $0x10,%esp

    return child_task->pid;
   11a30:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11a33:	8b 40 04             	mov    0x4(%eax),%eax
   11a36:	eb 2b                	jmp    11a63 <sys_fork+0x16f>
        goto fork_failed;
   11a38:	90                   	nop
   11a39:	eb 01                	jmp    11a3c <sys_fork+0x148>
        goto fork_failed;
   11a3b:	90                   	nop

fork_failed:
    if(child_task){
   11a3c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11a40:	74 1c                	je     11a5e <sys_fork+0x16a>
        task_uninit(child_task);
   11a42:	83 ec 0c             	sub    $0xc,%esp
   11a45:	ff 75 f0             	pushl  -0x10(%ebp)
   11a48:	e8 4f f8 ff ff       	call   1129c <task_uninit>
   11a4d:	83 c4 10             	add    $0x10,%esp
        free_task(child_task);
   11a50:	83 ec 0c             	sub    $0xc,%esp
   11a53:	ff 75 f0             	pushl  -0x10(%ebp)
   11a56:	e8 66 fe ff ff       	call   118c1 <free_task>
   11a5b:	83 c4 10             	add    $0x10,%esp
    }

    return -1;
   11a5e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   11a63:	c9                   	leave  
   11a64:	c3                   	ret    

00011a65 <load_phdr>:

static int load_phdr(int file,Elf32_Phdr*phdr ,uint32_t page_dir){
   11a65:	55                   	push   %ebp
   11a66:	89 e5                	mov    %esp,%ebp
   11a68:	83 ec 28             	sub    $0x28,%esp
    int err=memory_alloc_for_page_dir(page_dir,phdr->p_vaddr,phdr->p_memsz,PTE_P|PTE_U|PTE_W);
   11a6b:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a6e:	8b 50 14             	mov    0x14(%eax),%edx
   11a71:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a74:	8b 40 08             	mov    0x8(%eax),%eax
   11a77:	6a 07                	push   $0x7
   11a79:	52                   	push   %edx
   11a7a:	50                   	push   %eax
   11a7b:	ff 75 10             	pushl  0x10(%ebp)
   11a7e:	e8 ca ed ff ff       	call   1084d <memory_alloc_for_page_dir>
   11a83:	83 c4 10             	add    $0x10,%esp
   11a86:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(err < 0){
   11a89:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11a8d:	79 1a                	jns    11aa9 <load_phdr+0x44>
        log_printf("no memory");
   11a8f:	83 ec 0c             	sub    $0xc,%esp
   11a92:	68 89 5c 01 00       	push   $0x15c89
   11a97:	e8 76 3d 00 00       	call   15812 <log_printf>
   11a9c:	83 c4 10             	add    $0x10,%esp
        return -1;
   11a9f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11aa4:	e9 b8 00 00 00       	jmp    11b61 <load_phdr+0xfc>
    }

    if(sys_lseek(file,phdr->p_offset,0)<0){
   11aa9:	8b 45 0c             	mov    0xc(%ebp),%eax
   11aac:	8b 40 04             	mov    0x4(%eax),%eax
   11aaf:	83 ec 04             	sub    $0x4,%esp
   11ab2:	6a 00                	push   $0x0
   11ab4:	50                   	push   %eax
   11ab5:	ff 75 08             	pushl  0x8(%ebp)
   11ab8:	e8 91 2e 00 00       	call   1494e <sys_lseek>
   11abd:	83 c4 10             	add    $0x10,%esp
   11ac0:	85 c0                	test   %eax,%eax
   11ac2:	79 1a                	jns    11ade <load_phdr+0x79>
        log_printf("read file failed");
   11ac4:	83 ec 0c             	sub    $0xc,%esp
   11ac7:	68 93 5c 01 00       	push   $0x15c93
   11acc:	e8 41 3d 00 00       	call   15812 <log_printf>
   11ad1:	83 c4 10             	add    $0x10,%esp
        return -1;
   11ad4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11ad9:	e9 83 00 00 00       	jmp    11b61 <load_phdr+0xfc>
    }

    uint32_t vaddr=phdr->p_vaddr;
   11ade:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ae1:	8b 40 08             	mov    0x8(%eax),%eax
   11ae4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t size=phdr->p_filesz;
   11ae7:	8b 45 0c             	mov    0xc(%ebp),%eax
   11aea:	8b 40 10             	mov    0x10(%eax),%eax
   11aed:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while(size > 0){
   11af0:	eb 64                	jmp    11b56 <load_phdr+0xf1>
        int curr_size=(size > MEM_PAGE_SIZE) ? MEM_PAGE_SIZE : size;
   11af2:	b8 00 10 00 00       	mov    $0x1000,%eax
   11af7:	81 7d f0 00 10 00 00 	cmpl   $0x1000,-0x10(%ebp)
   11afe:	0f 46 45 f0          	cmovbe -0x10(%ebp),%eax
   11b02:	89 45 e8             	mov    %eax,-0x18(%ebp)
        uint32_t paddr=memory_get_paddr(page_dir,vaddr);
   11b05:	83 ec 08             	sub    $0x8,%esp
   11b08:	ff 75 f4             	pushl  -0xc(%ebp)
   11b0b:	ff 75 10             	pushl  0x10(%ebp)
   11b0e:	e8 1b f1 ff ff       	call   10c2e <memory_get_paddr>
   11b13:	83 c4 10             	add    $0x10,%esp
   11b16:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        if(sys_read(file,(char*)paddr,curr_size)<curr_size){
   11b19:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11b1c:	83 ec 04             	sub    $0x4,%esp
   11b1f:	ff 75 e8             	pushl  -0x18(%ebp)
   11b22:	50                   	push   %eax
   11b23:	ff 75 08             	pushl  0x8(%ebp)
   11b26:	e8 4f 2d 00 00       	call   1487a <sys_read>
   11b2b:	83 c4 10             	add    $0x10,%esp
   11b2e:	39 45 e8             	cmp    %eax,-0x18(%ebp)
   11b31:	7e 17                	jle    11b4a <load_phdr+0xe5>
            log_printf("read file failed.");
   11b33:	83 ec 0c             	sub    $0xc,%esp
   11b36:	68 a4 5c 01 00       	push   $0x15ca4
   11b3b:	e8 d2 3c 00 00       	call   15812 <log_printf>
   11b40:	83 c4 10             	add    $0x10,%esp
            return -1;
   11b43:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11b48:	eb 17                	jmp    11b61 <load_phdr+0xfc>
        }

        size-=curr_size;
   11b4a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11b4d:	29 45 f0             	sub    %eax,-0x10(%ebp)
        vaddr+=curr_size;
   11b50:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11b53:	01 45 f4             	add    %eax,-0xc(%ebp)
    while(size > 0){
   11b56:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11b5a:	75 96                	jne    11af2 <load_phdr+0x8d>
    }

    return 0;
   11b5c:	b8 00 00 00 00       	mov    $0x0,%eax

}
   11b61:	c9                   	leave  
   11b62:	c3                   	ret    

00011b63 <load_elf_file>:

static uint32_t load_elf_file(task_t* task,const char* name,uint32_t page_dir){
   11b63:	55                   	push   %ebp
   11b64:	89 e5                	mov    %esp,%ebp
   11b66:	83 ec 78             	sub    $0x78,%esp
    Elf32_Ehdr elf_hdr;
    Elf32_Phdr elf_phdr;

    int file=sys_open(name,0);
   11b69:	83 ec 08             	sub    $0x8,%esp
   11b6c:	6a 00                	push   $0x0
   11b6e:	ff 75 0c             	pushl  0xc(%ebp)
   11b71:	e8 a4 2b 00 00       	call   1471a <sys_open>
   11b76:	83 c4 10             	add    $0x10,%esp
   11b79:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(file<0){
   11b7c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11b80:	79 18                	jns    11b9a <load_elf_file+0x37>
        log_printf("open failed. %s",name);
   11b82:	83 ec 08             	sub    $0x8,%esp
   11b85:	ff 75 0c             	pushl  0xc(%ebp)
   11b88:	68 b6 5c 01 00       	push   $0x15cb6
   11b8d:	e8 80 3c 00 00       	call   15812 <log_printf>
   11b92:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   11b95:	e9 6c 01 00 00       	jmp    11d06 <load_elf_file+0x1a3>
    }

    int cnt=sys_read(file,(char*)&elf_hdr,sizeof(elf_hdr));
   11b9a:	83 ec 04             	sub    $0x4,%esp
   11b9d:	6a 34                	push   $0x34
   11b9f:	8d 45 b0             	lea    -0x50(%ebp),%eax
   11ba2:	50                   	push   %eax
   11ba3:	ff 75 ec             	pushl  -0x14(%ebp)
   11ba6:	e8 cf 2c 00 00       	call   1487a <sys_read>
   11bab:	83 c4 10             	add    $0x10,%esp
   11bae:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(cnt<sizeof(Elf32_Ehdr)){
   11bb1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11bb4:	83 f8 33             	cmp    $0x33,%eax
   11bb7:	77 18                	ja     11bd1 <load_elf_file+0x6e>
        log_printf("elf hdr too small. size=%d",cnt);
   11bb9:	83 ec 08             	sub    $0x8,%esp
   11bbc:	ff 75 e8             	pushl  -0x18(%ebp)
   11bbf:	68 c6 5c 01 00       	push   $0x15cc6
   11bc4:	e8 49 3c 00 00       	call   15812 <log_printf>
   11bc9:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   11bcc:	e9 35 01 00 00       	jmp    11d06 <load_elf_file+0x1a3>
    }

    if((elf_hdr.e_ident[0]!=0x7f)||(elf_hdr.e_ident[1]!='E')
   11bd1:	0f b6 45 b0          	movzbl -0x50(%ebp),%eax
   11bd5:	3c 7f                	cmp    $0x7f,%al
   11bd7:	75 18                	jne    11bf1 <load_elf_file+0x8e>
   11bd9:	0f b6 45 b1          	movzbl -0x4f(%ebp),%eax
   11bdd:	3c 45                	cmp    $0x45,%al
   11bdf:	75 10                	jne    11bf1 <load_elf_file+0x8e>
		|| (elf_hdr.e_ident[2]!='L')||(elf_hdr.e_ident[3]!='F')){
   11be1:	0f b6 45 b2          	movzbl -0x4e(%ebp),%eax
   11be5:	3c 4c                	cmp    $0x4c,%al
   11be7:	75 08                	jne    11bf1 <load_elf_file+0x8e>
   11be9:	0f b6 45 b3          	movzbl -0x4d(%ebp),%eax
   11bed:	3c 46                	cmp    $0x46,%al
   11bef:	74 15                	je     11c06 <load_elf_file+0xa3>
            log_printf("check elf ident failed.");
   11bf1:	83 ec 0c             	sub    $0xc,%esp
   11bf4:	68 e1 5c 01 00       	push   $0x15ce1
   11bf9:	e8 14 3c 00 00       	call   15812 <log_printf>
   11bfe:	83 c4 10             	add    $0x10,%esp
			goto load_failed;
   11c01:	e9 00 01 00 00       	jmp    11d06 <load_elf_file+0x1a3>
	}

    uint32_t e_phoff=elf_hdr.e_phoff;
   11c06:	8b 45 cc             	mov    -0x34(%ebp),%eax
   11c09:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(int i=0;i<elf_hdr.e_phnum;i++,e_phoff+=elf_hdr.e_phentsize){
   11c0c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11c13:	e9 cb 00 00 00       	jmp    11ce3 <load_elf_file+0x180>
        if(sys_lseek(file,e_phoff,0)<0){
   11c18:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11c1b:	83 ec 04             	sub    $0x4,%esp
   11c1e:	6a 00                	push   $0x0
   11c20:	50                   	push   %eax
   11c21:	ff 75 ec             	pushl  -0x14(%ebp)
   11c24:	e8 25 2d 00 00       	call   1494e <sys_lseek>
   11c29:	83 c4 10             	add    $0x10,%esp
   11c2c:	85 c0                	test   %eax,%eax
   11c2e:	79 15                	jns    11c45 <load_elf_file+0xe2>
            log_printf("read file failed.");
   11c30:	83 ec 0c             	sub    $0xc,%esp
   11c33:	68 a4 5c 01 00       	push   $0x15ca4
   11c38:	e8 d5 3b 00 00       	call   15812 <log_printf>
   11c3d:	83 c4 10             	add    $0x10,%esp
            goto load_failed;
   11c40:	e9 c1 00 00 00       	jmp    11d06 <load_elf_file+0x1a3>
        }

        cnt=sys_read(file,(char*)&elf_phdr,sizeof(elf_phdr));
   11c45:	83 ec 04             	sub    $0x4,%esp
   11c48:	6a 20                	push   $0x20
   11c4a:	8d 45 90             	lea    -0x70(%ebp),%eax
   11c4d:	50                   	push   %eax
   11c4e:	ff 75 ec             	pushl  -0x14(%ebp)
   11c51:	e8 24 2c 00 00       	call   1487a <sys_read>
   11c56:	83 c4 10             	add    $0x10,%esp
   11c59:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if(cnt<sizeof(elf_phdr)){
   11c5c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11c5f:	83 f8 1f             	cmp    $0x1f,%eax
   11c62:	77 15                	ja     11c79 <load_elf_file+0x116>
            log_printf("read file failed.");
   11c64:	83 ec 0c             	sub    $0xc,%esp
   11c67:	68 a4 5c 01 00       	push   $0x15ca4
   11c6c:	e8 a1 3b 00 00       	call   15812 <log_printf>
   11c71:	83 c4 10             	add    $0x10,%esp
            goto load_failed;
   11c74:	e9 8d 00 00 00       	jmp    11d06 <load_elf_file+0x1a3>
        }

        if((elf_phdr.p_type!=1)|| (elf_phdr.p_vaddr<MEMORY_TASK_BASE)){
   11c79:	8b 45 90             	mov    -0x70(%ebp),%eax
   11c7c:	83 f8 01             	cmp    $0x1,%eax
   11c7f:	75 53                	jne    11cd4 <load_elf_file+0x171>
   11c81:	8b 45 98             	mov    -0x68(%ebp),%eax
   11c84:	85 c0                	test   %eax,%eax
   11c86:	79 4c                	jns    11cd4 <load_elf_file+0x171>
            continue;
        }

        int err=load_phdr(file,&elf_phdr,page_dir);
   11c88:	83 ec 04             	sub    $0x4,%esp
   11c8b:	ff 75 10             	pushl  0x10(%ebp)
   11c8e:	8d 45 90             	lea    -0x70(%ebp),%eax
   11c91:	50                   	push   %eax
   11c92:	ff 75 ec             	pushl  -0x14(%ebp)
   11c95:	e8 cb fd ff ff       	call   11a65 <load_phdr>
   11c9a:	83 c4 10             	add    $0x10,%esp
   11c9d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(err<0){
   11ca0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   11ca4:	79 12                	jns    11cb8 <load_elf_file+0x155>
            log_printf("load program failed.");
   11ca6:	83 ec 0c             	sub    $0xc,%esp
   11ca9:	68 f9 5c 01 00       	push   $0x15cf9
   11cae:	e8 5f 3b 00 00       	call   15812 <log_printf>
   11cb3:	83 c4 10             	add    $0x10,%esp
            goto load_failed;
   11cb6:	eb 4e                	jmp    11d06 <load_elf_file+0x1a3>
        }

        task->heap_start=elf_phdr.p_vaddr+elf_phdr.p_memsz;
   11cb8:	8b 55 98             	mov    -0x68(%ebp),%edx
   11cbb:	8b 45 a4             	mov    -0x5c(%ebp),%eax
   11cbe:	01 c2                	add    %eax,%edx
   11cc0:	8b 45 08             	mov    0x8(%ebp),%eax
   11cc3:	89 50 0c             	mov    %edx,0xc(%eax)
        task->heap_end=task->heap_start;
   11cc6:	8b 45 08             	mov    0x8(%ebp),%eax
   11cc9:	8b 50 0c             	mov    0xc(%eax),%edx
   11ccc:	8b 45 08             	mov    0x8(%ebp),%eax
   11ccf:	89 50 10             	mov    %edx,0x10(%eax)
   11cd2:	eb 01                	jmp    11cd5 <load_elf_file+0x172>
            continue;
   11cd4:	90                   	nop
    for(int i=0;i<elf_hdr.e_phnum;i++,e_phoff+=elf_hdr.e_phentsize){
   11cd5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11cd9:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
   11cdd:	0f b7 c0             	movzwl %ax,%eax
   11ce0:	01 45 f4             	add    %eax,-0xc(%ebp)
   11ce3:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
   11ce7:	0f b7 c0             	movzwl %ax,%eax
   11cea:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11ced:	0f 8c 25 ff ff ff    	jl     11c18 <load_elf_file+0xb5>
    }


    sys_close(file);
   11cf3:	83 ec 0c             	sub    $0xc,%esp
   11cf6:	ff 75 ec             	pushl  -0x14(%ebp)
   11cf9:	e8 74 2c 00 00       	call   14972 <sys_close>
   11cfe:	83 c4 10             	add    $0x10,%esp
    return elf_hdr.e_entry;
   11d01:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11d04:	eb 19                	jmp    11d1f <load_elf_file+0x1bc>

load_failed:
    if(file){
   11d06:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11d0a:	74 0e                	je     11d1a <load_elf_file+0x1b7>
        sys_close(file);
   11d0c:	83 ec 0c             	sub    $0xc,%esp
   11d0f:	ff 75 ec             	pushl  -0x14(%ebp)
   11d12:	e8 5b 2c 00 00       	call   14972 <sys_close>
   11d17:	83 c4 10             	add    $0x10,%esp
    }
    return 0;
   11d1a:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11d1f:	c9                   	leave  
   11d20:	c3                   	ret    

00011d21 <copy_args>:

static int copy_args(char* to,uint32_t page_dir,int argc,char**argv){
   11d21:	55                   	push   %ebp
   11d22:	89 e5                	mov    %esp,%ebp
   11d24:	83 ec 38             	sub    $0x38,%esp
    task_args_t task_args;
    task_args.argc=argc;
   11d27:	8b 45 10             	mov    0x10(%ebp),%eax
   11d2a:	89 45 d8             	mov    %eax,-0x28(%ebp)
    task_args.argv=(char**)(to+sizeof(task_args_t));
   11d2d:	8b 45 08             	mov    0x8(%ebp),%eax
   11d30:	83 c0 0c             	add    $0xc,%eax
   11d33:	89 45 dc             	mov    %eax,-0x24(%ebp)

    char* dest_arg=to+sizeof(task_args_t)+sizeof(char*)*argc;
   11d36:	8b 45 10             	mov    0x10(%ebp),%eax
   11d39:	83 c0 03             	add    $0x3,%eax
   11d3c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11d43:	8b 45 08             	mov    0x8(%ebp),%eax
   11d46:	01 d0                	add    %edx,%eax
   11d48:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char** dest_arg_tb=(char**)memory_get_paddr(page_dir,(uint32_t)(to+sizeof(task_args_t)));
   11d4b:	8b 45 08             	mov    0x8(%ebp),%eax
   11d4e:	83 c0 0c             	add    $0xc,%eax
   11d51:	83 ec 08             	sub    $0x8,%esp
   11d54:	50                   	push   %eax
   11d55:	ff 75 0c             	pushl  0xc(%ebp)
   11d58:	e8 d1 ee ff ff       	call   10c2e <memory_get_paddr>
   11d5d:	83 c4 10             	add    $0x10,%esp
   11d60:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for(int i=0;i<argc;i++){
   11d63:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11d6a:	e9 82 00 00 00       	jmp    11df1 <copy_args+0xd0>
        char* from=argv[i];
   11d6f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d72:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11d79:	8b 45 14             	mov    0x14(%ebp),%eax
   11d7c:	01 d0                	add    %edx,%eax
   11d7e:	8b 00                	mov    (%eax),%eax
   11d80:	89 45 e8             	mov    %eax,-0x18(%ebp)
        int len=kernel_strlen(from)+1;
   11d83:	83 ec 0c             	sub    $0xc,%esp
   11d86:	ff 75 e8             	pushl  -0x18(%ebp)
   11d89:	e8 d7 33 00 00       	call   15165 <kernel_strlen>
   11d8e:	83 c4 10             	add    $0x10,%esp
   11d91:	83 c0 01             	add    $0x1,%eax
   11d94:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        int err=memory_copy_uvm_data((uint32_t)dest_arg,page_dir,(uint32_t)from,len);
   11d97:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   11d9a:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11d9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11da0:	51                   	push   %ecx
   11da1:	52                   	push   %edx
   11da2:	ff 75 0c             	pushl  0xc(%ebp)
   11da5:	50                   	push   %eax
   11da6:	e8 c9 ee ff ff       	call   10c74 <memory_copy_uvm_data>
   11dab:	83 c4 10             	add    $0x10,%esp
   11dae:	89 45 e0             	mov    %eax,-0x20(%ebp)
        ASSERT(err >= 0);
   11db1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   11db5:	79 1c                	jns    11dd3 <copy_args+0xb2>
   11db7:	68 0e 5d 01 00       	push   $0x15d0e
   11dbc:	68 34 5d 01 00       	push   $0x15d34
   11dc1:	68 d5 01 00 00       	push   $0x1d5
   11dc6:	68 18 5c 01 00       	push   $0x15c18
   11dcb:	e8 72 37 00 00       	call   15542 <panic>
   11dd0:	83 c4 10             	add    $0x10,%esp

        dest_arg_tb[i]=dest_arg;
   11dd3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11dd6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11ddd:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11de0:	01 c2                	add    %eax,%edx
   11de2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11de5:	89 02                	mov    %eax,(%edx)
        dest_arg+=len;
   11de7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11dea:	01 45 f4             	add    %eax,-0xc(%ebp)
    for(int i=0;i<argc;i++){
   11ded:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11df1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11df4:	3b 45 10             	cmp    0x10(%ebp),%eax
   11df7:	0f 8c 72 ff ff ff    	jl     11d6f <copy_args+0x4e>

    }
    return memory_copy_uvm_data((uint32_t)to,page_dir,(uint32_t)&task_args,sizeof(task_args));
   11dfd:	8d 55 d4             	lea    -0x2c(%ebp),%edx
   11e00:	8b 45 08             	mov    0x8(%ebp),%eax
   11e03:	6a 0c                	push   $0xc
   11e05:	52                   	push   %edx
   11e06:	ff 75 0c             	pushl  0xc(%ebp)
   11e09:	50                   	push   %eax
   11e0a:	e8 65 ee ff ff       	call   10c74 <memory_copy_uvm_data>
   11e0f:	83 c4 10             	add    $0x10,%esp

}
   11e12:	c9                   	leave  
   11e13:	c3                   	ret    

00011e14 <sys_execve>:

int sys_execve(char* name,char** argv,char** env){
   11e14:	55                   	push   %ebp
   11e15:	89 e5                	mov    %esp,%ebp
   11e17:	83 ec 28             	sub    $0x28,%esp
    task_t* task=task_current();
   11e1a:	e8 b0 f7 ff ff       	call   115cf <task_current>
   11e1f:	89 45 f4             	mov    %eax,-0xc(%ebp)

    kernel_strncpy(task->name,get_file_name(name),TASK_NAME_SIZE);
   11e22:	83 ec 0c             	sub    $0xc,%esp
   11e25:	ff 75 08             	pushl  0x8(%ebp)
   11e28:	e8 78 37 00 00       	call   155a5 <get_file_name>
   11e2d:	83 c4 10             	add    $0x10,%esp
   11e30:	89 c2                	mov    %eax,%edx
   11e32:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11e35:	83 c0 20             	add    $0x20,%eax
   11e38:	83 ec 04             	sub    $0x4,%esp
   11e3b:	6a 20                	push   $0x20
   11e3d:	52                   	push   %edx
   11e3e:	50                   	push   %eax
   11e3f:	e8 37 32 00 00       	call   1507b <kernel_strncpy>
   11e44:	83 c4 10             	add    $0x10,%esp

    uint32_t old_page_dir=task->tss.cr3;
   11e47:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11e4a:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
   11e50:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint32_t new_page_dir=memory_create_uvm();
   11e53:	e8 70 e9 ff ff       	call   107c8 <memory_create_uvm>
   11e58:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(!new_page_dir){
   11e5b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11e5f:	0f 84 1f 01 00 00    	je     11f84 <sys_execve+0x170>
        goto exec_failed;
    }

    uint32_t entry=load_elf_file(task,name,new_page_dir);
   11e65:	83 ec 04             	sub    $0x4,%esp
   11e68:	ff 75 ec             	pushl  -0x14(%ebp)
   11e6b:	ff 75 08             	pushl  0x8(%ebp)
   11e6e:	ff 75 f4             	pushl  -0xc(%ebp)
   11e71:	e8 ed fc ff ff       	call   11b63 <load_elf_file>
   11e76:	83 c4 10             	add    $0x10,%esp
   11e79:	89 45 e8             	mov    %eax,-0x18(%ebp)

    if(entry==0){
   11e7c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11e80:	0f 84 01 01 00 00    	je     11f87 <sys_execve+0x173>
        goto exec_failed;
    }

    uint32_t stack_top=MEM_TASK_STACK_TOP-MEM_TASK_ARG_SIZE;
   11e86:	c7 45 e4 00 c0 ff df 	movl   $0xdfffc000,-0x1c(%ebp)

    int err=memory_alloc_for_page_dir(new_page_dir,
   11e8d:	6a 07                	push   $0x7
   11e8f:	68 00 40 1f 00       	push   $0x1f4000
   11e94:	68 00 c0 e0 df       	push   $0xdfe0c000
   11e99:	ff 75 ec             	pushl  -0x14(%ebp)
   11e9c:	e8 ac e9 ff ff       	call   1084d <memory_alloc_for_page_dir>
   11ea1:	83 c4 10             	add    $0x10,%esp
   11ea4:	89 45 e0             	mov    %eax,-0x20(%ebp)
        MEM_TASK_STACK_TOP-MEM_TASK_STACK_SIZE,MEM_TASK_STACK_SIZE,
        PTE_P | PTE_U | PTE_W
    );

    if(err < 0){
   11ea7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   11eab:	0f 88 d9 00 00 00    	js     11f8a <sys_execve+0x176>
        goto exec_failed;
    }
    
    int argc=string_count(argv);
   11eb1:	83 ec 0c             	sub    $0xc,%esp
   11eb4:	ff 75 0c             	pushl  0xc(%ebp)
   11eb7:	e8 bc 36 00 00       	call   15578 <string_count>
   11ebc:	83 c4 10             	add    $0x10,%esp
   11ebf:	89 45 dc             	mov    %eax,-0x24(%ebp)
    err=copy_args((char*)stack_top,new_page_dir,argc,argv);
   11ec2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11ec5:	ff 75 0c             	pushl  0xc(%ebp)
   11ec8:	ff 75 dc             	pushl  -0x24(%ebp)
   11ecb:	ff 75 ec             	pushl  -0x14(%ebp)
   11ece:	50                   	push   %eax
   11ecf:	e8 4d fe ff ff       	call   11d21 <copy_args>
   11ed4:	83 c4 10             	add    $0x10,%esp
   11ed7:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(err<0){
   11eda:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   11ede:	0f 88 a9 00 00 00    	js     11f8d <sys_execve+0x179>
        goto exec_failed;
    }

    syscall_frame_t* frame=(syscall_frame_t*)(task->tss.esp0-sizeof(syscall_frame_t));
   11ee4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ee7:	8b 80 5c 02 00 00    	mov    0x25c(%eax),%eax
   11eed:	83 e8 58             	sub    $0x58,%eax
   11ef0:	89 45 d8             	mov    %eax,-0x28(%ebp)
    frame->eip=entry;
   11ef3:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11ef6:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11ef9:	89 50 34             	mov    %edx,0x34(%eax)
    frame->eax=frame->ebx=frame->edx=0;
   11efc:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11eff:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
   11f06:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f09:	8b 50 28             	mov    0x28(%eax),%edx
   11f0c:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f0f:	89 50 24             	mov    %edx,0x24(%eax)
   11f12:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f15:	8b 50 24             	mov    0x24(%eax),%edx
   11f18:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f1b:	89 50 30             	mov    %edx,0x30(%eax)
    frame->esi=frame->edi=frame->ebp=0;
   11f1e:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f21:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
   11f28:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f2b:	8b 50 1c             	mov    0x1c(%eax),%edx
   11f2e:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f31:	89 50 14             	mov    %edx,0x14(%eax)
   11f34:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f37:	8b 50 14             	mov    0x14(%eax),%edx
   11f3a:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f3d:	89 50 18             	mov    %edx,0x18(%eax)
    frame->eflags=EFLAGS_DEFAULT|EFLAGS_IF;
   11f40:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f43:	c7 00 02 02 00 00    	movl   $0x202,(%eax)

    frame->esp=stack_top-sizeof(uint32_t)*SYSCALL_PARAM_COUNT;
   11f49:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11f4c:	8d 50 ec             	lea    -0x14(%eax),%edx
   11f4f:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f52:	89 50 50             	mov    %edx,0x50(%eax)

    task->tss.cr3=new_page_dir;
   11f55:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11f58:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11f5b:	89 90 74 02 00 00    	mov    %edx,0x274(%eax)
    mmu_set_page_dir(new_page_dir);
   11f61:	83 ec 0c             	sub    $0xc,%esp
   11f64:	ff 75 ec             	pushl  -0x14(%ebp)
   11f67:	e8 de ef ff ff       	call   10f4a <mmu_set_page_dir>
   11f6c:	83 c4 10             	add    $0x10,%esp

    memory_destroy_uvm(old_page_dir);
   11f6f:	83 ec 0c             	sub    $0xc,%esp
   11f72:	ff 75 f0             	pushl  -0x10(%ebp)
   11f75:	e8 78 ea ff ff       	call   109f2 <memory_destroy_uvm>
   11f7a:	83 c4 10             	add    $0x10,%esp

    return 0;
   11f7d:	b8 00 00 00 00       	mov    $0x0,%eax
   11f82:	eb 3d                	jmp    11fc1 <sys_execve+0x1ad>
        goto exec_failed;
   11f84:	90                   	nop
   11f85:	eb 07                	jmp    11f8e <sys_execve+0x17a>
        goto exec_failed;
   11f87:	90                   	nop
   11f88:	eb 04                	jmp    11f8e <sys_execve+0x17a>
        goto exec_failed;
   11f8a:	90                   	nop
   11f8b:	eb 01                	jmp    11f8e <sys_execve+0x17a>
        goto exec_failed;
   11f8d:	90                   	nop

exec_failed:
    if(new_page_dir){
   11f8e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11f92:	74 28                	je     11fbc <sys_execve+0x1a8>
        task->tss.cr3=old_page_dir;
   11f94:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11f97:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11f9a:	89 90 74 02 00 00    	mov    %edx,0x274(%eax)
        mmu_set_page_dir(old_page_dir);
   11fa0:	83 ec 0c             	sub    $0xc,%esp
   11fa3:	ff 75 f0             	pushl  -0x10(%ebp)
   11fa6:	e8 9f ef ff ff       	call   10f4a <mmu_set_page_dir>
   11fab:	83 c4 10             	add    $0x10,%esp

        memory_destroy_uvm(new_page_dir);
   11fae:	83 ec 0c             	sub    $0xc,%esp
   11fb1:	ff 75 ec             	pushl  -0x14(%ebp)
   11fb4:	e8 39 ea ff ff       	call   109f2 <memory_destroy_uvm>
   11fb9:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   11fbc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   11fc1:	c9                   	leave  
   11fc2:	c3                   	ret    

00011fc3 <task_file>:

file_t* task_file(int fd){
   11fc3:	55                   	push   %ebp
   11fc4:	89 e5                	mov    %esp,%ebp
   11fc6:	83 ec 10             	sub    $0x10,%esp
    if((fd>=0) && (fd<TASK_OFILE_NR)){
   11fc9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11fcd:	78 1e                	js     11fed <task_file+0x2a>
   11fcf:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   11fd3:	7f 18                	jg     11fed <task_file+0x2a>
        file_t* file=task_current()->file_table[fd];
   11fd5:	e8 f5 f5 ff ff       	call   115cf <task_current>
   11fda:	89 c2                	mov    %eax,%edx
   11fdc:	8b 45 08             	mov    0x8(%ebp),%eax
   11fdf:	83 c0 10             	add    $0x10,%eax
   11fe2:	8b 04 82             	mov    (%edx,%eax,4),%eax
   11fe5:	89 45 fc             	mov    %eax,-0x4(%ebp)
        return file;
   11fe8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11feb:	eb 05                	jmp    11ff2 <task_file+0x2f>
    }

    return (file_t*)0;
   11fed:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11ff2:	c9                   	leave  
   11ff3:	c3                   	ret    

00011ff4 <task_alloc_fd>:

int task_alloc_fd(file_t* file){
   11ff4:	55                   	push   %ebp
   11ff5:	89 e5                	mov    %esp,%ebp
   11ff7:	83 ec 10             	sub    $0x10,%esp
    task_t* task=task_current();
   11ffa:	e8 d0 f5 ff ff       	call   115cf <task_current>
   11fff:	89 45 f8             	mov    %eax,-0x8(%ebp)

    for(int i=0;i<TASK_OFILE_NR;i++){
   12002:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12009:	eb 2d                	jmp    12038 <task_alloc_fd+0x44>
        file_t* p=task->file_table[i];
   1200b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1200e:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12011:	83 c2 10             	add    $0x10,%edx
   12014:	8b 04 90             	mov    (%eax,%edx,4),%eax
   12017:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(p==(file_t*)0){
   1201a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1201e:	75 14                	jne    12034 <task_alloc_fd+0x40>
            task->file_table[i]=file;
   12020:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12023:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12026:	8d 4a 10             	lea    0x10(%edx),%ecx
   12029:	8b 55 08             	mov    0x8(%ebp),%edx
   1202c:	89 14 88             	mov    %edx,(%eax,%ecx,4)
            return i;
   1202f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12032:	eb 0f                	jmp    12043 <task_alloc_fd+0x4f>
    for(int i=0;i<TASK_OFILE_NR;i++){
   12034:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12038:	83 7d fc 7f          	cmpl   $0x7f,-0x4(%ebp)
   1203c:	7e cd                	jle    1200b <task_alloc_fd+0x17>
        }
    }

    return -1;
   1203e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   12043:	c9                   	leave  
   12044:	c3                   	ret    

00012045 <task_remove_fd>:

void task_remove_fd(int fd){
   12045:	55                   	push   %ebp
   12046:	89 e5                	mov    %esp,%ebp
   if((fd>=0) && (fd<TASK_OFILE_NR)){
   12048:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1204c:	78 1a                	js     12068 <task_remove_fd+0x23>
   1204e:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   12052:	7f 14                	jg     12068 <task_remove_fd+0x23>
       task_current()->file_table[fd]=(file_t*)0;
   12054:	e8 76 f5 ff ff       	call   115cf <task_current>
   12059:	89 c2                	mov    %eax,%edx
   1205b:	8b 45 08             	mov    0x8(%ebp),%eax
   1205e:	83 c0 10             	add    $0x10,%eax
   12061:	c7 04 82 00 00 00 00 	movl   $0x0,(%edx,%eax,4)
    }
}
   12068:	90                   	nop
   12069:	5d                   	pop    %ebp
   1206a:	c3                   	ret    

0001206b <lgdt>:
static inline void lgdt(uint32_t start,uint32_t size){
   1206b:	55                   	push   %ebp
   1206c:	89 e5                	mov    %esp,%ebp
   1206e:	83 ec 10             	sub    $0x10,%esp
    gdt.start31_16=start>>16;
   12071:	8b 45 08             	mov    0x8(%ebp),%eax
   12074:	c1 e8 10             	shr    $0x10,%eax
   12077:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    gdt.start15_0=start&0xFFFF;
   1207b:	8b 45 08             	mov    0x8(%ebp),%eax
   1207e:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    gdt.limit=size-1;
   12082:	8b 45 0c             	mov    0xc(%ebp),%eax
   12085:	83 e8 01             	sub    $0x1,%eax
   12088:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    __asm__ __volatile__(
   1208c:	0f 01 55 fa          	lgdtl  -0x6(%ebp)
}
   12090:	90                   	nop
   12091:	c9                   	leave  
   12092:	c3                   	ret    

00012093 <far_jump>:
static inline void far_jump(uint32_t selector,uint32_t offset){
   12093:	55                   	push   %ebp
   12094:	89 e5                	mov    %esp,%ebp
   12096:	83 ec 10             	sub    $0x10,%esp
    uint32_t addr[]={offset,selector};
   12099:	8b 45 0c             	mov    0xc(%ebp),%eax
   1209c:	89 45 f8             	mov    %eax,-0x8(%ebp)
   1209f:	8b 45 08             	mov    0x8(%ebp),%eax
   120a2:	89 45 fc             	mov    %eax,-0x4(%ebp)
    __asm__ __volatile__(
   120a5:	8d 45 f8             	lea    -0x8(%ebp),%eax
   120a8:	ff 28                	ljmp   *(%eax)
}
   120aa:	90                   	nop
   120ab:	c9                   	leave  
   120ac:	c3                   	ret    

000120ad <segment_desc_set>:
#include "cpu/irq.h"

static segment_desc_t gdt_table[GDT_TABLE_SIZE];
static mutex_t mutex;
// 设置gdt段，selector gdt表的索引，base是段基址，limit是段界限，attr段属性
void segment_desc_set(int selector,uint32_t base,uint32_t limit,uint16_t attr){
   120ad:	55                   	push   %ebp
   120ae:	89 e5                	mov    %esp,%ebp
   120b0:	83 ec 14             	sub    $0x14,%esp
   120b3:	8b 45 14             	mov    0x14(%ebp),%eax
   120b6:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    segment_desc_t* desc=gdt_table+(selector >> 3);
   120ba:	8b 45 08             	mov    0x8(%ebp),%eax
   120bd:	c1 f8 03             	sar    $0x3,%eax
   120c0:	c1 e0 03             	shl    $0x3,%eax
   120c3:	05 e0 17 03 00       	add    $0x317e0,%eax
   120c8:	89 45 fc             	mov    %eax,-0x4(%ebp)

    // 设置G标志位决定粒度4kb or 1B
    if(limit > 0xFFFFF){
   120cb:	81 7d 10 ff ff 0f 00 	cmpl   $0xfffff,0x10(%ebp)
   120d2:	76 0f                	jbe    120e3 <segment_desc_set+0x36>
        attr|=0x8000;
   120d4:	66 81 4d ec 00 80    	orw    $0x8000,-0x14(%ebp)
        limit/=0x1000;
   120da:	8b 45 10             	mov    0x10(%ebp),%eax
   120dd:	c1 e8 0c             	shr    $0xc,%eax
   120e0:	89 45 10             	mov    %eax,0x10(%ebp)
    }
    desc->limit15_0=limit&0xFFFF;
   120e3:	8b 45 10             	mov    0x10(%ebp),%eax
   120e6:	89 c2                	mov    %eax,%edx
   120e8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   120eb:	66 89 10             	mov    %dx,(%eax)
    desc->base15_0=base&0xFFFF;
   120ee:	8b 45 0c             	mov    0xc(%ebp),%eax
   120f1:	89 c2                	mov    %eax,%edx
   120f3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   120f6:	66 89 50 02          	mov    %dx,0x2(%eax)
    desc->base23_16=(base>>16)&0xFF;
   120fa:	8b 45 0c             	mov    0xc(%ebp),%eax
   120fd:	c1 e8 10             	shr    $0x10,%eax
   12100:	89 c2                	mov    %eax,%edx
   12102:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12105:	88 50 04             	mov    %dl,0x4(%eax)
    desc->attr=attr|(((limit>>16)&0xF)<<8);
   12108:	8b 45 10             	mov    0x10(%ebp),%eax
   1210b:	c1 e8 10             	shr    $0x10,%eax
   1210e:	c1 e0 08             	shl    $0x8,%eax
   12111:	66 25 00 0f          	and    $0xf00,%ax
   12115:	66 0b 45 ec          	or     -0x14(%ebp),%ax
   12119:	89 c2                	mov    %eax,%edx
   1211b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1211e:	66 89 50 05          	mov    %dx,0x5(%eax)
    desc->base31_24=(base>>24)&0xFF;
   12122:	8b 45 0c             	mov    0xc(%ebp),%eax
   12125:	c1 e8 18             	shr    $0x18,%eax
   12128:	89 c2                	mov    %eax,%edx
   1212a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1212d:	88 50 07             	mov    %dl,0x7(%eax)

}
   12130:	90                   	nop
   12131:	c9                   	leave  
   12132:	c3                   	ret    

00012133 <init_gdt>:

// 初始化gdt表
void init_gdt(void){
   12133:	55                   	push   %ebp
   12134:	89 e5                	mov    %esp,%ebp
   12136:	83 ec 18             	sub    $0x18,%esp
    for(int i=0;i<GDT_TABLE_SIZE;i++){
   12139:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12140:	eb 19                	jmp    1215b <init_gdt+0x28>
        segment_desc_set(i<<3,0,0,0);
   12142:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12145:	c1 e0 03             	shl    $0x3,%eax
   12148:	6a 00                	push   $0x0
   1214a:	6a 00                	push   $0x0
   1214c:	6a 00                	push   $0x0
   1214e:	50                   	push   %eax
   1214f:	e8 59 ff ff ff       	call   120ad <segment_desc_set>
   12154:	83 c4 10             	add    $0x10,%esp
    for(int i=0;i<GDT_TABLE_SIZE;i++){
   12157:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1215b:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   12162:	7e de                	jle    12142 <init_gdt+0xf>
    }
    segment_desc_set(KERNEL_SELECTOR_DS,0,0xFFFFFFFF,
   12164:	68 92 40 00 00       	push   $0x4092
   12169:	6a ff                	push   $0xffffffff
   1216b:	6a 00                	push   $0x0
   1216d:	6a 10                	push   $0x10
   1216f:	e8 39 ff ff ff       	call   120ad <segment_desc_set>
   12174:	83 c4 10             	add    $0x10,%esp
        SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_DATA | SEG_TYPE_RW
        | SEG_D
    );
    segment_desc_set(KERNEL_SELECTOR_CS, 0x00000000, 0xFFFFFFFF,
   12177:	68 9a c0 00 00       	push   $0xc09a
   1217c:	6a ff                	push   $0xffffffff
   1217e:	6a 00                	push   $0x0
   12180:	6a 08                	push   $0x8
   12182:	e8 26 ff ff ff       	call   120ad <segment_desc_set>
   12187:	83 c4 10             	add    $0x10,%esp
        SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_CODE
        | SEG_TYPE_RW | SEG_D | SEG_G);
    gate_desc_set((gate_desc_t*)(gdt_table+(SELECTOR_SYSCALL >> 3)),
   1218a:	ba c7 02 01 00       	mov    $0x102c7,%edx
   1218f:	b8 f8 17 03 00       	mov    $0x317f8,%eax
   12194:	68 05 ec 00 00       	push   $0xec05
   12199:	52                   	push   %edx
   1219a:	6a 08                	push   $0x8
   1219c:	50                   	push   %eax
   1219d:	e8 1c 00 00 00       	call   121be <gate_desc_set>
   121a2:	83 c4 10             	add    $0x10,%esp
        KERNEL_SELECTOR_CS,(uint32_t)exception_handler_syscall,
        GATE_P_PRESENT | GATE_DPL3 | GATE_TYPE_SYSCALL | SYSCALL_PARAM_COUNT
    );
    lgdt((uint32_t)gdt_table,sizeof(gdt_table));
   121a5:	b8 e0 17 03 00       	mov    $0x317e0,%eax
   121aa:	83 ec 08             	sub    $0x8,%esp
   121ad:	68 00 08 00 00       	push   $0x800
   121b2:	50                   	push   %eax
   121b3:	e8 b3 fe ff ff       	call   1206b <lgdt>
   121b8:	83 c4 10             	add    $0x10,%esp
}
   121bb:	90                   	nop
   121bc:	c9                   	leave  
   121bd:	c3                   	ret    

000121be <gate_desc_set>:

// 设置idt表项
void gate_desc_set(gate_desc_t* desc,uint16_t selector,uint32_t offset,uint16_t attr){
   121be:	55                   	push   %ebp
   121bf:	89 e5                	mov    %esp,%ebp
   121c1:	83 ec 08             	sub    $0x8,%esp
   121c4:	8b 55 0c             	mov    0xc(%ebp),%edx
   121c7:	8b 45 14             	mov    0x14(%ebp),%eax
   121ca:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   121ce:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    desc->offset15_0=offset&0xFFFF;
   121d2:	8b 45 10             	mov    0x10(%ebp),%eax
   121d5:	89 c2                	mov    %eax,%edx
   121d7:	8b 45 08             	mov    0x8(%ebp),%eax
   121da:	66 89 10             	mov    %dx,(%eax)
    desc->selector=selector;
   121dd:	8b 45 08             	mov    0x8(%ebp),%eax
   121e0:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   121e4:	66 89 50 02          	mov    %dx,0x2(%eax)
    desc->attr=attr;
   121e8:	8b 45 08             	mov    0x8(%ebp),%eax
   121eb:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
   121ef:	66 89 50 04          	mov    %dx,0x4(%eax)
    desc->offset31_16=(offset>>16)&0xFFFF;
   121f3:	8b 45 10             	mov    0x10(%ebp),%eax
   121f6:	c1 e8 10             	shr    $0x10,%eax
   121f9:	89 c2                	mov    %eax,%edx
   121fb:	8b 45 08             	mov    0x8(%ebp),%eax
   121fe:	66 89 50 06          	mov    %dx,0x6(%eax)
}
   12202:	90                   	nop
   12203:	c9                   	leave  
   12204:	c3                   	ret    

00012205 <cpu_init>:


void cpu_init(void){
   12205:	55                   	push   %ebp
   12206:	89 e5                	mov    %esp,%ebp
   12208:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&mutex);
   1220b:	83 ec 0c             	sub    $0xc,%esp
   1220e:	68 e0 1f 03 00       	push   $0x31fe0
   12213:	e8 df 28 00 00       	call   14af7 <mutex_init>
   12218:	83 c4 10             	add    $0x10,%esp
    init_gdt();
   1221b:	e8 13 ff ff ff       	call   12133 <init_gdt>
}
   12220:	90                   	nop
   12221:	c9                   	leave  
   12222:	c3                   	ret    

00012223 <gdt_alloc_desc>:

int gdt_alloc_desc(){
   12223:	55                   	push   %ebp
   12224:	89 e5                	mov    %esp,%ebp
   12226:	83 ec 18             	sub    $0x18,%esp
    mutex_lock(&mutex);
   12229:	83 ec 0c             	sub    $0xc,%esp
   1222c:	68 e0 1f 03 00       	push   $0x31fe0
   12231:	e8 ef 28 00 00       	call   14b25 <mutex_lock>
   12236:	83 c4 10             	add    $0x10,%esp
    for(int i=1;i<GDT_TABLE_SIZE;i++){
   12239:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
   12240:	eb 36                	jmp    12278 <gdt_alloc_desc+0x55>
        segment_desc_t* desc=gdt_table+i;
   12242:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12245:	c1 e0 03             	shl    $0x3,%eax
   12248:	05 e0 17 03 00       	add    $0x317e0,%eax
   1224d:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(desc->attr==0){
   12250:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12253:	0f b7 40 05          	movzwl 0x5(%eax),%eax
   12257:	66 85 c0             	test   %ax,%ax
   1225a:	75 18                	jne    12274 <gdt_alloc_desc+0x51>
            mutex_unlock(&mutex);
   1225c:	83 ec 0c             	sub    $0xc,%esp
   1225f:	68 e0 1f 03 00       	push   $0x31fe0
   12264:	e8 4b 29 00 00       	call   14bb4 <mutex_unlock>
   12269:	83 c4 10             	add    $0x10,%esp
            return i*sizeof(segment_desc_t);
   1226c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1226f:	c1 e0 03             	shl    $0x3,%eax
   12272:	eb 22                	jmp    12296 <gdt_alloc_desc+0x73>
    for(int i=1;i<GDT_TABLE_SIZE;i++){
   12274:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12278:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   1227f:	7e c1                	jle    12242 <gdt_alloc_desc+0x1f>
        }
    }
    mutex_unlock(&mutex);
   12281:	83 ec 0c             	sub    $0xc,%esp
   12284:	68 e0 1f 03 00       	push   $0x31fe0
   12289:	e8 26 29 00 00       	call   14bb4 <mutex_unlock>
   1228e:	83 c4 10             	add    $0x10,%esp
    return -1;
   12291:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   12296:	c9                   	leave  
   12297:	c3                   	ret    

00012298 <switch_to_tss>:

void switch_to_tss(int tss_sel){
   12298:	55                   	push   %ebp
   12299:	89 e5                	mov    %esp,%ebp
    far_jump(tss_sel,0);
   1229b:	8b 45 08             	mov    0x8(%ebp),%eax
   1229e:	6a 00                	push   $0x0
   122a0:	50                   	push   %eax
   122a1:	e8 ed fd ff ff       	call   12093 <far_jump>
   122a6:	83 c4 08             	add    $0x8,%esp
}
   122a9:	90                   	nop
   122aa:	c9                   	leave  
   122ab:	c3                   	ret    

000122ac <gdt_free_sel>:

void gdt_free_sel(int sel){
   122ac:	55                   	push   %ebp
   122ad:	89 e5                	mov    %esp,%ebp
   122af:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&mutex);
   122b2:	83 ec 0c             	sub    $0xc,%esp
   122b5:	68 e0 1f 03 00       	push   $0x31fe0
   122ba:	e8 66 28 00 00       	call   14b25 <mutex_lock>
   122bf:	83 c4 10             	add    $0x10,%esp
    gdt_table[sel/sizeof(segment_desc_set)].attr=0;
   122c2:	8b 45 08             	mov    0x8(%ebp),%eax
   122c5:	66 c7 04 c5 e5 17 03 	movw   $0x0,0x317e5(,%eax,8)
   122cc:	00 00 00 
    mutex_unlock(&mutex);
   122cf:	83 ec 0c             	sub    $0xc,%esp
   122d2:	68 e0 1f 03 00       	push   $0x31fe0
   122d7:	e8 d8 28 00 00       	call   14bb4 <mutex_unlock>
   122dc:	83 c4 10             	add    $0x10,%esp
   122df:	90                   	nop
   122e0:	c9                   	leave  
   122e1:	c3                   	ret    

000122e2 <cli>:
static inline void cli(void){
   122e2:	55                   	push   %ebp
   122e3:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("cli");
   122e5:	fa                   	cli    
}
   122e6:	90                   	nop
   122e7:	5d                   	pop    %ebp
   122e8:	c3                   	ret    

000122e9 <sti>:
static inline void sti(void){
   122e9:	55                   	push   %ebp
   122ea:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("sti");
   122ec:	fb                   	sti    
}
   122ed:	90                   	nop
   122ee:	5d                   	pop    %ebp
   122ef:	c3                   	ret    

000122f0 <inb>:
static inline uint8_t inb(uint16_t port){
   122f0:	55                   	push   %ebp
   122f1:	89 e5                	mov    %esp,%ebp
   122f3:	83 ec 14             	sub    $0x14,%esp
   122f6:	8b 45 08             	mov    0x8(%ebp),%eax
   122f9:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__(
   122fd:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   12301:	89 c2                	mov    %eax,%edx
   12303:	ec                   	in     (%dx),%al
   12304:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   12307:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   1230b:	c9                   	leave  
   1230c:	c3                   	ret    

0001230d <outb>:
static inline void outb(uint16_t port,uint8_t data){
   1230d:	55                   	push   %ebp
   1230e:	89 e5                	mov    %esp,%ebp
   12310:	83 ec 08             	sub    $0x8,%esp
   12313:	8b 55 08             	mov    0x8(%ebp),%edx
   12316:	8b 45 0c             	mov    0xc(%ebp),%eax
   12319:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   1231d:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile(
   12320:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   12324:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   12328:	ee                   	out    %al,(%dx)
}
   12329:	90                   	nop
   1232a:	c9                   	leave  
   1232b:	c3                   	ret    

0001232c <lidt>:
static inline void lidt(uint32_t start,uint32_t size){
   1232c:	55                   	push   %ebp
   1232d:	89 e5                	mov    %esp,%ebp
   1232f:	83 ec 10             	sub    $0x10,%esp
    idt.start31_16=start>>16;
   12332:	8b 45 08             	mov    0x8(%ebp),%eax
   12335:	c1 e8 10             	shr    $0x10,%eax
   12338:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    idt.start15_0=start&0xFFFF;
   1233c:	8b 45 08             	mov    0x8(%ebp),%eax
   1233f:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    idt.limit=size-1;
   12343:	8b 45 0c             	mov    0xc(%ebp),%eax
   12346:	83 e8 01             	sub    $0x1,%eax
   12349:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    __asm__ __volatile__(
   1234d:	0f 01 5d fa          	lidtl  -0x6(%ebp)
}
   12351:	90                   	nop
   12352:	c9                   	leave  
   12353:	c3                   	ret    

00012354 <hlt>:
static inline void hlt(void){
   12354:	55                   	push   %ebp
   12355:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile("hlt");
   12357:	f4                   	hlt    
}
   12358:	90                   	nop
   12359:	5d                   	pop    %ebp
   1235a:	c3                   	ret    

0001235b <read_eflags>:
static inline uint32_t read_eflags(void){
   1235b:	55                   	push   %ebp
   1235c:	89 e5                	mov    %esp,%ebp
   1235e:	83 ec 10             	sub    $0x10,%esp
    __asm__ __volatile__(
   12361:	9c                   	pushf  
   12362:	58                   	pop    %eax
   12363:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return eflags;
   12366:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   12369:	c9                   	leave  
   1236a:	c3                   	ret    

0001236b <write_eflags>:
static inline void write_eflags(uint32_t eflags){
   1236b:	55                   	push   %ebp
   1236c:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   1236e:	8b 45 08             	mov    0x8(%ebp),%eax
   12371:	50                   	push   %eax
   12372:	9d                   	popf   
}
   12373:	90                   	nop
   12374:	5d                   	pop    %ebp
   12375:	c3                   	ret    

00012376 <read_cr2>:
        :
        :[v]"r"(v)
    );
}

static inline uint32_t read_cr2(void){
   12376:	55                   	push   %ebp
   12377:	89 e5                	mov    %esp,%ebp
   12379:	83 ec 10             	sub    $0x10,%esp
    uint32_t cr2;
    __asm__ __volatile__(
   1237c:	0f 20 e0             	mov    %cr4,%eax
   1237f:	89 45 fc             	mov    %eax,-0x4(%ebp)
        "mov %%cr4,%[v]"
        :[v]"=r"(cr2)
        :
    );
    return cr2;
   12382:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   12385:	c9                   	leave  
   12386:	c3                   	ret    

00012387 <init_pic>:
#include "cpu/irq.h"

// 初始化8259，开启中断
static void init_pic(void){
   12387:	55                   	push   %ebp
   12388:	89 e5                	mov    %esp,%ebp
	outb(PIC0_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);
   1238a:	6a 11                	push   $0x11
   1238c:	6a 20                	push   $0x20
   1238e:	e8 7a ff ff ff       	call   1230d <outb>
   12393:	83 c4 08             	add    $0x8,%esp
	outb(PIC0_ICW2, IRQ_PIC_START);
   12396:	6a 20                	push   $0x20
   12398:	6a 21                	push   $0x21
   1239a:	e8 6e ff ff ff       	call   1230d <outb>
   1239f:	83 c4 08             	add    $0x8,%esp
	outb(PIC0_ICW3, 1 << 2);
   123a2:	6a 04                	push   $0x4
   123a4:	6a 21                	push   $0x21
   123a6:	e8 62 ff ff ff       	call   1230d <outb>
   123ab:	83 c4 08             	add    $0x8,%esp
	outb(PIC0_ICW4, PIC_ICW4_8086);
   123ae:	6a 01                	push   $0x1
   123b0:	6a 21                	push   $0x21
   123b2:	e8 56 ff ff ff       	call   1230d <outb>
   123b7:	83 c4 08             	add    $0x8,%esp

	outb(PIC1_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);
   123ba:	6a 11                	push   $0x11
   123bc:	68 a0 00 00 00       	push   $0xa0
   123c1:	e8 47 ff ff ff       	call   1230d <outb>
   123c6:	83 c4 08             	add    $0x8,%esp
	outb(PIC1_ICW2, IRQ_PIC_START+8);
   123c9:	6a 28                	push   $0x28
   123cb:	68 a1 00 00 00       	push   $0xa1
   123d0:	e8 38 ff ff ff       	call   1230d <outb>
   123d5:	83 c4 08             	add    $0x8,%esp
	outb(PIC1_ICW3, 2);
   123d8:	6a 02                	push   $0x2
   123da:	68 a1 00 00 00       	push   $0xa1
   123df:	e8 29 ff ff ff       	call   1230d <outb>
   123e4:	83 c4 08             	add    $0x8,%esp
	outb(PIC1_ICW4, PIC_ICW4_8086);
   123e7:	6a 01                	push   $0x1
   123e9:	68 a1 00 00 00       	push   $0xa1
   123ee:	e8 1a ff ff ff       	call   1230d <outb>
   123f3:	83 c4 08             	add    $0x8,%esp

	outb(PIC0_IMR,0xFF & ~(1 << 2));
   123f6:	68 fb 00 00 00       	push   $0xfb
   123fb:	6a 21                	push   $0x21
   123fd:	e8 0b ff ff ff       	call   1230d <outb>
   12402:	83 c4 08             	add    $0x8,%esp
	outb(PIC1_IMR, 0xFF);
   12405:	68 ff 00 00 00       	push   $0xff
   1240a:	68 a1 00 00 00       	push   $0xa1
   1240f:	e8 f9 fe ff ff       	call   1230d <outb>
   12414:	83 c4 08             	add    $0x8,%esp
}
   12417:	90                   	nop
   12418:	c9                   	leave  
   12419:	c3                   	ret    

0001241a <irq_disable_global>:

// 关中断
void irq_disable_global(void){
   1241a:	55                   	push   %ebp
   1241b:	89 e5                	mov    %esp,%ebp
	cli();
   1241d:	e8 c0 fe ff ff       	call   122e2 <cli>
}
   12422:	90                   	nop
   12423:	5d                   	pop    %ebp
   12424:	c3                   	ret    

00012425 <irq_enable_global>:

// 开中断
void irq_enable_global(void){
   12425:	55                   	push   %ebp
   12426:	89 e5                	mov    %esp,%ebp
	sti();
   12428:	e8 bc fe ff ff       	call   122e9 <sti>
}
   1242d:	90                   	nop
   1242e:	5d                   	pop    %ebp
   1242f:	c3                   	ret    

00012430 <irq_enable>:

// 开启特定中断
void irq_enable(int irq_num){
   12430:	55                   	push   %ebp
   12431:	89 e5                	mov    %esp,%ebp
   12433:	53                   	push   %ebx
   12434:	83 ec 10             	sub    $0x10,%esp
	if(irq_num < IRQ_PIC_START){
   12437:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
   1243b:	7e 78                	jle    124b5 <irq_enable+0x85>
		return;
	}
	irq_num-=IRQ_PIC_START;
   1243d:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
	if(irq_num<8){
   12441:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   12445:	7f 32                	jg     12479 <irq_enable+0x49>
		uint8_t mask=inb(PIC0_IMR) & ~(1<<irq_num);
   12447:	6a 21                	push   $0x21
   12449:	e8 a2 fe ff ff       	call   122f0 <inb>
   1244e:	83 c4 04             	add    $0x4,%esp
   12451:	89 c2                	mov    %eax,%edx
   12453:	8b 45 08             	mov    0x8(%ebp),%eax
   12456:	bb 01 00 00 00       	mov    $0x1,%ebx
   1245b:	89 c1                	mov    %eax,%ecx
   1245d:	d3 e3                	shl    %cl,%ebx
   1245f:	89 d8                	mov    %ebx,%eax
   12461:	f7 d0                	not    %eax
   12463:	21 d0                	and    %edx,%eax
   12465:	88 45 fa             	mov    %al,-0x6(%ebp)
		outb(PIC0_IMR,mask);
   12468:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   1246c:	50                   	push   %eax
   1246d:	6a 21                	push   $0x21
   1246f:	e8 99 fe ff ff       	call   1230d <outb>
   12474:	83 c4 08             	add    $0x8,%esp
   12477:	eb 3d                	jmp    124b6 <irq_enable+0x86>
	}
	else{
		irq_num-=8;
   12479:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
		uint8_t mask=inb(PIC1_IMR) & ~(1<<irq_num);
   1247d:	68 a1 00 00 00       	push   $0xa1
   12482:	e8 69 fe ff ff       	call   122f0 <inb>
   12487:	83 c4 04             	add    $0x4,%esp
   1248a:	89 c2                	mov    %eax,%edx
   1248c:	8b 45 08             	mov    0x8(%ebp),%eax
   1248f:	bb 01 00 00 00       	mov    $0x1,%ebx
   12494:	89 c1                	mov    %eax,%ecx
   12496:	d3 e3                	shl    %cl,%ebx
   12498:	89 d8                	mov    %ebx,%eax
   1249a:	f7 d0                	not    %eax
   1249c:	21 d0                	and    %edx,%eax
   1249e:	88 45 fb             	mov    %al,-0x5(%ebp)
		outb(PIC1_IMR,mask);
   124a1:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   124a5:	50                   	push   %eax
   124a6:	68 a1 00 00 00       	push   $0xa1
   124ab:	e8 5d fe ff ff       	call   1230d <outb>
   124b0:	83 c4 08             	add    $0x8,%esp
   124b3:	eb 01                	jmp    124b6 <irq_enable+0x86>
		return;
   124b5:	90                   	nop
	}
}
   124b6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   124b9:	c9                   	leave  
   124ba:	c3                   	ret    

000124bb <irq_disable>:

// 关闭特定中断
void irq_disable(int irq_num){
   124bb:	55                   	push   %ebp
   124bc:	89 e5                	mov    %esp,%ebp
   124be:	53                   	push   %ebx
   124bf:	83 ec 10             	sub    $0x10,%esp
	if(irq_num < IRQ_PIC_START){
   124c2:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
   124c6:	7e 74                	jle    1253c <irq_disable+0x81>
		return;
	}
	irq_num-=IRQ_PIC_START;
   124c8:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
	if(irq_num<8){
   124cc:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   124d0:	7f 30                	jg     12502 <irq_disable+0x47>
		uint8_t mask=inb(PIC0_IMR) | (1<<irq_num);
   124d2:	6a 21                	push   $0x21
   124d4:	e8 17 fe ff ff       	call   122f0 <inb>
   124d9:	83 c4 04             	add    $0x4,%esp
   124dc:	89 c3                	mov    %eax,%ebx
   124de:	8b 45 08             	mov    0x8(%ebp),%eax
   124e1:	ba 01 00 00 00       	mov    $0x1,%edx
   124e6:	89 c1                	mov    %eax,%ecx
   124e8:	d3 e2                	shl    %cl,%edx
   124ea:	89 d0                	mov    %edx,%eax
   124ec:	09 d8                	or     %ebx,%eax
   124ee:	88 45 fa             	mov    %al,-0x6(%ebp)
		outb(PIC0_IMR,mask);
   124f1:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   124f5:	50                   	push   %eax
   124f6:	6a 21                	push   $0x21
   124f8:	e8 10 fe ff ff       	call   1230d <outb>
   124fd:	83 c4 08             	add    $0x8,%esp
   12500:	eb 3b                	jmp    1253d <irq_disable+0x82>
	}
	else{
		irq_num-=8;
   12502:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
		uint8_t mask=inb(PIC1_IMR) | (1<<irq_num);
   12506:	68 a1 00 00 00       	push   $0xa1
   1250b:	e8 e0 fd ff ff       	call   122f0 <inb>
   12510:	83 c4 04             	add    $0x4,%esp
   12513:	89 c3                	mov    %eax,%ebx
   12515:	8b 45 08             	mov    0x8(%ebp),%eax
   12518:	ba 01 00 00 00       	mov    $0x1,%edx
   1251d:	89 c1                	mov    %eax,%ecx
   1251f:	d3 e2                	shl    %cl,%edx
   12521:	89 d0                	mov    %edx,%eax
   12523:	09 d8                	or     %ebx,%eax
   12525:	88 45 fb             	mov    %al,-0x5(%ebp)
		outb(PIC1_IMR,mask);
   12528:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   1252c:	50                   	push   %eax
   1252d:	68 a1 00 00 00       	push   $0xa1
   12532:	e8 d6 fd ff ff       	call   1230d <outb>
   12537:	83 c4 08             	add    $0x8,%esp
   1253a:	eb 01                	jmp    1253d <irq_disable+0x82>
		return;
   1253c:	90                   	nop
	}
}
   1253d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   12540:	c9                   	leave  
   12541:	c3                   	ret    

00012542 <irq_init>:

// 定义中断向量表
static gate_desc_t idt_table[IDT_TABLE_NR];
void irq_init(void){
   12542:	55                   	push   %ebp
   12543:	89 e5                	mov    %esp,%ebp
   12545:	83 ec 18             	sub    $0x18,%esp
    for(uint32_t i=0;i<IDT_TABLE_NR;i++){
   12548:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1254f:	eb 25                	jmp    12576 <irq_init+0x34>
        gate_desc_set(idt_table+i,KERNEL_SELECTOR_CS,(uint32_t)exception_handler_unknown,
   12551:	ba 2b 00 01 00       	mov    $0x1002b,%edx
   12556:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12559:	c1 e0 03             	shl    $0x3,%eax
   1255c:	05 00 20 03 00       	add    $0x32000,%eax
   12561:	68 00 8e 00 00       	push   $0x8e00
   12566:	52                   	push   %edx
   12567:	6a 08                	push   $0x8
   12569:	50                   	push   %eax
   1256a:	e8 4f fc ff ff       	call   121be <gate_desc_set>
   1256f:	83 c4 10             	add    $0x10,%esp
    for(uint32_t i=0;i<IDT_TABLE_NR;i++){
   12572:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12576:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
   1257a:	76 d5                	jbe    12551 <irq_init+0xf>
        GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_INT);
    }

    
    irq_install(IRQ0_DE, (irq_handler_t)exception_handler_divider);
   1257c:	83 ec 08             	sub    $0x8,%esp
   1257f:	68 4a 00 01 00       	push   $0x1004a
   12584:	6a 00                	push   $0x0
   12586:	e8 65 01 00 00       	call   126f0 <irq_install>
   1258b:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ1_DB, (irq_handler_t)exception_handler_Debug);
   1258e:	83 ec 08             	sub    $0x8,%esp
   12591:	68 69 00 01 00       	push   $0x10069
   12596:	6a 01                	push   $0x1
   12598:	e8 53 01 00 00       	call   126f0 <irq_install>
   1259d:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ2_NMI, (irq_handler_t)exception_handler_NMI);
   125a0:	83 ec 08             	sub    $0x8,%esp
   125a3:	68 88 00 01 00       	push   $0x10088
   125a8:	6a 02                	push   $0x2
   125aa:	e8 41 01 00 00       	call   126f0 <irq_install>
   125af:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ3_BP, (irq_handler_t)exception_handler_breakpoint);
   125b2:	83 ec 08             	sub    $0x8,%esp
   125b5:	68 a7 00 01 00       	push   $0x100a7
   125ba:	6a 03                	push   $0x3
   125bc:	e8 2f 01 00 00       	call   126f0 <irq_install>
   125c1:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ4_OF, (irq_handler_t)exception_handler_overflow);
   125c4:	83 ec 08             	sub    $0x8,%esp
   125c7:	68 c6 00 01 00       	push   $0x100c6
   125cc:	6a 04                	push   $0x4
   125ce:	e8 1d 01 00 00       	call   126f0 <irq_install>
   125d3:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ5_BR, (irq_handler_t)exception_handler_bound_range);
   125d6:	83 ec 08             	sub    $0x8,%esp
   125d9:	68 e5 00 01 00       	push   $0x100e5
   125de:	6a 05                	push   $0x5
   125e0:	e8 0b 01 00 00       	call   126f0 <irq_install>
   125e5:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ6_UD, (irq_handler_t)exception_handler_invalid_opcode);
   125e8:	83 ec 08             	sub    $0x8,%esp
   125eb:	68 04 01 01 00       	push   $0x10104
   125f0:	6a 06                	push   $0x6
   125f2:	e8 f9 00 00 00       	call   126f0 <irq_install>
   125f7:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ7_NM, (irq_handler_t)exception_handler_device_unavailable);
   125fa:	83 ec 08             	sub    $0x8,%esp
   125fd:	68 23 01 01 00       	push   $0x10123
   12602:	6a 07                	push   $0x7
   12604:	e8 e7 00 00 00       	call   126f0 <irq_install>
   12609:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ8_DF, (irq_handler_t)exception_handler_double_fault);
   1260c:	83 ec 08             	sub    $0x8,%esp
   1260f:	68 42 01 01 00       	push   $0x10142
   12614:	6a 08                	push   $0x8
   12616:	e8 d5 00 00 00       	call   126f0 <irq_install>
   1261b:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ10_TS, (irq_handler_t)exception_handler_invalid_tss);
   1261e:	83 ec 08             	sub    $0x8,%esp
   12621:	68 5f 01 01 00       	push   $0x1015f
   12626:	6a 0a                	push   $0xa
   12628:	e8 c3 00 00 00       	call   126f0 <irq_install>
   1262d:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ11_NP, (irq_handler_t)exception_handler_segment_not_present);
   12630:	83 ec 08             	sub    $0x8,%esp
   12633:	68 7c 01 01 00       	push   $0x1017c
   12638:	6a 0b                	push   $0xb
   1263a:	e8 b1 00 00 00       	call   126f0 <irq_install>
   1263f:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ12_SS, (irq_handler_t)exception_handler_stack_segment_fault);
   12642:	83 ec 08             	sub    $0x8,%esp
   12645:	68 99 01 01 00       	push   $0x10199
   1264a:	6a 0c                	push   $0xc
   1264c:	e8 9f 00 00 00       	call   126f0 <irq_install>
   12651:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ13_GP, (irq_handler_t)exception_handler_general_protection);
   12654:	83 ec 08             	sub    $0x8,%esp
   12657:	68 b6 01 01 00       	push   $0x101b6
   1265c:	6a 0d                	push   $0xd
   1265e:	e8 8d 00 00 00       	call   126f0 <irq_install>
   12663:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ14_PF, (irq_handler_t)exception_handler_page_fault);
   12666:	83 ec 08             	sub    $0x8,%esp
   12669:	68 d3 01 01 00       	push   $0x101d3
   1266e:	6a 0e                	push   $0xe
   12670:	e8 7b 00 00 00       	call   126f0 <irq_install>
   12675:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ16_MF, (irq_handler_t)exception_handler_fpu_error);
   12678:	83 ec 08             	sub    $0x8,%esp
   1267b:	68 f0 01 01 00       	push   $0x101f0
   12680:	6a 10                	push   $0x10
   12682:	e8 69 00 00 00       	call   126f0 <irq_install>
   12687:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ17_AC, (irq_handler_t)exception_handler_alignment_check);
   1268a:	83 ec 08             	sub    $0x8,%esp
   1268d:	68 0f 02 01 00       	push   $0x1020f
   12692:	6a 11                	push   $0x11
   12694:	e8 57 00 00 00       	call   126f0 <irq_install>
   12699:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ18_MC, (irq_handler_t)exception_handler_machine_check);
   1269c:	83 ec 08             	sub    $0x8,%esp
   1269f:	68 2c 02 01 00       	push   $0x1022c
   126a4:	6a 12                	push   $0x12
   126a6:	e8 45 00 00 00       	call   126f0 <irq_install>
   126ab:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ19_XM, (irq_handler_t)exception_handler_smd_exception);
   126ae:	83 ec 08             	sub    $0x8,%esp
   126b1:	68 4b 02 01 00       	push   $0x1024b
   126b6:	6a 13                	push   $0x13
   126b8:	e8 33 00 00 00       	call   126f0 <irq_install>
   126bd:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ20_VE, (irq_handler_t)exception_handler_virtual_exception);
   126c0:	83 ec 08             	sub    $0x8,%esp
   126c3:	68 6a 02 01 00       	push   $0x1026a
   126c8:	6a 14                	push   $0x14
   126ca:	e8 21 00 00 00       	call   126f0 <irq_install>
   126cf:	83 c4 10             	add    $0x10,%esp

    lidt((uint32_t)idt_table,sizeof(idt_table));
   126d2:	b8 00 20 03 00       	mov    $0x32000,%eax
   126d7:	83 ec 08             	sub    $0x8,%esp
   126da:	68 00 04 00 00       	push   $0x400
   126df:	50                   	push   %eax
   126e0:	e8 47 fc ff ff       	call   1232c <lidt>
   126e5:	83 c4 10             	add    $0x10,%esp

	// 初始化8259用于开启中断
	init_pic();
   126e8:	e8 9a fc ff ff       	call   12387 <init_pic>

}
   126ed:	90                   	nop
   126ee:	c9                   	leave  
   126ef:	c3                   	ret    

000126f0 <irq_install>:

// 将对应的中断添加到idt表中
int irq_install(int irq_num,irq_handler_t handler){
   126f0:	55                   	push   %ebp
   126f1:	89 e5                	mov    %esp,%ebp
   126f3:	83 ec 08             	sub    $0x8,%esp
    if(irq_num >= IDT_TABLE_NR){
   126f6:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   126fa:	7e 07                	jle    12703 <irq_install+0x13>
        return -1;
   126fc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   12701:	eb 25                	jmp    12728 <irq_install+0x38>
    }
    gate_desc_set(idt_table+irq_num,KERNEL_SELECTOR_CS,(uint32_t)handler,
   12703:	8b 45 0c             	mov    0xc(%ebp),%eax
   12706:	8b 55 08             	mov    0x8(%ebp),%edx
   12709:	c1 e2 03             	shl    $0x3,%edx
   1270c:	81 c2 00 20 03 00    	add    $0x32000,%edx
   12712:	68 00 8e 00 00       	push   $0x8e00
   12717:	50                   	push   %eax
   12718:	6a 08                	push   $0x8
   1271a:	52                   	push   %edx
   1271b:	e8 9e fa ff ff       	call   121be <gate_desc_set>
   12720:	83 c4 10             	add    $0x10,%esp
     GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_INT);
    return 0;
   12723:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12728:	c9                   	leave  
   12729:	c3                   	ret    

0001272a <dump_core_regs>:


static void dump_core_regs(exception_frame_t*frame){
   1272a:	55                   	push   %ebp
   1272b:	89 e5                	mov    %esp,%ebp
   1272d:	57                   	push   %edi
   1272e:	56                   	push   %esi
   1272f:	53                   	push   %ebx
   12730:	83 ec 2c             	sub    $0x2c,%esp
	log_printf("IRQ: %d, error code: %d",frame->num,frame->error_code);
   12733:	8b 45 08             	mov    0x8(%ebp),%eax
   12736:	8b 50 34             	mov    0x34(%eax),%edx
   12739:	8b 45 08             	mov    0x8(%ebp),%eax
   1273c:	8b 40 30             	mov    0x30(%eax),%eax
   1273f:	83 ec 04             	sub    $0x4,%esp
   12742:	52                   	push   %edx
   12743:	50                   	push   %eax
   12744:	68 40 5d 01 00       	push   $0x15d40
   12749:	e8 c4 30 00 00       	call   15812 <log_printf>
   1274e:	83 c4 10             	add    $0x10,%esp
	uint32_t ss,esp;
	if(frame->cs & 0x3){
   12751:	8b 45 08             	mov    0x8(%ebp),%eax
   12754:	8b 40 3c             	mov    0x3c(%eax),%eax
   12757:	83 e0 03             	and    $0x3,%eax
   1275a:	85 c0                	test   %eax,%eax
   1275c:	74 14                	je     12772 <dump_core_regs+0x48>
		ss=frame->ss3;
   1275e:	8b 45 08             	mov    0x8(%ebp),%eax
   12761:	8b 40 48             	mov    0x48(%eax),%eax
   12764:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		esp=frame->esp3;
   12767:	8b 45 08             	mov    0x8(%ebp),%eax
   1276a:	8b 40 44             	mov    0x44(%eax),%eax
   1276d:	89 45 e0             	mov    %eax,-0x20(%ebp)
   12770:	eb 12                	jmp    12784 <dump_core_regs+0x5a>
	}else{
		ss=frame->ds;
   12772:	8b 45 08             	mov    0x8(%ebp),%eax
   12775:	8b 40 0c             	mov    0xc(%eax),%eax
   12778:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		esp=frame->esp;
   1277b:	8b 45 08             	mov    0x8(%ebp),%eax
   1277e:	8b 40 1c             	mov    0x1c(%eax),%eax
   12781:	89 45 e0             	mov    %eax,-0x20(%ebp)
	}
	log_printf("CS: %d\nDS: %d\nES: %d\nSS: %d\nFS: %d\nGS: %d",
   12784:	8b 45 08             	mov    0x8(%ebp),%eax
   12787:	8b 18                	mov    (%eax),%ebx
   12789:	8b 45 08             	mov    0x8(%ebp),%eax
   1278c:	8b 48 08             	mov    0x8(%eax),%ecx
   1278f:	8b 45 08             	mov    0x8(%ebp),%eax
   12792:	8b 50 0c             	mov    0xc(%eax),%edx
   12795:	8b 45 08             	mov    0x8(%ebp),%eax
   12798:	8b 40 3c             	mov    0x3c(%eax),%eax
   1279b:	83 ec 08             	sub    $0x8,%esp
   1279e:	53                   	push   %ebx
   1279f:	ff 75 e4             	pushl  -0x1c(%ebp)
   127a2:	51                   	push   %ecx
   127a3:	52                   	push   %edx
   127a4:	50                   	push   %eax
   127a5:	68 58 5d 01 00       	push   $0x15d58
   127aa:	e8 63 30 00 00       	call   15812 <log_printf>
   127af:	83 c4 20             	add    $0x20,%esp
		frame->cs,frame->ds,frame->es,ss,frame->gs
	);
	log_printf("EAX: 0x%x\nEBX: 0x%x\nECX: 0x%x\nEDX: 0x%x\nEDI: 0x%x\nESI: 0x%x\n"
   127b2:	8b 45 08             	mov    0x8(%ebp),%eax
   127b5:	8b 40 18             	mov    0x18(%eax),%eax
   127b8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   127bb:	8b 45 08             	mov    0x8(%ebp),%eax
   127be:	8b 78 14             	mov    0x14(%eax),%edi
   127c1:	8b 45 08             	mov    0x8(%ebp),%eax
   127c4:	8b 70 10             	mov    0x10(%eax),%esi
   127c7:	8b 45 08             	mov    0x8(%ebp),%eax
   127ca:	8b 58 24             	mov    0x24(%eax),%ebx
   127cd:	8b 45 08             	mov    0x8(%ebp),%eax
   127d0:	8b 48 28             	mov    0x28(%eax),%ecx
   127d3:	8b 45 08             	mov    0x8(%ebp),%eax
   127d6:	8b 50 20             	mov    0x20(%eax),%edx
   127d9:	8b 45 08             	mov    0x8(%ebp),%eax
   127dc:	8b 40 2c             	mov    0x2c(%eax),%eax
   127df:	83 ec 0c             	sub    $0xc,%esp
   127e2:	ff 75 e0             	pushl  -0x20(%ebp)
   127e5:	ff 75 d4             	pushl  -0x2c(%ebp)
   127e8:	57                   	push   %edi
   127e9:	56                   	push   %esi
   127ea:	53                   	push   %ebx
   127eb:	51                   	push   %ecx
   127ec:	52                   	push   %edx
   127ed:	50                   	push   %eax
   127ee:	68 84 5d 01 00       	push   $0x15d84
   127f3:	e8 1a 30 00 00       	call   15812 <log_printf>
   127f8:	83 c4 30             	add    $0x30,%esp
	"EBP: 0x%x\nESP: 0x%x",
		frame->eax,frame->ebx,frame->ecx,frame->edx,
		frame->edi,frame->esi,frame->ebp,esp
	);
	log_printf("EIP: 0x%x\nEFLAGS:0x%x\n",frame->eip,frame->eflags);
   127fb:	8b 45 08             	mov    0x8(%ebp),%eax
   127fe:	8b 50 40             	mov    0x40(%eax),%edx
   12801:	8b 45 08             	mov    0x8(%ebp),%eax
   12804:	8b 40 38             	mov    0x38(%eax),%eax
   12807:	83 ec 04             	sub    $0x4,%esp
   1280a:	52                   	push   %edx
   1280b:	50                   	push   %eax
   1280c:	68 d4 5d 01 00       	push   $0x15dd4
   12811:	e8 fc 2f 00 00       	call   15812 <log_printf>
   12816:	83 c4 10             	add    $0x10,%esp
}
   12819:	90                   	nop
   1281a:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1281d:	5b                   	pop    %ebx
   1281e:	5e                   	pop    %esi
   1281f:	5f                   	pop    %edi
   12820:	5d                   	pop    %ebp
   12821:	c3                   	ret    

00012822 <do_default_handler>:

static void do_default_handler(exception_frame_t* frame,char* message){
   12822:	55                   	push   %ebp
   12823:	89 e5                	mov    %esp,%ebp
   12825:	83 ec 08             	sub    $0x8,%esp
	log_printf("---------------");
   12828:	83 ec 0c             	sub    $0xc,%esp
   1282b:	68 eb 5d 01 00       	push   $0x15deb
   12830:	e8 dd 2f 00 00       	call   15812 <log_printf>
   12835:	83 c4 10             	add    $0x10,%esp
	log_printf("IRQ/Exception happened: %s",message);
   12838:	83 ec 08             	sub    $0x8,%esp
   1283b:	ff 75 0c             	pushl  0xc(%ebp)
   1283e:	68 fb 5d 01 00       	push   $0x15dfb
   12843:	e8 ca 2f 00 00       	call   15812 <log_printf>
   12848:	83 c4 10             	add    $0x10,%esp
	dump_core_regs(frame);
   1284b:	83 ec 0c             	sub    $0xc,%esp
   1284e:	ff 75 08             	pushl  0x8(%ebp)
   12851:	e8 d4 fe ff ff       	call   1272a <dump_core_regs>
   12856:	83 c4 10             	add    $0x10,%esp
    hlt();
   12859:	e8 f6 fa ff ff       	call   12354 <hlt>
}
   1285e:	90                   	nop
   1285f:	c9                   	leave  
   12860:	c3                   	ret    

00012861 <do_handler_unknown>:

// 会被对应exception_handler的call调用
void do_handler_unknown(exception_frame_t* frame){
   12861:	55                   	push   %ebp
   12862:	89 e5                	mov    %esp,%ebp
   12864:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"unknown exception");
   12867:	83 ec 08             	sub    $0x8,%esp
   1286a:	68 16 5e 01 00       	push   $0x15e16
   1286f:	ff 75 08             	pushl  0x8(%ebp)
   12872:	e8 ab ff ff ff       	call   12822 <do_default_handler>
   12877:	83 c4 10             	add    $0x10,%esp
}
   1287a:	90                   	nop
   1287b:	c9                   	leave  
   1287c:	c3                   	ret    

0001287d <do_handler_divider>:

void do_handler_divider(exception_frame_t* frame){
   1287d:	55                   	push   %ebp
   1287e:	89 e5                	mov    %esp,%ebp
   12880:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"Divider exception");
   12883:	83 ec 08             	sub    $0x8,%esp
   12886:	68 28 5e 01 00       	push   $0x15e28
   1288b:	ff 75 08             	pushl  0x8(%ebp)
   1288e:	e8 8f ff ff ff       	call   12822 <do_default_handler>
   12893:	83 c4 10             	add    $0x10,%esp
}
   12896:	90                   	nop
   12897:	c9                   	leave  
   12898:	c3                   	ret    

00012899 <do_handler_Debug>:

void do_handler_Debug(exception_frame_t * frame) {
   12899:	55                   	push   %ebp
   1289a:	89 e5                	mov    %esp,%ebp
   1289c:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Debug Exception");
   1289f:	83 ec 08             	sub    $0x8,%esp
   128a2:	68 3a 5e 01 00       	push   $0x15e3a
   128a7:	ff 75 08             	pushl  0x8(%ebp)
   128aa:	e8 73 ff ff ff       	call   12822 <do_default_handler>
   128af:	83 c4 10             	add    $0x10,%esp
}
   128b2:	90                   	nop
   128b3:	c9                   	leave  
   128b4:	c3                   	ret    

000128b5 <do_handler_NMI>:

void do_handler_NMI(exception_frame_t * frame) {
   128b5:	55                   	push   %ebp
   128b6:	89 e5                	mov    %esp,%ebp
   128b8:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "NMI Interrupt.");
   128bb:	83 ec 08             	sub    $0x8,%esp
   128be:	68 4a 5e 01 00       	push   $0x15e4a
   128c3:	ff 75 08             	pushl  0x8(%ebp)
   128c6:	e8 57 ff ff ff       	call   12822 <do_default_handler>
   128cb:	83 c4 10             	add    $0x10,%esp
}
   128ce:	90                   	nop
   128cf:	c9                   	leave  
   128d0:	c3                   	ret    

000128d1 <do_handler_breakpoint>:

void do_handler_breakpoint(exception_frame_t * frame) {
   128d1:	55                   	push   %ebp
   128d2:	89 e5                	mov    %esp,%ebp
   128d4:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Breakpoint.");
   128d7:	83 ec 08             	sub    $0x8,%esp
   128da:	68 59 5e 01 00       	push   $0x15e59
   128df:	ff 75 08             	pushl  0x8(%ebp)
   128e2:	e8 3b ff ff ff       	call   12822 <do_default_handler>
   128e7:	83 c4 10             	add    $0x10,%esp
}
   128ea:	90                   	nop
   128eb:	c9                   	leave  
   128ec:	c3                   	ret    

000128ed <do_handler_overflow>:

void do_handler_overflow(exception_frame_t * frame) {
   128ed:	55                   	push   %ebp
   128ee:	89 e5                	mov    %esp,%ebp
   128f0:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Overflow.");
   128f3:	83 ec 08             	sub    $0x8,%esp
   128f6:	68 65 5e 01 00       	push   $0x15e65
   128fb:	ff 75 08             	pushl  0x8(%ebp)
   128fe:	e8 1f ff ff ff       	call   12822 <do_default_handler>
   12903:	83 c4 10             	add    $0x10,%esp
}
   12906:	90                   	nop
   12907:	c9                   	leave  
   12908:	c3                   	ret    

00012909 <do_handler_bound_range>:

void do_handler_bound_range(exception_frame_t * frame) {
   12909:	55                   	push   %ebp
   1290a:	89 e5                	mov    %esp,%ebp
   1290c:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "BOUND Range Exceeded.");
   1290f:	83 ec 08             	sub    $0x8,%esp
   12912:	68 6f 5e 01 00       	push   $0x15e6f
   12917:	ff 75 08             	pushl  0x8(%ebp)
   1291a:	e8 03 ff ff ff       	call   12822 <do_default_handler>
   1291f:	83 c4 10             	add    $0x10,%esp
}
   12922:	90                   	nop
   12923:	c9                   	leave  
   12924:	c3                   	ret    

00012925 <do_handler_invalid_opcode>:

void do_handler_invalid_opcode(exception_frame_t * frame) {
   12925:	55                   	push   %ebp
   12926:	89 e5                	mov    %esp,%ebp
   12928:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Invalid Opcode.");
   1292b:	83 ec 08             	sub    $0x8,%esp
   1292e:	68 85 5e 01 00       	push   $0x15e85
   12933:	ff 75 08             	pushl  0x8(%ebp)
   12936:	e8 e7 fe ff ff       	call   12822 <do_default_handler>
   1293b:	83 c4 10             	add    $0x10,%esp
}
   1293e:	90                   	nop
   1293f:	c9                   	leave  
   12940:	c3                   	ret    

00012941 <do_handler_device_unavailable>:

void do_handler_device_unavailable(exception_frame_t * frame) {
   12941:	55                   	push   %ebp
   12942:	89 e5                	mov    %esp,%ebp
   12944:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Device Not Available.");
   12947:	83 ec 08             	sub    $0x8,%esp
   1294a:	68 95 5e 01 00       	push   $0x15e95
   1294f:	ff 75 08             	pushl  0x8(%ebp)
   12952:	e8 cb fe ff ff       	call   12822 <do_default_handler>
   12957:	83 c4 10             	add    $0x10,%esp
}
   1295a:	90                   	nop
   1295b:	c9                   	leave  
   1295c:	c3                   	ret    

0001295d <do_handler_double_fault>:

void do_handler_double_fault(exception_frame_t * frame) {
   1295d:	55                   	push   %ebp
   1295e:	89 e5                	mov    %esp,%ebp
   12960:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Double Fault.");
   12963:	83 ec 08             	sub    $0x8,%esp
   12966:	68 ab 5e 01 00       	push   $0x15eab
   1296b:	ff 75 08             	pushl  0x8(%ebp)
   1296e:	e8 af fe ff ff       	call   12822 <do_default_handler>
   12973:	83 c4 10             	add    $0x10,%esp
}
   12976:	90                   	nop
   12977:	c9                   	leave  
   12978:	c3                   	ret    

00012979 <do_handler_invalid_tss>:

void do_handler_invalid_tss(exception_frame_t * frame) {
   12979:	55                   	push   %ebp
   1297a:	89 e5                	mov    %esp,%ebp
   1297c:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Invalid TSS");
   1297f:	83 ec 08             	sub    $0x8,%esp
   12982:	68 b9 5e 01 00       	push   $0x15eb9
   12987:	ff 75 08             	pushl  0x8(%ebp)
   1298a:	e8 93 fe ff ff       	call   12822 <do_default_handler>
   1298f:	83 c4 10             	add    $0x10,%esp
}
   12992:	90                   	nop
   12993:	c9                   	leave  
   12994:	c3                   	ret    

00012995 <do_handler_segment_not_present>:

void do_handler_segment_not_present(exception_frame_t * frame) {
   12995:	55                   	push   %ebp
   12996:	89 e5                	mov    %esp,%ebp
   12998:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Segment Not Present.");
   1299b:	83 ec 08             	sub    $0x8,%esp
   1299e:	68 c5 5e 01 00       	push   $0x15ec5
   129a3:	ff 75 08             	pushl  0x8(%ebp)
   129a6:	e8 77 fe ff ff       	call   12822 <do_default_handler>
   129ab:	83 c4 10             	add    $0x10,%esp
}
   129ae:	90                   	nop
   129af:	c9                   	leave  
   129b0:	c3                   	ret    

000129b1 <do_handler_stack_segment_fault>:

void do_handler_stack_segment_fault(exception_frame_t * frame) {
   129b1:	55                   	push   %ebp
   129b2:	89 e5                	mov    %esp,%ebp
   129b4:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Stack-Segment Fault.");
   129b7:	83 ec 08             	sub    $0x8,%esp
   129ba:	68 da 5e 01 00       	push   $0x15eda
   129bf:	ff 75 08             	pushl  0x8(%ebp)
   129c2:	e8 5b fe ff ff       	call   12822 <do_default_handler>
   129c7:	83 c4 10             	add    $0x10,%esp
}
   129ca:	90                   	nop
   129cb:	c9                   	leave  
   129cc:	c3                   	ret    

000129cd <do_handler_general_protection>:

void do_handler_general_protection(exception_frame_t * frame) {
   129cd:	55                   	push   %ebp
   129ce:	89 e5                	mov    %esp,%ebp
   129d0:	83 ec 08             	sub    $0x8,%esp
	log_printf("--------------------------------");
   129d3:	83 ec 0c             	sub    $0xc,%esp
   129d6:	68 f0 5e 01 00       	push   $0x15ef0
   129db:	e8 32 2e 00 00       	call   15812 <log_printf>
   129e0:	83 c4 10             	add    $0x10,%esp
    log_printf("IRQ/Exception happend: General Protection.");
   129e3:	83 ec 0c             	sub    $0xc,%esp
   129e6:	68 14 5f 01 00       	push   $0x15f14
   129eb:	e8 22 2e 00 00       	call   15812 <log_printf>
   129f0:	83 c4 10             	add    $0x10,%esp
    if (frame->error_code & ERR_EXT) {
   129f3:	8b 45 08             	mov    0x8(%ebp),%eax
   129f6:	8b 40 34             	mov    0x34(%eax),%eax
   129f9:	83 e0 01             	and    $0x1,%eax
   129fc:	85 c0                	test   %eax,%eax
   129fe:	74 12                	je     12a12 <do_handler_general_protection+0x45>
        log_printf("the exception occurred during delivery of an "
   12a00:	83 ec 0c             	sub    $0xc,%esp
   12a03:	68 40 5f 01 00       	push   $0x15f40
   12a08:	e8 05 2e 00 00       	call   15812 <log_printf>
   12a0d:	83 c4 10             	add    $0x10,%esp
   12a10:	eb 10                	jmp    12a22 <do_handler_general_protection+0x55>
                "event external to the program, such as an interrupt"
                "or an earlier exception.");
    } else {
        log_printf("the exception occurred during delivery of a"
   12a12:	83 ec 0c             	sub    $0xc,%esp
   12a15:	68 bc 5f 01 00       	push   $0x15fbc
   12a1a:	e8 f3 2d 00 00       	call   15812 <log_printf>
   12a1f:	83 c4 10             	add    $0x10,%esp
                    "software interrupt (INT n, INT3, or INTO).");
    }
    
    if (frame->error_code & ERR_IDT) {
   12a22:	8b 45 08             	mov    0x8(%ebp),%eax
   12a25:	8b 40 34             	mov    0x34(%eax),%eax
   12a28:	83 e0 02             	and    $0x2,%eax
   12a2b:	85 c0                	test   %eax,%eax
   12a2d:	74 12                	je     12a41 <do_handler_general_protection+0x74>
        log_printf("the index portion of the error code refers "
   12a2f:	83 ec 0c             	sub    $0xc,%esp
   12a32:	68 14 60 01 00       	push   $0x16014
   12a37:	e8 d6 2d 00 00       	call   15812 <log_printf>
   12a3c:	83 c4 10             	add    $0x10,%esp
   12a3f:	eb 10                	jmp    12a51 <do_handler_general_protection+0x84>
                    "to a gate descriptor in the IDT");
    } else {
        log_printf("the index refers to a descriptor in the GDT");
   12a41:	83 ec 0c             	sub    $0xc,%esp
   12a44:	68 60 60 01 00       	push   $0x16060
   12a49:	e8 c4 2d 00 00       	call   15812 <log_printf>
   12a4e:	83 c4 10             	add    $0x10,%esp
    }
    
    log_printf("segment index: %d", frame->error_code & 0xFFF8);
   12a51:	8b 45 08             	mov    0x8(%ebp),%eax
   12a54:	8b 40 34             	mov    0x34(%eax),%eax
   12a57:	25 f8 ff 00 00       	and    $0xfff8,%eax
   12a5c:	83 ec 08             	sub    $0x8,%esp
   12a5f:	50                   	push   %eax
   12a60:	68 8c 60 01 00       	push   $0x1608c
   12a65:	e8 a8 2d 00 00       	call   15812 <log_printf>
   12a6a:	83 c4 10             	add    $0x10,%esp

    dump_core_regs(frame);
   12a6d:	83 ec 0c             	sub    $0xc,%esp
   12a70:	ff 75 08             	pushl  0x8(%ebp)
   12a73:	e8 b2 fc ff ff       	call   1272a <dump_core_regs>
   12a78:	83 c4 10             	add    $0x10,%esp
    while (1) {
        hlt();
   12a7b:	e8 d4 f8 ff ff       	call   12354 <hlt>
   12a80:	eb f9                	jmp    12a7b <do_handler_general_protection+0xae>

00012a82 <do_handler_page_fault>:
    }	
}

void do_handler_page_fault(exception_frame_t * frame) {
   12a82:	55                   	push   %ebp
   12a83:	89 e5                	mov    %esp,%ebp
   12a85:	83 ec 08             	sub    $0x8,%esp
	log_printf("--------------------------------");
   12a88:	83 ec 0c             	sub    $0xc,%esp
   12a8b:	68 f0 5e 01 00       	push   $0x15ef0
   12a90:	e8 7d 2d 00 00       	call   15812 <log_printf>
   12a95:	83 c4 10             	add    $0x10,%esp
    log_printf("IRQ/Exception happend: Page fault.");
   12a98:	83 ec 0c             	sub    $0xc,%esp
   12a9b:	68 a0 60 01 00       	push   $0x160a0
   12aa0:	e8 6d 2d 00 00       	call   15812 <log_printf>
   12aa5:	83 c4 10             	add    $0x10,%esp
    if (frame->error_code & ERR_PAGE_P) {
   12aa8:	8b 45 08             	mov    0x8(%ebp),%eax
   12aab:	8b 40 34             	mov    0x34(%eax),%eax
   12aae:	83 e0 01             	and    $0x1,%eax
   12ab1:	85 c0                	test   %eax,%eax
   12ab3:	74 18                	je     12acd <do_handler_page_fault+0x4b>
        log_printf("\tpage-level protection violation: 0x%x.", read_cr2());
   12ab5:	e8 bc f8 ff ff       	call   12376 <read_cr2>
   12aba:	83 ec 08             	sub    $0x8,%esp
   12abd:	50                   	push   %eax
   12abe:	68 c4 60 01 00       	push   $0x160c4
   12ac3:	e8 4a 2d 00 00       	call   15812 <log_printf>
   12ac8:	83 c4 10             	add    $0x10,%esp
   12acb:	eb 16                	jmp    12ae3 <do_handler_page_fault+0x61>
    } else {
         log_printf("\tPage doesn't present 0x%x", read_cr2());
   12acd:	e8 a4 f8 ff ff       	call   12376 <read_cr2>
   12ad2:	83 ec 08             	sub    $0x8,%esp
   12ad5:	50                   	push   %eax
   12ad6:	68 ec 60 01 00       	push   $0x160ec
   12adb:	e8 32 2d 00 00       	call   15812 <log_printf>
   12ae0:	83 c4 10             	add    $0x10,%esp
   }
    
    if (frame->error_code & ERR_PAGE_WR) {
   12ae3:	8b 45 08             	mov    0x8(%ebp),%eax
   12ae6:	8b 40 34             	mov    0x34(%eax),%eax
   12ae9:	83 e0 02             	and    $0x2,%eax
   12aec:	85 c0                	test   %eax,%eax
   12aee:	74 12                	je     12b02 <do_handler_page_fault+0x80>
        log_printf("\tThe access causing the fault was a read.");
   12af0:	83 ec 0c             	sub    $0xc,%esp
   12af3:	68 08 61 01 00       	push   $0x16108
   12af8:	e8 15 2d 00 00       	call   15812 <log_printf>
   12afd:	83 c4 10             	add    $0x10,%esp
   12b00:	eb 10                	jmp    12b12 <do_handler_page_fault+0x90>
    } else {
        log_printf("\tThe access causing the fault was a write.");
   12b02:	83 ec 0c             	sub    $0xc,%esp
   12b05:	68 34 61 01 00       	push   $0x16134
   12b0a:	e8 03 2d 00 00       	call   15812 <log_printf>
   12b0f:	83 c4 10             	add    $0x10,%esp
    }
    
    if (frame->error_code & ERR_PAGE_US) {
   12b12:	8b 45 08             	mov    0x8(%ebp),%eax
   12b15:	8b 40 34             	mov    0x34(%eax),%eax
   12b18:	83 e0 02             	and    $0x2,%eax
   12b1b:	85 c0                	test   %eax,%eax
   12b1d:	74 12                	je     12b31 <do_handler_page_fault+0xaf>
        log_printf("\tA supervisor-mode access caused the fault.");
   12b1f:	83 ec 0c             	sub    $0xc,%esp
   12b22:	68 60 61 01 00       	push   $0x16160
   12b27:	e8 e6 2c 00 00       	call   15812 <log_printf>
   12b2c:	83 c4 10             	add    $0x10,%esp
   12b2f:	eb 10                	jmp    12b41 <do_handler_page_fault+0xbf>
    } else {
        log_printf("\tA user-mode access caused the fault.");
   12b31:	83 ec 0c             	sub    $0xc,%esp
   12b34:	68 8c 61 01 00       	push   $0x1618c
   12b39:	e8 d4 2c 00 00       	call   15812 <log_printf>
   12b3e:	83 c4 10             	add    $0x10,%esp
    }

    dump_core_regs(frame);
   12b41:	83 ec 0c             	sub    $0xc,%esp
   12b44:	ff 75 08             	pushl  0x8(%ebp)
   12b47:	e8 de fb ff ff       	call   1272a <dump_core_regs>
   12b4c:	83 c4 10             	add    $0x10,%esp
    while (1) {
        hlt();
   12b4f:	e8 00 f8 ff ff       	call   12354 <hlt>
   12b54:	eb f9                	jmp    12b4f <do_handler_page_fault+0xcd>

00012b56 <do_handler_fpu_error>:
    }
}

void do_handler_fpu_error(exception_frame_t * frame) {
   12b56:	55                   	push   %ebp
   12b57:	89 e5                	mov    %esp,%ebp
   12b59:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "X87 FPU Floating Point Error.");
   12b5c:	83 ec 08             	sub    $0x8,%esp
   12b5f:	68 b2 61 01 00       	push   $0x161b2
   12b64:	ff 75 08             	pushl  0x8(%ebp)
   12b67:	e8 b6 fc ff ff       	call   12822 <do_default_handler>
   12b6c:	83 c4 10             	add    $0x10,%esp
}
   12b6f:	90                   	nop
   12b70:	c9                   	leave  
   12b71:	c3                   	ret    

00012b72 <do_handler_alignment_check>:

void do_handler_alignment_check(exception_frame_t * frame) {
   12b72:	55                   	push   %ebp
   12b73:	89 e5                	mov    %esp,%ebp
   12b75:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Alignment Check.");
   12b78:	83 ec 08             	sub    $0x8,%esp
   12b7b:	68 d0 61 01 00       	push   $0x161d0
   12b80:	ff 75 08             	pushl  0x8(%ebp)
   12b83:	e8 9a fc ff ff       	call   12822 <do_default_handler>
   12b88:	83 c4 10             	add    $0x10,%esp
}
   12b8b:	90                   	nop
   12b8c:	c9                   	leave  
   12b8d:	c3                   	ret    

00012b8e <do_handler_machine_check>:

void do_handler_machine_check(exception_frame_t * frame) {
   12b8e:	55                   	push   %ebp
   12b8f:	89 e5                	mov    %esp,%ebp
   12b91:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Machine Check.");
   12b94:	83 ec 08             	sub    $0x8,%esp
   12b97:	68 e1 61 01 00       	push   $0x161e1
   12b9c:	ff 75 08             	pushl  0x8(%ebp)
   12b9f:	e8 7e fc ff ff       	call   12822 <do_default_handler>
   12ba4:	83 c4 10             	add    $0x10,%esp
}
   12ba7:	90                   	nop
   12ba8:	c9                   	leave  
   12ba9:	c3                   	ret    

00012baa <do_handler_smd_exception>:

void do_handler_smd_exception(exception_frame_t * frame) {
   12baa:	55                   	push   %ebp
   12bab:	89 e5                	mov    %esp,%ebp
   12bad:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "SIMD Floating Point Exception.");
   12bb0:	83 ec 08             	sub    $0x8,%esp
   12bb3:	68 f0 61 01 00       	push   $0x161f0
   12bb8:	ff 75 08             	pushl  0x8(%ebp)
   12bbb:	e8 62 fc ff ff       	call   12822 <do_default_handler>
   12bc0:	83 c4 10             	add    $0x10,%esp
}
   12bc3:	90                   	nop
   12bc4:	c9                   	leave  
   12bc5:	c3                   	ret    

00012bc6 <do_handler_virtual_exception>:

void do_handler_virtual_exception(exception_frame_t * frame) {
   12bc6:	55                   	push   %ebp
   12bc7:	89 e5                	mov    %esp,%ebp
   12bc9:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Virtualization Exception.");
   12bcc:	83 ec 08             	sub    $0x8,%esp
   12bcf:	68 0f 62 01 00       	push   $0x1620f
   12bd4:	ff 75 08             	pushl  0x8(%ebp)
   12bd7:	e8 46 fc ff ff       	call   12822 <do_default_handler>
   12bdc:	83 c4 10             	add    $0x10,%esp
}
   12bdf:	90                   	nop
   12be0:	c9                   	leave  
   12be1:	c3                   	ret    

00012be2 <pic_send_eoi>:

void pic_send_eoi(int irq_num){
   12be2:	55                   	push   %ebp
   12be3:	89 e5                	mov    %esp,%ebp
	irq_num-=IRQ_PIC_START;
   12be5:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
	if(irq_num >=8){
   12be9:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   12bed:	7e 0f                	jle    12bfe <pic_send_eoi+0x1c>
		outb(PIC1_OCW2,PIC_OCW2_EOI);
   12bef:	6a 20                	push   $0x20
   12bf1:	68 a0 00 00 00       	push   $0xa0
   12bf6:	e8 12 f7 ff ff       	call   1230d <outb>
   12bfb:	83 c4 08             	add    $0x8,%esp
	}
	outb(PIC0_OCW2,PIC_OCW2_EOI);
   12bfe:	6a 20                	push   $0x20
   12c00:	6a 20                	push   $0x20
   12c02:	e8 06 f7 ff ff       	call   1230d <outb>
   12c07:	83 c4 08             	add    $0x8,%esp
}
   12c0a:	90                   	nop
   12c0b:	c9                   	leave  
   12c0c:	c3                   	ret    

00012c0d <irq_enter_protection>:

/**
 * @brief 进入临界区
 * @return 进入临界区时的状态
 */
irq_state_t irq_enter_protection(void){
   12c0d:	55                   	push   %ebp
   12c0e:	89 e5                	mov    %esp,%ebp
   12c10:	83 ec 10             	sub    $0x10,%esp
	irq_state_t state=read_eflags();
   12c13:	e8 43 f7 ff ff       	call   1235b <read_eflags>
   12c18:	89 45 fc             	mov    %eax,-0x4(%ebp)
	irq_disable_global();
   12c1b:	e8 fa f7 ff ff       	call   1241a <irq_disable_global>
	return state;
   12c20:	8b 45 fc             	mov    -0x4(%ebp),%eax
	
}
   12c23:	c9                   	leave  
   12c24:	c3                   	ret    

00012c25 <irq_leave_protection>:

/**
 * @brief 退出临界区
 * @param state 进入临界区时的状态
 */
void irq_leave_protection(irq_state_t state){
   12c25:	55                   	push   %ebp
   12c26:	89 e5                	mov    %esp,%ebp
	write_eflags(state);
   12c28:	ff 75 08             	pushl  0x8(%ebp)
   12c2b:	e8 3b f7 ff ff       	call   1236b <write_eflags>
   12c30:	83 c4 04             	add    $0x4,%esp
}
   12c33:	90                   	nop
   12c34:	c9                   	leave  
   12c35:	c3                   	ret    

00012c36 <inb>:
static inline uint8_t inb(uint16_t port){
   12c36:	55                   	push   %ebp
   12c37:	89 e5                	mov    %esp,%ebp
   12c39:	83 ec 14             	sub    $0x14,%esp
   12c3c:	8b 45 08             	mov    0x8(%ebp),%eax
   12c3f:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__(
   12c43:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   12c47:	89 c2                	mov    %eax,%edx
   12c49:	ec                   	in     (%dx),%al
   12c4a:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   12c4d:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   12c51:	c9                   	leave  
   12c52:	c3                   	ret    

00012c53 <outb>:
static inline void outb(uint16_t port,uint8_t data){
   12c53:	55                   	push   %ebp
   12c54:	89 e5                	mov    %esp,%ebp
   12c56:	83 ec 08             	sub    $0x8,%esp
   12c59:	8b 55 08             	mov    0x8(%ebp),%edx
   12c5c:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c5f:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   12c63:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile(
   12c66:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   12c6a:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   12c6e:	ee                   	out    %al,(%dx)
}
   12c6f:	90                   	nop
   12c70:	c9                   	leave  
   12c71:	c3                   	ret    

00012c72 <read_cursor_pos>:

/**
 * @brief 读取光标位置
 * @return 光标位置
*/
static int read_cursor_pos(void){
   12c72:	55                   	push   %ebp
   12c73:	89 e5                	mov    %esp,%ebp
   12c75:	83 ec 18             	sub    $0x18,%esp
    int pos;

    irq_state_t state=irq_enter_protection();
   12c78:	e8 90 ff ff ff       	call   12c0d <irq_enter_protection>
   12c7d:	89 45 f4             	mov    %eax,-0xc(%ebp)

    outb(0x3D4,0xF);
   12c80:	83 ec 08             	sub    $0x8,%esp
   12c83:	6a 0f                	push   $0xf
   12c85:	68 d4 03 00 00       	push   $0x3d4
   12c8a:	e8 c4 ff ff ff       	call   12c53 <outb>
   12c8f:	83 c4 10             	add    $0x10,%esp
    pos=inb(0x3d5);
   12c92:	83 ec 0c             	sub    $0xc,%esp
   12c95:	68 d5 03 00 00       	push   $0x3d5
   12c9a:	e8 97 ff ff ff       	call   12c36 <inb>
   12c9f:	83 c4 10             	add    $0x10,%esp
   12ca2:	0f b6 c0             	movzbl %al,%eax
   12ca5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    outb(0x3D4,0xE);
   12ca8:	83 ec 08             	sub    $0x8,%esp
   12cab:	6a 0e                	push   $0xe
   12cad:	68 d4 03 00 00       	push   $0x3d4
   12cb2:	e8 9c ff ff ff       	call   12c53 <outb>
   12cb7:	83 c4 10             	add    $0x10,%esp
    pos |= inb(0x3d5) << 8;
   12cba:	83 ec 0c             	sub    $0xc,%esp
   12cbd:	68 d5 03 00 00       	push   $0x3d5
   12cc2:	e8 6f ff ff ff       	call   12c36 <inb>
   12cc7:	83 c4 10             	add    $0x10,%esp
   12cca:	0f b6 c0             	movzbl %al,%eax
   12ccd:	c1 e0 08             	shl    $0x8,%eax
   12cd0:	09 45 f0             	or     %eax,-0x10(%ebp)

    irq_leave_protection(state);
   12cd3:	83 ec 0c             	sub    $0xc,%esp
   12cd6:	ff 75 f4             	pushl  -0xc(%ebp)
   12cd9:	e8 47 ff ff ff       	call   12c25 <irq_leave_protection>
   12cde:	83 c4 10             	add    $0x10,%esp
    return pos;
   12ce1:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   12ce4:	c9                   	leave  
   12ce5:	c3                   	ret    

00012ce6 <update_cursor_pos>:

/**
 * @brief 更新光标位置
 * @param console 要更新光标的console
*/
static int update_cursor_pos(console_t* console){
   12ce6:	55                   	push   %ebp
   12ce7:	89 e5                	mov    %esp,%ebp
   12ce9:	83 ec 18             	sub    $0x18,%esp
    int pos = (console - console_buf)*console->display_cols*console->display_rows;
   12cec:	8b 45 08             	mov    0x8(%ebp),%eax
   12cef:	ba 00 24 03 00       	mov    $0x32400,%edx
   12cf4:	29 d0                	sub    %edx,%eax
   12cf6:	c1 f8 02             	sar    $0x2,%eax
   12cf9:	69 c0 3d cf f3 3c    	imul   $0x3cf3cf3d,%eax,%eax
   12cff:	89 c2                	mov    %eax,%edx
   12d01:	8b 45 08             	mov    0x8(%ebp),%eax
   12d04:	8b 40 14             	mov    0x14(%eax),%eax
   12d07:	0f af d0             	imul   %eax,%edx
   12d0a:	8b 45 08             	mov    0x8(%ebp),%eax
   12d0d:	8b 40 10             	mov    0x10(%eax),%eax
   12d10:	0f af c2             	imul   %edx,%eax
   12d13:	89 45 f4             	mov    %eax,-0xc(%ebp)
    pos += console->cursor_row * console->display_cols + console->cursor_col;
   12d16:	8b 45 08             	mov    0x8(%ebp),%eax
   12d19:	8b 50 08             	mov    0x8(%eax),%edx
   12d1c:	8b 45 08             	mov    0x8(%ebp),%eax
   12d1f:	8b 40 14             	mov    0x14(%eax),%eax
   12d22:	0f af d0             	imul   %eax,%edx
   12d25:	8b 45 08             	mov    0x8(%ebp),%eax
   12d28:	8b 40 0c             	mov    0xc(%eax),%eax
   12d2b:	01 d0                	add    %edx,%eax
   12d2d:	01 45 f4             	add    %eax,-0xc(%ebp)

    irq_state_t state=irq_enter_protection();
   12d30:	e8 d8 fe ff ff       	call   12c0d <irq_enter_protection>
   12d35:	89 45 f0             	mov    %eax,-0x10(%ebp)

    // 获取低八位和高八位
    outb(0x3D4,0xF);
   12d38:	83 ec 08             	sub    $0x8,%esp
   12d3b:	6a 0f                	push   $0xf
   12d3d:	68 d4 03 00 00       	push   $0x3d4
   12d42:	e8 0c ff ff ff       	call   12c53 <outb>
   12d47:	83 c4 10             	add    $0x10,%esp
    outb(0x3D5,(uint8_t)(pos & 0xFF));
   12d4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12d4d:	0f b6 c0             	movzbl %al,%eax
   12d50:	83 ec 08             	sub    $0x8,%esp
   12d53:	50                   	push   %eax
   12d54:	68 d5 03 00 00       	push   $0x3d5
   12d59:	e8 f5 fe ff ff       	call   12c53 <outb>
   12d5e:	83 c4 10             	add    $0x10,%esp
    outb(0x3D4,0xE);
   12d61:	83 ec 08             	sub    $0x8,%esp
   12d64:	6a 0e                	push   $0xe
   12d66:	68 d4 03 00 00       	push   $0x3d4
   12d6b:	e8 e3 fe ff ff       	call   12c53 <outb>
   12d70:	83 c4 10             	add    $0x10,%esp
    outb(0x3D5,(uint8_t)((pos >> 8) & 0xFF));
   12d73:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12d76:	c1 f8 08             	sar    $0x8,%eax
   12d79:	0f b6 c0             	movzbl %al,%eax
   12d7c:	83 ec 08             	sub    $0x8,%esp
   12d7f:	50                   	push   %eax
   12d80:	68 d5 03 00 00       	push   $0x3d5
   12d85:	e8 c9 fe ff ff       	call   12c53 <outb>
   12d8a:	83 c4 10             	add    $0x10,%esp

    irq_leave_protection(state);
   12d8d:	83 ec 0c             	sub    $0xc,%esp
   12d90:	ff 75 f0             	pushl  -0x10(%ebp)
   12d93:	e8 8d fe ff ff       	call   12c25 <irq_leave_protection>
   12d98:	83 c4 10             	add    $0x10,%esp

    return pos;
   12d9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   12d9e:	c9                   	leave  
   12d9f:	c3                   	ret    

00012da0 <erase_rows>:

static void erase_rows(console_t*console,int start,int end){
   12da0:	55                   	push   %ebp
   12da1:	89 e5                	mov    %esp,%ebp
   12da3:	83 ec 10             	sub    $0x10,%esp
    disp_char_t* disp_start=console->disp_base+console->display_cols*start;
   12da6:	8b 45 08             	mov    0x8(%ebp),%eax
   12da9:	8b 50 04             	mov    0x4(%eax),%edx
   12dac:	8b 45 08             	mov    0x8(%ebp),%eax
   12daf:	8b 40 14             	mov    0x14(%eax),%eax
   12db2:	0f af 45 0c          	imul   0xc(%ebp),%eax
   12db6:	01 c0                	add    %eax,%eax
   12db8:	01 d0                	add    %edx,%eax
   12dba:	89 45 fc             	mov    %eax,-0x4(%ebp)
    disp_char_t* disp_end=console->disp_base+console->display_cols*(end+1);
   12dbd:	8b 45 08             	mov    0x8(%ebp),%eax
   12dc0:	8b 50 04             	mov    0x4(%eax),%edx
   12dc3:	8b 45 08             	mov    0x8(%ebp),%eax
   12dc6:	8b 40 14             	mov    0x14(%eax),%eax
   12dc9:	8b 4d 10             	mov    0x10(%ebp),%ecx
   12dcc:	83 c1 01             	add    $0x1,%ecx
   12dcf:	0f af c1             	imul   %ecx,%eax
   12dd2:	01 c0                	add    %eax,%eax
   12dd4:	01 d0                	add    %edx,%eax
   12dd6:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while(disp_start < disp_end){
   12dd9:	eb 4d                	jmp    12e28 <erase_rows+0x88>
        disp_start->c=' ';
   12ddb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12dde:	c6 00 20             	movb   $0x20,(%eax)
        disp_start->foreground=console->foreground;
   12de1:	8b 45 08             	mov    0x8(%ebp),%eax
   12de4:	8b 40 18             	mov    0x18(%eax),%eax
   12de7:	c1 e0 04             	shl    $0x4,%eax
   12dea:	c0 f8 04             	sar    $0x4,%al
   12ded:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12df0:	83 e0 0f             	and    $0xf,%eax
   12df3:	89 c1                	mov    %eax,%ecx
   12df5:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   12df9:	83 e0 f0             	and    $0xfffffff0,%eax
   12dfc:	09 c8                	or     %ecx,%eax
   12dfe:	88 42 01             	mov    %al,0x1(%edx)
        disp_start->background=console->background;
   12e01:	8b 45 08             	mov    0x8(%ebp),%eax
   12e04:	8b 40 1c             	mov    0x1c(%eax),%eax
   12e07:	c1 e0 05             	shl    $0x5,%eax
   12e0a:	c0 f8 05             	sar    $0x5,%al
   12e0d:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12e10:	83 e0 07             	and    $0x7,%eax
   12e13:	c1 e0 04             	shl    $0x4,%eax
   12e16:	89 c1                	mov    %eax,%ecx
   12e18:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   12e1c:	83 e0 8f             	and    $0xffffff8f,%eax
   12e1f:	09 c8                	or     %ecx,%eax
   12e21:	88 42 01             	mov    %al,0x1(%edx)

        disp_start++;
   12e24:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
    while(disp_start < disp_end){
   12e28:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12e2b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   12e2e:	72 ab                	jb     12ddb <erase_rows+0x3b>
    }
}
   12e30:	90                   	nop
   12e31:	c9                   	leave  
   12e32:	c3                   	ret    

00012e33 <scroll_up>:

static void scroll_up(console_t* console,int lines){
   12e33:	55                   	push   %ebp
   12e34:	89 e5                	mov    %esp,%ebp
   12e36:	83 ec 18             	sub    $0x18,%esp
    disp_char_t* dest=console->disp_base;
   12e39:	8b 45 08             	mov    0x8(%ebp),%eax
   12e3c:	8b 40 04             	mov    0x4(%eax),%eax
   12e3f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    disp_char_t* src=console->disp_base+console->display_cols*lines;
   12e42:	8b 45 08             	mov    0x8(%ebp),%eax
   12e45:	8b 50 04             	mov    0x4(%eax),%edx
   12e48:	8b 45 08             	mov    0x8(%ebp),%eax
   12e4b:	8b 40 14             	mov    0x14(%eax),%eax
   12e4e:	0f af 45 0c          	imul   0xc(%ebp),%eax
   12e52:	01 c0                	add    %eax,%eax
   12e54:	01 d0                	add    %edx,%eax
   12e56:	89 45 f0             	mov    %eax,-0x10(%ebp)

    uint32_t size=(console->display_rows-lines)*console->display_cols*sizeof(disp_char_t);
   12e59:	8b 45 08             	mov    0x8(%ebp),%eax
   12e5c:	8b 40 10             	mov    0x10(%eax),%eax
   12e5f:	2b 45 0c             	sub    0xc(%ebp),%eax
   12e62:	89 c2                	mov    %eax,%edx
   12e64:	8b 45 08             	mov    0x8(%ebp),%eax
   12e67:	8b 40 14             	mov    0x14(%eax),%eax
   12e6a:	0f af c2             	imul   %edx,%eax
   12e6d:	01 c0                	add    %eax,%eax
   12e6f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    kernel_memcpy(dest,src,size);
   12e72:	83 ec 04             	sub    $0x4,%esp
   12e75:	ff 75 ec             	pushl  -0x14(%ebp)
   12e78:	ff 75 f0             	pushl  -0x10(%ebp)
   12e7b:	ff 75 f4             	pushl  -0xc(%ebp)
   12e7e:	e8 1d 23 00 00       	call   151a0 <kernel_memcpy>
   12e83:	83 c4 10             	add    $0x10,%esp

    erase_rows(console,console->display_rows-lines,console->display_rows-1);
   12e86:	8b 45 08             	mov    0x8(%ebp),%eax
   12e89:	8b 40 10             	mov    0x10(%eax),%eax
   12e8c:	8d 50 ff             	lea    -0x1(%eax),%edx
   12e8f:	8b 45 08             	mov    0x8(%ebp),%eax
   12e92:	8b 40 10             	mov    0x10(%eax),%eax
   12e95:	2b 45 0c             	sub    0xc(%ebp),%eax
   12e98:	83 ec 04             	sub    $0x4,%esp
   12e9b:	52                   	push   %edx
   12e9c:	50                   	push   %eax
   12e9d:	ff 75 08             	pushl  0x8(%ebp)
   12ea0:	e8 fb fe ff ff       	call   12da0 <erase_rows>
   12ea5:	83 c4 10             	add    $0x10,%esp
    console->cursor_row-=lines;
   12ea8:	8b 45 08             	mov    0x8(%ebp),%eax
   12eab:	8b 40 08             	mov    0x8(%eax),%eax
   12eae:	2b 45 0c             	sub    0xc(%ebp),%eax
   12eb1:	89 c2                	mov    %eax,%edx
   12eb3:	8b 45 08             	mov    0x8(%ebp),%eax
   12eb6:	89 50 08             	mov    %edx,0x8(%eax)
}
   12eb9:	90                   	nop
   12eba:	c9                   	leave  
   12ebb:	c3                   	ret    

00012ebc <clear_display>:

static void clear_display(console_t*console){
   12ebc:	55                   	push   %ebp
   12ebd:	89 e5                	mov    %esp,%ebp
   12ebf:	83 ec 10             	sub    $0x10,%esp
    int size=console->display_cols*console->display_rows;
   12ec2:	8b 45 08             	mov    0x8(%ebp),%eax
   12ec5:	8b 50 14             	mov    0x14(%eax),%edx
   12ec8:	8b 45 08             	mov    0x8(%ebp),%eax
   12ecb:	8b 40 10             	mov    0x10(%eax),%eax
   12ece:	0f af c2             	imul   %edx,%eax
   12ed1:	89 45 f4             	mov    %eax,-0xc(%ebp)

    disp_char_t* start=console->disp_base;
   12ed4:	8b 45 08             	mov    0x8(%ebp),%eax
   12ed7:	8b 40 04             	mov    0x4(%eax),%eax
   12eda:	89 45 fc             	mov    %eax,-0x4(%ebp)
    for(int i=0;i<size;i++,start++){
   12edd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   12ee4:	eb 51                	jmp    12f37 <clear_display+0x7b>
        start->c=' ';
   12ee6:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12ee9:	c6 00 20             	movb   $0x20,(%eax)
        start->foreground=console->foreground;
   12eec:	8b 45 08             	mov    0x8(%ebp),%eax
   12eef:	8b 40 18             	mov    0x18(%eax),%eax
   12ef2:	c1 e0 04             	shl    $0x4,%eax
   12ef5:	c0 f8 04             	sar    $0x4,%al
   12ef8:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12efb:	83 e0 0f             	and    $0xf,%eax
   12efe:	89 c1                	mov    %eax,%ecx
   12f00:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   12f04:	83 e0 f0             	and    $0xfffffff0,%eax
   12f07:	09 c8                	or     %ecx,%eax
   12f09:	88 42 01             	mov    %al,0x1(%edx)
        start->background=console->background; 
   12f0c:	8b 45 08             	mov    0x8(%ebp),%eax
   12f0f:	8b 40 1c             	mov    0x1c(%eax),%eax
   12f12:	c1 e0 05             	shl    $0x5,%eax
   12f15:	c0 f8 05             	sar    $0x5,%al
   12f18:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12f1b:	83 e0 07             	and    $0x7,%eax
   12f1e:	c1 e0 04             	shl    $0x4,%eax
   12f21:	89 c1                	mov    %eax,%ecx
   12f23:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   12f27:	83 e0 8f             	and    $0xffffff8f,%eax
   12f2a:	09 c8                	or     %ecx,%eax
   12f2c:	88 42 01             	mov    %al,0x1(%edx)
    for(int i=0;i<size;i++,start++){
   12f2f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   12f33:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
   12f37:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12f3a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   12f3d:	7c a7                	jl     12ee6 <clear_display+0x2a>
    }
}
   12f3f:	90                   	nop
   12f40:	c9                   	leave  
   12f41:	c3                   	ret    

00012f42 <move_to_col0>:

static void move_to_col0(console_t* console){
   12f42:	55                   	push   %ebp
   12f43:	89 e5                	mov    %esp,%ebp
    console->cursor_col=0;
   12f45:	8b 45 08             	mov    0x8(%ebp),%eax
   12f48:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
   12f4f:	90                   	nop
   12f50:	5d                   	pop    %ebp
   12f51:	c3                   	ret    

00012f52 <move_next_line>:

static void move_next_line(console_t*console){
   12f52:	55                   	push   %ebp
   12f53:	89 e5                	mov    %esp,%ebp
   12f55:	83 ec 08             	sub    $0x8,%esp
    console->cursor_row++;
   12f58:	8b 45 08             	mov    0x8(%ebp),%eax
   12f5b:	8b 40 08             	mov    0x8(%eax),%eax
   12f5e:	8d 50 01             	lea    0x1(%eax),%edx
   12f61:	8b 45 08             	mov    0x8(%ebp),%eax
   12f64:	89 50 08             	mov    %edx,0x8(%eax)
    if(console->cursor_row >= console->display_rows){
   12f67:	8b 45 08             	mov    0x8(%ebp),%eax
   12f6a:	8b 50 08             	mov    0x8(%eax),%edx
   12f6d:	8b 45 08             	mov    0x8(%ebp),%eax
   12f70:	8b 40 10             	mov    0x10(%eax),%eax
   12f73:	39 c2                	cmp    %eax,%edx
   12f75:	7c 10                	jl     12f87 <move_next_line+0x35>
        scroll_up(console,1);
   12f77:	83 ec 08             	sub    $0x8,%esp
   12f7a:	6a 01                	push   $0x1
   12f7c:	ff 75 08             	pushl  0x8(%ebp)
   12f7f:	e8 af fe ff ff       	call   12e33 <scroll_up>
   12f84:	83 c4 10             	add    $0x10,%esp
    }
}
   12f87:	90                   	nop
   12f88:	c9                   	leave  
   12f89:	c3                   	ret    

00012f8a <move_forward>:

static void move_forward(console_t* console,int n){
   12f8a:	55                   	push   %ebp
   12f8b:	89 e5                	mov    %esp,%ebp
   12f8d:	83 ec 18             	sub    $0x18,%esp
    for(int i=0;i<n;i++){
   12f90:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12f97:	eb 5c                	jmp    12ff5 <move_forward+0x6b>
        if(++console->cursor_col >= console->display_cols){
   12f99:	8b 45 08             	mov    0x8(%ebp),%eax
   12f9c:	8b 40 0c             	mov    0xc(%eax),%eax
   12f9f:	8d 50 01             	lea    0x1(%eax),%edx
   12fa2:	8b 45 08             	mov    0x8(%ebp),%eax
   12fa5:	89 50 0c             	mov    %edx,0xc(%eax)
   12fa8:	8b 45 08             	mov    0x8(%ebp),%eax
   12fab:	8b 50 0c             	mov    0xc(%eax),%edx
   12fae:	8b 45 08             	mov    0x8(%ebp),%eax
   12fb1:	8b 40 14             	mov    0x14(%eax),%eax
   12fb4:	39 c2                	cmp    %eax,%edx
   12fb6:	7c 39                	jl     12ff1 <move_forward+0x67>
            console->cursor_row++;
   12fb8:	8b 45 08             	mov    0x8(%ebp),%eax
   12fbb:	8b 40 08             	mov    0x8(%eax),%eax
   12fbe:	8d 50 01             	lea    0x1(%eax),%edx
   12fc1:	8b 45 08             	mov    0x8(%ebp),%eax
   12fc4:	89 50 08             	mov    %edx,0x8(%eax)
            console->cursor_col=0;
   12fc7:	8b 45 08             	mov    0x8(%ebp),%eax
   12fca:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
            
            if(console->cursor_row >= console->display_rows){
   12fd1:	8b 45 08             	mov    0x8(%ebp),%eax
   12fd4:	8b 50 08             	mov    0x8(%eax),%edx
   12fd7:	8b 45 08             	mov    0x8(%ebp),%eax
   12fda:	8b 40 10             	mov    0x10(%eax),%eax
   12fdd:	39 c2                	cmp    %eax,%edx
   12fdf:	7c 10                	jl     12ff1 <move_forward+0x67>
                scroll_up(console,1);
   12fe1:	83 ec 08             	sub    $0x8,%esp
   12fe4:	6a 01                	push   $0x1
   12fe6:	ff 75 08             	pushl  0x8(%ebp)
   12fe9:	e8 45 fe ff ff       	call   12e33 <scroll_up>
   12fee:	83 c4 10             	add    $0x10,%esp
    for(int i=0;i<n;i++){
   12ff1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12ff5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12ff8:	3b 45 0c             	cmp    0xc(%ebp),%eax
   12ffb:	7c 9c                	jl     12f99 <move_forward+0xf>
            }
        }
    }
}
   12ffd:	90                   	nop
   12ffe:	c9                   	leave  
   12fff:	c3                   	ret    

00013000 <move_backword>:

static int move_backword(console_t* console,int n){
   13000:	55                   	push   %ebp
   13001:	89 e5                	mov    %esp,%ebp
   13003:	83 ec 10             	sub    $0x10,%esp
    int status=-1;
   13006:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
    for(int i=0;i<n;i++){
   1300d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   13014:	eb 55                	jmp    1306b <move_backword+0x6b>
        if(console->cursor_col > 0){
   13016:	8b 45 08             	mov    0x8(%ebp),%eax
   13019:	8b 40 0c             	mov    0xc(%eax),%eax
   1301c:	85 c0                	test   %eax,%eax
   1301e:	7e 18                	jle    13038 <move_backword+0x38>
            console->cursor_col--;
   13020:	8b 45 08             	mov    0x8(%ebp),%eax
   13023:	8b 40 0c             	mov    0xc(%eax),%eax
   13026:	8d 50 ff             	lea    -0x1(%eax),%edx
   13029:	8b 45 08             	mov    0x8(%ebp),%eax
   1302c:	89 50 0c             	mov    %edx,0xc(%eax)
            status=0;
   1302f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   13036:	eb 2f                	jmp    13067 <move_backword+0x67>
        }
        else if(console->cursor_row > 0){
   13038:	8b 45 08             	mov    0x8(%ebp),%eax
   1303b:	8b 40 08             	mov    0x8(%eax),%eax
   1303e:	85 c0                	test   %eax,%eax
   13040:	7e 25                	jle    13067 <move_backword+0x67>
            console->cursor_row--;
   13042:	8b 45 08             	mov    0x8(%ebp),%eax
   13045:	8b 40 08             	mov    0x8(%eax),%eax
   13048:	8d 50 ff             	lea    -0x1(%eax),%edx
   1304b:	8b 45 08             	mov    0x8(%ebp),%eax
   1304e:	89 50 08             	mov    %edx,0x8(%eax)
            console->cursor_col=console->display_cols-1;
   13051:	8b 45 08             	mov    0x8(%ebp),%eax
   13054:	8b 40 14             	mov    0x14(%eax),%eax
   13057:	8d 50 ff             	lea    -0x1(%eax),%edx
   1305a:	8b 45 08             	mov    0x8(%ebp),%eax
   1305d:	89 50 0c             	mov    %edx,0xc(%eax)
            status=0;
   13060:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    for(int i=0;i<n;i++){
   13067:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   1306b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1306e:	3b 45 0c             	cmp    0xc(%ebp),%eax
   13071:	7c a3                	jl     13016 <move_backword+0x16>
        }

    }
    
    return status;
   13073:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   13076:	c9                   	leave  
   13077:	c3                   	ret    

00013078 <console_init>:


int console_init(int idx){
   13078:	55                   	push   %ebp
   13079:	89 e5                	mov    %esp,%ebp
   1307b:	83 ec 18             	sub    $0x18,%esp

    console_t* console=console_buf+idx;
   1307e:	8b 45 08             	mov    0x8(%ebp),%eax
   13081:	6b c0 54             	imul   $0x54,%eax,%eax
   13084:	05 00 24 03 00       	add    $0x32400,%eax
   13089:	89 45 f4             	mov    %eax,-0xc(%ebp)

    console->display_cols=CONSOLE_COL_MAX;
   1308c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1308f:	c7 40 14 50 00 00 00 	movl   $0x50,0x14(%eax)
    console->display_rows=CONSOLE_ROW_MAX;
   13096:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13099:	c7 40 10 19 00 00 00 	movl   $0x19,0x10(%eax)
    console->disp_base=(disp_char_t*)CONSOLE_DISP_ADDR+idx*(CONSOLE_COL_MAX*CONSOLE_ROW_MAX);
   130a0:	8b 45 08             	mov    0x8(%ebp),%eax
   130a3:	69 c0 a0 0f 00 00    	imul   $0xfa0,%eax,%eax
   130a9:	8d 90 00 80 0b 00    	lea    0xb8000(%eax),%edx
   130af:	8b 45 f4             	mov    -0xc(%ebp),%eax
   130b2:	89 50 04             	mov    %edx,0x4(%eax)

    console->foreground=WHITE;
   130b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   130b8:	c7 40 18 0f 00 00 00 	movl   $0xf,0x18(%eax)
    console->background=BLACK;
   130bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   130c2:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)

    if(idx==0){
   130c9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   130cd:	75 30                	jne    130ff <console_init+0x87>
        int cursor_pos=read_cursor_pos();
   130cf:	e8 9e fb ff ff       	call   12c72 <read_cursor_pos>
   130d4:	89 45 f0             	mov    %eax,-0x10(%ebp)
        console->cursor_row=cursor_pos / console->display_cols;        
   130d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   130da:	8b 48 14             	mov    0x14(%eax),%ecx
   130dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   130e0:	99                   	cltd   
   130e1:	f7 f9                	idiv   %ecx
   130e3:	89 c2                	mov    %eax,%edx
   130e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   130e8:	89 50 08             	mov    %edx,0x8(%eax)
        console->cursor_col=cursor_pos % console->display_cols;
   130eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   130ee:	8b 48 14             	mov    0x14(%eax),%ecx
   130f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   130f4:	99                   	cltd   
   130f5:	f7 f9                	idiv   %ecx
   130f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   130fa:	89 50 0c             	mov    %edx,0xc(%eax)
   130fd:	eb 22                	jmp    13121 <console_init+0xa9>
    }
    else{
        console->cursor_row=0;
   130ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13102:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        console->cursor_col=0;
   13109:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1310c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
        clear_display(console);
   13113:	83 ec 0c             	sub    $0xc,%esp
   13116:	ff 75 f4             	pushl  -0xc(%ebp)
   13119:	e8 9e fd ff ff       	call   12ebc <clear_display>
   1311e:	83 c4 10             	add    $0x10,%esp
    }

    console->old_cursor_col=console->cursor_col;
   13121:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13124:	8b 50 0c             	mov    0xc(%eax),%edx
   13127:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1312a:	89 50 20             	mov    %edx,0x20(%eax)
    console->old_cursor_row=console->cursor_row;
   1312d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13130:	8b 50 08             	mov    0x8(%eax),%edx
   13133:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13136:	89 50 24             	mov    %edx,0x24(%eax)

    console->write_state=CONSOLE_WRITE_NORMAL; 
   13139:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1313c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    return 0;
   13142:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13147:	c9                   	leave  
   13148:	c3                   	ret    

00013149 <show_char>:

static void show_char(console_t* console,char c){
   13149:	55                   	push   %ebp
   1314a:	89 e5                	mov    %esp,%ebp
   1314c:	83 ec 28             	sub    $0x28,%esp
   1314f:	8b 45 0c             	mov    0xc(%ebp),%eax
   13152:	88 45 e4             	mov    %al,-0x1c(%ebp)
    int offset=console->cursor_col+console->cursor_row*console->display_cols;
   13155:	8b 45 08             	mov    0x8(%ebp),%eax
   13158:	8b 50 0c             	mov    0xc(%eax),%edx
   1315b:	8b 45 08             	mov    0x8(%ebp),%eax
   1315e:	8b 48 08             	mov    0x8(%eax),%ecx
   13161:	8b 45 08             	mov    0x8(%ebp),%eax
   13164:	8b 40 14             	mov    0x14(%eax),%eax
   13167:	0f af c1             	imul   %ecx,%eax
   1316a:	01 d0                	add    %edx,%eax
   1316c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    disp_char_t* p=console->disp_base+offset;
   1316f:	8b 45 08             	mov    0x8(%ebp),%eax
   13172:	8b 40 04             	mov    0x4(%eax),%eax
   13175:	8b 55 f4             	mov    -0xc(%ebp),%edx
   13178:	01 d2                	add    %edx,%edx
   1317a:	01 d0                	add    %edx,%eax
   1317c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    p->c=c;
   1317f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13182:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
   13186:	88 10                	mov    %dl,(%eax)
    p->foreground=console->foreground;
   13188:	8b 45 08             	mov    0x8(%ebp),%eax
   1318b:	8b 40 18             	mov    0x18(%eax),%eax
   1318e:	c1 e0 04             	shl    $0x4,%eax
   13191:	c0 f8 04             	sar    $0x4,%al
   13194:	8b 55 f0             	mov    -0x10(%ebp),%edx
   13197:	83 e0 0f             	and    $0xf,%eax
   1319a:	89 c1                	mov    %eax,%ecx
   1319c:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   131a0:	83 e0 f0             	and    $0xfffffff0,%eax
   131a3:	09 c8                	or     %ecx,%eax
   131a5:	88 42 01             	mov    %al,0x1(%edx)
    p->background=console->background;
   131a8:	8b 45 08             	mov    0x8(%ebp),%eax
   131ab:	8b 40 1c             	mov    0x1c(%eax),%eax
   131ae:	c1 e0 05             	shl    $0x5,%eax
   131b1:	c0 f8 05             	sar    $0x5,%al
   131b4:	8b 55 f0             	mov    -0x10(%ebp),%edx
   131b7:	83 e0 07             	and    $0x7,%eax
   131ba:	c1 e0 04             	shl    $0x4,%eax
   131bd:	89 c1                	mov    %eax,%ecx
   131bf:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   131c3:	83 e0 8f             	and    $0xffffff8f,%eax
   131c6:	09 c8                	or     %ecx,%eax
   131c8:	88 42 01             	mov    %al,0x1(%edx)
    move_forward(console,1);
   131cb:	83 ec 08             	sub    $0x8,%esp
   131ce:	6a 01                	push   $0x1
   131d0:	ff 75 08             	pushl  0x8(%ebp)
   131d3:	e8 b2 fd ff ff       	call   12f8a <move_forward>
   131d8:	83 c4 10             	add    $0x10,%esp
}
   131db:	90                   	nop
   131dc:	c9                   	leave  
   131dd:	c3                   	ret    

000131de <erase_backword>:

static void erase_backword(console_t*console){
   131de:	55                   	push   %ebp
   131df:	89 e5                	mov    %esp,%ebp
   131e1:	83 ec 08             	sub    $0x8,%esp
    if(move_backword(console,1)==0){
   131e4:	6a 01                	push   $0x1
   131e6:	ff 75 08             	pushl  0x8(%ebp)
   131e9:	e8 12 fe ff ff       	call   13000 <move_backword>
   131ee:	83 c4 08             	add    $0x8,%esp
   131f1:	85 c0                	test   %eax,%eax
   131f3:	75 20                	jne    13215 <erase_backword+0x37>
        show_char(console,' ');
   131f5:	83 ec 08             	sub    $0x8,%esp
   131f8:	6a 20                	push   $0x20
   131fa:	ff 75 08             	pushl  0x8(%ebp)
   131fd:	e8 47 ff ff ff       	call   13149 <show_char>
   13202:	83 c4 10             	add    $0x10,%esp
        move_backword(console,1);
   13205:	83 ec 08             	sub    $0x8,%esp
   13208:	6a 01                	push   $0x1
   1320a:	ff 75 08             	pushl  0x8(%ebp)
   1320d:	e8 ee fd ff ff       	call   13000 <move_backword>
   13212:	83 c4 10             	add    $0x10,%esp
    }

}
   13215:	90                   	nop
   13216:	c9                   	leave  
   13217:	c3                   	ret    

00013218 <save_cursor>:

static void save_cursor(console_t* console){
   13218:	55                   	push   %ebp
   13219:	89 e5                	mov    %esp,%ebp
    console->old_cursor_col=console->cursor_col;
   1321b:	8b 45 08             	mov    0x8(%ebp),%eax
   1321e:	8b 50 0c             	mov    0xc(%eax),%edx
   13221:	8b 45 08             	mov    0x8(%ebp),%eax
   13224:	89 50 20             	mov    %edx,0x20(%eax)
    console->old_cursor_row=console->cursor_row;
   13227:	8b 45 08             	mov    0x8(%ebp),%eax
   1322a:	8b 50 08             	mov    0x8(%eax),%edx
   1322d:	8b 45 08             	mov    0x8(%ebp),%eax
   13230:	89 50 24             	mov    %edx,0x24(%eax)
}
   13233:	90                   	nop
   13234:	5d                   	pop    %ebp
   13235:	c3                   	ret    

00013236 <restore_cursor>:

static void restore_cursor(console_t* console){
   13236:	55                   	push   %ebp
   13237:	89 e5                	mov    %esp,%ebp
    console->cursor_col=console->old_cursor_col;
   13239:	8b 45 08             	mov    0x8(%ebp),%eax
   1323c:	8b 50 20             	mov    0x20(%eax),%edx
   1323f:	8b 45 08             	mov    0x8(%ebp),%eax
   13242:	89 50 0c             	mov    %edx,0xc(%eax)
    console->cursor_row=console->old_cursor_row;
   13245:	8b 45 08             	mov    0x8(%ebp),%eax
   13248:	8b 50 24             	mov    0x24(%eax),%edx
   1324b:	8b 45 08             	mov    0x8(%ebp),%eax
   1324e:	89 50 08             	mov    %edx,0x8(%eax)
}
   13251:	90                   	nop
   13252:	5d                   	pop    %ebp
   13253:	c3                   	ret    

00013254 <clear_esc_param>:

static void clear_esc_param(console_t* console){
   13254:	55                   	push   %ebp
   13255:	89 e5                	mov    %esp,%ebp
   13257:	83 ec 08             	sub    $0x8,%esp
    kernel_memset(console->esc_param,0,sizeof(console->esc_param));
   1325a:	8b 45 08             	mov    0x8(%ebp),%eax
   1325d:	83 c0 28             	add    $0x28,%eax
   13260:	83 ec 04             	sub    $0x4,%esp
   13263:	6a 28                	push   $0x28
   13265:	6a 00                	push   $0x0
   13267:	50                   	push   %eax
   13268:	e8 82 1f 00 00       	call   151ef <kernel_memset>
   1326d:	83 c4 10             	add    $0x10,%esp
    console->curr_param_index=0;
   13270:	8b 45 08             	mov    0x8(%ebp),%eax
   13273:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
}
   1327a:	90                   	nop
   1327b:	c9                   	leave  
   1327c:	c3                   	ret    

0001327d <write_esc>:

static void write_esc(console_t* console,char c){
   1327d:	55                   	push   %ebp
   1327e:	89 e5                	mov    %esp,%ebp
   13280:	83 ec 18             	sub    $0x18,%esp
   13283:	8b 45 0c             	mov    0xc(%ebp),%eax
   13286:	88 45 f4             	mov    %al,-0xc(%ebp)
    switch (c)
   13289:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
   1328d:	83 f8 38             	cmp    $0x38,%eax
   13290:	74 20                	je     132b2 <write_esc+0x35>
   13292:	83 f8 5b             	cmp    $0x5b,%eax
   13295:	74 31                	je     132c8 <write_esc+0x4b>
   13297:	83 f8 37             	cmp    $0x37,%eax
   1329a:	75 45                	jne    132e1 <write_esc+0x64>
    {
    case '7':
        save_cursor(console);
   1329c:	ff 75 08             	pushl  0x8(%ebp)
   1329f:	e8 74 ff ff ff       	call   13218 <save_cursor>
   132a4:	83 c4 04             	add    $0x4,%esp
        console->write_state=CONSOLE_WRITE_NORMAL;
   132a7:	8b 45 08             	mov    0x8(%ebp),%eax
   132aa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        break;
   132b0:	eb 39                	jmp    132eb <write_esc+0x6e>
    case '8':
        restore_cursor(console);
   132b2:	ff 75 08             	pushl  0x8(%ebp)
   132b5:	e8 7c ff ff ff       	call   13236 <restore_cursor>
   132ba:	83 c4 04             	add    $0x4,%esp
        console->write_state=CONSOLE_WRITE_NORMAL;
   132bd:	8b 45 08             	mov    0x8(%ebp),%eax
   132c0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        break;
   132c6:	eb 23                	jmp    132eb <write_esc+0x6e>
    case '[':
        clear_esc_param(console);
   132c8:	83 ec 0c             	sub    $0xc,%esp
   132cb:	ff 75 08             	pushl  0x8(%ebp)
   132ce:	e8 81 ff ff ff       	call   13254 <clear_esc_param>
   132d3:	83 c4 10             	add    $0x10,%esp
        console->write_state=CONSOLE_WRITE_SQUARE;
   132d6:	8b 45 08             	mov    0x8(%ebp),%eax
   132d9:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        break;
   132df:	eb 0a                	jmp    132eb <write_esc+0x6e>
    default:
        console->write_state=CONSOLE_WRITE_NORMAL;
   132e1:	8b 45 08             	mov    0x8(%ebp),%eax
   132e4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        break;
   132ea:	90                   	nop
    }
}
   132eb:	90                   	nop
   132ec:	c9                   	leave  
   132ed:	c3                   	ret    

000132ee <set_font_style>:

static void set_font_style(console_t* console){
   132ee:	55                   	push   %ebp
   132ef:	89 e5                	mov    %esp,%ebp
   132f1:	83 ec 10             	sub    $0x10,%esp
    static const color_t color_table[]={
        BLACK,RED,GREEN,YELLOW,BLUE,
        MAGENTA,CYAN,WHITE
    };

    for(int i=0;i<=console->curr_param_index;i++){
   132f4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   132fb:	eb 78                	jmp    13375 <set_font_style+0x87>
        int param=console->esc_param[i];
   132fd:	8b 45 08             	mov    0x8(%ebp),%eax
   13300:	8b 55 fc             	mov    -0x4(%ebp),%edx
   13303:	83 c2 08             	add    $0x8,%edx
   13306:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
   1330a:	89 45 f8             	mov    %eax,-0x8(%ebp)
        if((param>=30) && (param <= 37)){
   1330d:	83 7d f8 1d          	cmpl   $0x1d,-0x8(%ebp)
   13311:	7e 1b                	jle    1332e <set_font_style+0x40>
   13313:	83 7d f8 25          	cmpl   $0x25,-0x8(%ebp)
   13317:	7f 15                	jg     1332e <set_font_style+0x40>
            console->foreground=color_table[param-30];
   13319:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1331c:	83 e8 1e             	sub    $0x1e,%eax
   1331f:	8b 14 85 00 63 01 00 	mov    0x16300(,%eax,4),%edx
   13326:	8b 45 08             	mov    0x8(%ebp),%eax
   13329:	89 50 18             	mov    %edx,0x18(%eax)
   1332c:	eb 43                	jmp    13371 <set_font_style+0x83>
        }
        else if((param >= 40)&&(param <= 47)){
   1332e:	83 7d f8 27          	cmpl   $0x27,-0x8(%ebp)
   13332:	7e 1b                	jle    1334f <set_font_style+0x61>
   13334:	83 7d f8 2f          	cmpl   $0x2f,-0x8(%ebp)
   13338:	7f 15                	jg     1334f <set_font_style+0x61>
            console->background=color_table[param-40];
   1333a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1333d:	83 e8 28             	sub    $0x28,%eax
   13340:	8b 14 85 00 63 01 00 	mov    0x16300(,%eax,4),%edx
   13347:	8b 45 08             	mov    0x8(%ebp),%eax
   1334a:	89 50 1c             	mov    %edx,0x1c(%eax)
   1334d:	eb 22                	jmp    13371 <set_font_style+0x83>
        }
        else if(param == 39){
   1334f:	83 7d f8 27          	cmpl   $0x27,-0x8(%ebp)
   13353:	75 0c                	jne    13361 <set_font_style+0x73>
            console->foreground=WHITE;
   13355:	8b 45 08             	mov    0x8(%ebp),%eax
   13358:	c7 40 18 0f 00 00 00 	movl   $0xf,0x18(%eax)
   1335f:	eb 10                	jmp    13371 <set_font_style+0x83>
        }
        else if(param == 49){
   13361:	83 7d f8 31          	cmpl   $0x31,-0x8(%ebp)
   13365:	75 0a                	jne    13371 <set_font_style+0x83>
            console->background=BLACK;
   13367:	8b 45 08             	mov    0x8(%ebp),%eax
   1336a:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    for(int i=0;i<=console->curr_param_index;i++){
   13371:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   13375:	8b 45 08             	mov    0x8(%ebp),%eax
   13378:	8b 40 50             	mov    0x50(%eax),%eax
   1337b:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   1337e:	0f 8e 79 ff ff ff    	jle    132fd <set_font_style+0xf>
        }
    }

}
   13384:	90                   	nop
   13385:	c9                   	leave  
   13386:	c3                   	ret    

00013387 <erase_in_display>:

static void erase_in_display(console_t* console){
   13387:	55                   	push   %ebp
   13388:	89 e5                	mov    %esp,%ebp
   1338a:	83 ec 10             	sub    $0x10,%esp
    if(console->curr_param_index < 0){
   1338d:	8b 45 08             	mov    0x8(%ebp),%eax
   13390:	8b 40 50             	mov    0x50(%eax),%eax
   13393:	85 c0                	test   %eax,%eax
   13395:	78 3e                	js     133d5 <erase_in_display+0x4e>
        return;
    }

    int param=console->esc_param[0];
   13397:	8b 45 08             	mov    0x8(%ebp),%eax
   1339a:	8b 40 28             	mov    0x28(%eax),%eax
   1339d:	89 45 fc             	mov    %eax,-0x4(%ebp)

    if(param==2){
   133a0:	83 7d fc 02          	cmpl   $0x2,-0x4(%ebp)
   133a4:	75 30                	jne    133d6 <erase_in_display+0x4f>
        erase_rows(console,0,console->display_cols-1);
   133a6:	8b 45 08             	mov    0x8(%ebp),%eax
   133a9:	8b 40 14             	mov    0x14(%eax),%eax
   133ac:	83 e8 01             	sub    $0x1,%eax
   133af:	50                   	push   %eax
   133b0:	6a 00                	push   $0x0
   133b2:	ff 75 08             	pushl  0x8(%ebp)
   133b5:	e8 e6 f9 ff ff       	call   12da0 <erase_rows>
   133ba:	83 c4 0c             	add    $0xc,%esp
        console->cursor_col=console->cursor_row=0;
   133bd:	8b 45 08             	mov    0x8(%ebp),%eax
   133c0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   133c7:	8b 45 08             	mov    0x8(%ebp),%eax
   133ca:	8b 50 08             	mov    0x8(%eax),%edx
   133cd:	8b 45 08             	mov    0x8(%ebp),%eax
   133d0:	89 50 0c             	mov    %edx,0xc(%eax)
   133d3:	eb 01                	jmp    133d6 <erase_in_display+0x4f>
        return;
   133d5:	90                   	nop
    }

}
   133d6:	c9                   	leave  
   133d7:	c3                   	ret    

000133d8 <move_cursor>:

static void move_cursor(console_t* console){
   133d8:	55                   	push   %ebp
   133d9:	89 e5                	mov    %esp,%ebp
    console->cursor_row=console->esc_param[0];
   133db:	8b 45 08             	mov    0x8(%ebp),%eax
   133de:	8b 50 28             	mov    0x28(%eax),%edx
   133e1:	8b 45 08             	mov    0x8(%ebp),%eax
   133e4:	89 50 08             	mov    %edx,0x8(%eax)
    console->cursor_col=console->esc_param[1];
   133e7:	8b 45 08             	mov    0x8(%ebp),%eax
   133ea:	8b 50 2c             	mov    0x2c(%eax),%edx
   133ed:	8b 45 08             	mov    0x8(%ebp),%eax
   133f0:	89 50 0c             	mov    %edx,0xc(%eax)
}
   133f3:	90                   	nop
   133f4:	5d                   	pop    %ebp
   133f5:	c3                   	ret    

000133f6 <move_left>:

static void move_left(console_t* console,int n){
   133f6:	55                   	push   %ebp
   133f7:	89 e5                	mov    %esp,%ebp
   133f9:	83 ec 10             	sub    $0x10,%esp
    if(n==0){
   133fc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   13400:	75 07                	jne    13409 <move_left+0x13>
        n=1;
   13402:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)
    }

    int col=console->cursor_col-n;
   13409:	8b 45 08             	mov    0x8(%ebp),%eax
   1340c:	8b 40 0c             	mov    0xc(%eax),%eax
   1340f:	2b 45 0c             	sub    0xc(%ebp),%eax
   13412:	89 45 fc             	mov    %eax,-0x4(%ebp)

    console->cursor_col=(col>=0)?col:0;
   13415:	b8 00 00 00 00       	mov    $0x0,%eax
   1341a:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1341e:	0f 49 45 fc          	cmovns -0x4(%ebp),%eax
   13422:	89 c2                	mov    %eax,%edx
   13424:	8b 45 08             	mov    0x8(%ebp),%eax
   13427:	89 50 0c             	mov    %edx,0xc(%eax)
}
   1342a:	90                   	nop
   1342b:	c9                   	leave  
   1342c:	c3                   	ret    

0001342d <move_right>:

static void move_right(console_t* console,int n){
   1342d:	55                   	push   %ebp
   1342e:	89 e5                	mov    %esp,%ebp
   13430:	83 ec 10             	sub    $0x10,%esp
    if(n==0){
   13433:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   13437:	75 07                	jne    13440 <move_right+0x13>
        n=1;
   13439:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)
    }

    int col=console->cursor_col+n;
   13440:	8b 45 08             	mov    0x8(%ebp),%eax
   13443:	8b 50 0c             	mov    0xc(%eax),%edx
   13446:	8b 45 0c             	mov    0xc(%ebp),%eax
   13449:	01 d0                	add    %edx,%eax
   1344b:	89 45 fc             	mov    %eax,-0x4(%ebp)

    if(col >= console->display_cols){
   1344e:	8b 45 08             	mov    0x8(%ebp),%eax
   13451:	8b 40 14             	mov    0x14(%eax),%eax
   13454:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   13457:	7c 11                	jl     1346a <move_right+0x3d>
        console->cursor_col=console->display_cols-1;
   13459:	8b 45 08             	mov    0x8(%ebp),%eax
   1345c:	8b 40 14             	mov    0x14(%eax),%eax
   1345f:	8d 50 ff             	lea    -0x1(%eax),%edx
   13462:	8b 45 08             	mov    0x8(%ebp),%eax
   13465:	89 50 0c             	mov    %edx,0xc(%eax)
    }
    else{
        console->cursor_col=col;
    }
}
   13468:	eb 09                	jmp    13473 <move_right+0x46>
        console->cursor_col=col;
   1346a:	8b 45 08             	mov    0x8(%ebp),%eax
   1346d:	8b 55 fc             	mov    -0x4(%ebp),%edx
   13470:	89 50 0c             	mov    %edx,0xc(%eax)
}
   13473:	90                   	nop
   13474:	c9                   	leave  
   13475:	c3                   	ret    

00013476 <write_esc_square>:

static void write_esc_square(console_t* console,char c){
   13476:	55                   	push   %ebp
   13477:	89 e5                	mov    %esp,%ebp
   13479:	83 ec 14             	sub    $0x14,%esp
   1347c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1347f:	88 45 ec             	mov    %al,-0x14(%ebp)
    if((c>='0') && (c<='9')){
   13482:	80 7d ec 2f          	cmpb   $0x2f,-0x14(%ebp)
   13486:	7e 44                	jle    134cc <write_esc_square+0x56>
   13488:	80 7d ec 39          	cmpb   $0x39,-0x14(%ebp)
   1348c:	7f 3e                	jg     134cc <write_esc_square+0x56>
        int *param=&console->esc_param[console->curr_param_index];
   1348e:	8b 45 08             	mov    0x8(%ebp),%eax
   13491:	8b 40 50             	mov    0x50(%eax),%eax
   13494:	83 c0 08             	add    $0x8,%eax
   13497:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1349e:	8b 45 08             	mov    0x8(%ebp),%eax
   134a1:	01 d0                	add    %edx,%eax
   134a3:	83 c0 08             	add    $0x8,%eax
   134a6:	89 45 fc             	mov    %eax,-0x4(%ebp)
        *param=*param*10+c-'0';
   134a9:	8b 45 fc             	mov    -0x4(%ebp),%eax
   134ac:	8b 10                	mov    (%eax),%edx
   134ae:	89 d0                	mov    %edx,%eax
   134b0:	c1 e0 02             	shl    $0x2,%eax
   134b3:	01 d0                	add    %edx,%eax
   134b5:	01 c0                	add    %eax,%eax
   134b7:	89 c2                	mov    %eax,%edx
   134b9:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
   134bd:	01 d0                	add    %edx,%eax
   134bf:	8d 50 d0             	lea    -0x30(%eax),%edx
   134c2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   134c5:	89 10                	mov    %edx,(%eax)
    if((c>='0') && (c<='9')){
   134c7:	e9 9b 00 00 00       	jmp    13567 <write_esc_square+0xf1>
    }
    else if((c==';') && (console->curr_param_index < ESC_PARAM_MAX)){
   134cc:	80 7d ec 3b          	cmpb   $0x3b,-0x14(%ebp)
   134d0:	75 1c                	jne    134ee <write_esc_square+0x78>
   134d2:	8b 45 08             	mov    0x8(%ebp),%eax
   134d5:	8b 40 50             	mov    0x50(%eax),%eax
   134d8:	83 f8 09             	cmp    $0x9,%eax
   134db:	7f 11                	jg     134ee <write_esc_square+0x78>
        console->curr_param_index++;
   134dd:	8b 45 08             	mov    0x8(%ebp),%eax
   134e0:	8b 40 50             	mov    0x50(%eax),%eax
   134e3:	8d 50 01             	lea    0x1(%eax),%edx
   134e6:	8b 45 08             	mov    0x8(%ebp),%eax
   134e9:	89 50 50             	mov    %edx,0x50(%eax)
   134ec:	eb 79                	jmp    13567 <write_esc_square+0xf1>
    }
    else{
        switch(c){
   134ee:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
   134f2:	83 e8 43             	sub    $0x43,%eax
   134f5:	83 f8 2a             	cmp    $0x2a,%eax
   134f8:	77 63                	ja     1355d <write_esc_square+0xe7>
   134fa:	8b 04 85 40 62 01 00 	mov    0x16240(,%eax,4),%eax
   13501:	ff e0                	jmp    *%eax
            case 'm':
                set_font_style(console);
   13503:	ff 75 08             	pushl  0x8(%ebp)
   13506:	e8 e3 fd ff ff       	call   132ee <set_font_style>
   1350b:	83 c4 04             	add    $0x4,%esp
                break;
   1350e:	eb 4e                	jmp    1355e <write_esc_square+0xe8>
            case 'D':
                move_left(console,console->esc_param[0]);
   13510:	8b 45 08             	mov    0x8(%ebp),%eax
   13513:	8b 40 28             	mov    0x28(%eax),%eax
   13516:	50                   	push   %eax
   13517:	ff 75 08             	pushl  0x8(%ebp)
   1351a:	e8 d7 fe ff ff       	call   133f6 <move_left>
   1351f:	83 c4 08             	add    $0x8,%esp
                break;
   13522:	eb 3a                	jmp    1355e <write_esc_square+0xe8>
            case 'C':
                move_right(console,console->esc_param[0]);
   13524:	8b 45 08             	mov    0x8(%ebp),%eax
   13527:	8b 40 28             	mov    0x28(%eax),%eax
   1352a:	50                   	push   %eax
   1352b:	ff 75 08             	pushl  0x8(%ebp)
   1352e:	e8 fa fe ff ff       	call   1342d <move_right>
   13533:	83 c4 08             	add    $0x8,%esp
                break;
   13536:	eb 26                	jmp    1355e <write_esc_square+0xe8>
            case 'H':
                move_cursor(console);
   13538:	ff 75 08             	pushl  0x8(%ebp)
   1353b:	e8 98 fe ff ff       	call   133d8 <move_cursor>
   13540:	83 c4 04             	add    $0x4,%esp
                break;
   13543:	eb 19                	jmp    1355e <write_esc_square+0xe8>
            case 'f':
                 move_cursor(console);
   13545:	ff 75 08             	pushl  0x8(%ebp)
   13548:	e8 8b fe ff ff       	call   133d8 <move_cursor>
   1354d:	83 c4 04             	add    $0x4,%esp
                break;
   13550:	eb 0c                	jmp    1355e <write_esc_square+0xe8>
            case 'J':
                erase_in_display(console);
   13552:	ff 75 08             	pushl  0x8(%ebp)
   13555:	e8 2d fe ff ff       	call   13387 <erase_in_display>
   1355a:	83 c4 04             	add    $0x4,%esp
            default:
                break;
   1355d:	90                   	nop
        }
        console->write_state=CONSOLE_WRITE_NORMAL;
   1355e:	8b 45 08             	mov    0x8(%ebp),%eax
   13561:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
}
   13567:	90                   	nop
   13568:	c9                   	leave  
   13569:	c3                   	ret    

0001356a <write_normal>:

static void write_normal(console_t* console,char c){
   1356a:	55                   	push   %ebp
   1356b:	89 e5                	mov    %esp,%ebp
   1356d:	83 ec 18             	sub    $0x18,%esp
   13570:	8b 45 0c             	mov    0xc(%ebp),%eax
   13573:	88 45 f4             	mov    %al,-0xc(%ebp)
    switch (c)
   13576:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
   1357a:	83 f8 0d             	cmp    $0xd,%eax
   1357d:	74 4a                	je     135c9 <write_normal+0x5f>
   1357f:	83 f8 0d             	cmp    $0xd,%eax
   13582:	7f 0c                	jg     13590 <write_normal+0x26>
   13584:	83 f8 08             	cmp    $0x8,%eax
   13587:	74 2e                	je     135b7 <write_normal+0x4d>
   13589:	83 f8 0a             	cmp    $0xa,%eax
   1358c:	74 4b                	je     135d9 <write_normal+0x6f>
   1358e:	eb 59                	jmp    135e9 <write_normal+0x7f>
   13590:	83 f8 1b             	cmp    $0x1b,%eax
   13593:	74 07                	je     1359c <write_normal+0x32>
   13595:	83 f8 7f             	cmp    $0x7f,%eax
   13598:	74 0d                	je     135a7 <write_normal+0x3d>
   1359a:	eb 4d                	jmp    135e9 <write_normal+0x7f>
    {
        case ASCII_ESC:
            console->write_state=CONSOLE_WRITE_ESC;
   1359c:	8b 45 08             	mov    0x8(%ebp),%eax
   1359f:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
            break;
   135a5:	eb 62                	jmp    13609 <write_normal+0x9f>
        case 0x7F:
            erase_backword(console);
   135a7:	83 ec 0c             	sub    $0xc,%esp
   135aa:	ff 75 08             	pushl  0x8(%ebp)
   135ad:	e8 2c fc ff ff       	call   131de <erase_backword>
   135b2:	83 c4 10             	add    $0x10,%esp
            break;
   135b5:	eb 52                	jmp    13609 <write_normal+0x9f>
        case '\b':
            move_backword(console,1);
   135b7:	83 ec 08             	sub    $0x8,%esp
   135ba:	6a 01                	push   $0x1
   135bc:	ff 75 08             	pushl  0x8(%ebp)
   135bf:	e8 3c fa ff ff       	call   13000 <move_backword>
   135c4:	83 c4 10             	add    $0x10,%esp
            break;
   135c7:	eb 40                	jmp    13609 <write_normal+0x9f>
        case '\r':
            move_to_col0(console);
   135c9:	83 ec 0c             	sub    $0xc,%esp
   135cc:	ff 75 08             	pushl  0x8(%ebp)
   135cf:	e8 6e f9 ff ff       	call   12f42 <move_to_col0>
   135d4:	83 c4 10             	add    $0x10,%esp
            break;
   135d7:	eb 30                	jmp    13609 <write_normal+0x9f>
        case '\n':  
            move_next_line(console);
   135d9:	83 ec 0c             	sub    $0xc,%esp
   135dc:	ff 75 08             	pushl  0x8(%ebp)
   135df:	e8 6e f9 ff ff       	call   12f52 <move_next_line>
   135e4:	83 c4 10             	add    $0x10,%esp
            break;
   135e7:	eb 20                	jmp    13609 <write_normal+0x9f>
        default:
            if((c >= ' ') && (c <= '~')){
   135e9:	80 7d f4 1f          	cmpb   $0x1f,-0xc(%ebp)
   135ed:	7e 19                	jle    13608 <write_normal+0x9e>
   135ef:	80 7d f4 7f          	cmpb   $0x7f,-0xc(%ebp)
   135f3:	74 13                	je     13608 <write_normal+0x9e>
                show_char(console,c);
   135f5:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
   135f9:	83 ec 08             	sub    $0x8,%esp
   135fc:	50                   	push   %eax
   135fd:	ff 75 08             	pushl  0x8(%ebp)
   13600:	e8 44 fb ff ff       	call   13149 <show_char>
   13605:	83 c4 10             	add    $0x10,%esp
            }
            break;
   13608:	90                   	nop
    }
}
   13609:	90                   	nop
   1360a:	c9                   	leave  
   1360b:	c3                   	ret    

0001360c <console_write>:

int console_write(tty_t* tty){
   1360c:	55                   	push   %ebp
   1360d:	89 e5                	mov    %esp,%ebp
   1360f:	83 ec 18             	sub    $0x18,%esp
    console_t* console=console_buf+tty->console_index;
   13612:	8b 45 08             	mov    0x8(%ebp),%eax
   13615:	8b 80 28 04 00 00    	mov    0x428(%eax),%eax
   1361b:	6b c0 54             	imul   $0x54,%eax,%eax
   1361e:	05 00 24 03 00       	add    $0x32400,%eax
   13623:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int len=0;
   13626:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    do{
        char c;
        int err=tty_fifo_get(&tty->ofifo,&c);
   1362d:	8b 45 08             	mov    0x8(%ebp),%eax
   13630:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
   13636:	83 ec 08             	sub    $0x8,%esp
   13639:	8d 45 eb             	lea    -0x15(%ebp),%eax
   1363c:	50                   	push   %eax
   1363d:	52                   	push   %edx
   1363e:	e8 ff 09 00 00       	call   14042 <tty_fifo_get>
   13643:	83 c4 10             	add    $0x10,%esp
   13646:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(err<0){
   13649:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1364d:	79 17                	jns    13666 <console_write+0x5a>
        }
        
        len++;
    }while(1);

    if(tty->console_index==curr_console_idx){
   1364f:	8b 45 08             	mov    0x8(%ebp),%eax
   13652:	8b 90 28 04 00 00    	mov    0x428(%eax),%edx
   13658:	a1 a0 26 03 00       	mov    0x326a0,%eax
   1365d:	39 c2                	cmp    %eax,%edx
   1365f:	74 7f                	je     136e0 <console_write+0xd4>
   13661:	e9 88 00 00 00       	jmp    136ee <console_write+0xe2>
        sem_notify(&tty->osem);
   13666:	8b 45 08             	mov    0x8(%ebp),%eax
   13669:	05 2c 04 00 00       	add    $0x42c,%eax
   1366e:	83 ec 0c             	sub    $0xc,%esp
   13671:	50                   	push   %eax
   13672:	e8 98 16 00 00       	call   14d0f <sem_notify>
   13677:	83 c4 10             	add    $0x10,%esp
        switch(console->write_state){
   1367a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1367d:	8b 00                	mov    (%eax),%eax
   1367f:	83 f8 01             	cmp    $0x1,%eax
   13682:	74 24                	je     136a8 <console_write+0x9c>
   13684:	83 f8 01             	cmp    $0x1,%eax
   13687:	72 07                	jb     13690 <console_write+0x84>
   13689:	83 f8 02             	cmp    $0x2,%eax
   1368c:	74 32                	je     136c0 <console_write+0xb4>
                break;
   1368e:	eb 47                	jmp    136d7 <console_write+0xcb>
                write_normal(console,c);
   13690:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   13694:	0f be c0             	movsbl %al,%eax
   13697:	83 ec 08             	sub    $0x8,%esp
   1369a:	50                   	push   %eax
   1369b:	ff 75 f0             	pushl  -0x10(%ebp)
   1369e:	e8 c7 fe ff ff       	call   1356a <write_normal>
   136a3:	83 c4 10             	add    $0x10,%esp
                break;
   136a6:	eb 2f                	jmp    136d7 <console_write+0xcb>
                write_esc(console,c);
   136a8:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   136ac:	0f be c0             	movsbl %al,%eax
   136af:	83 ec 08             	sub    $0x8,%esp
   136b2:	50                   	push   %eax
   136b3:	ff 75 f0             	pushl  -0x10(%ebp)
   136b6:	e8 c2 fb ff ff       	call   1327d <write_esc>
   136bb:	83 c4 10             	add    $0x10,%esp
                break;
   136be:	eb 17                	jmp    136d7 <console_write+0xcb>
                write_esc_square(console,c);
   136c0:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   136c4:	0f be c0             	movsbl %al,%eax
   136c7:	83 ec 08             	sub    $0x8,%esp
   136ca:	50                   	push   %eax
   136cb:	ff 75 f0             	pushl  -0x10(%ebp)
   136ce:	e8 a3 fd ff ff       	call   13476 <write_esc_square>
   136d3:	83 c4 10             	add    $0x10,%esp
                break;
   136d6:	90                   	nop
        len++;
   136d7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    do{
   136db:	e9 4d ff ff ff       	jmp    1362d <console_write+0x21>
        update_cursor_pos(console);
   136e0:	83 ec 0c             	sub    $0xc,%esp
   136e3:	ff 75 f0             	pushl  -0x10(%ebp)
   136e6:	e8 fb f5 ff ff       	call   12ce6 <update_cursor_pos>
   136eb:	83 c4 10             	add    $0x10,%esp
    }

    return len;
   136ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   136f1:	c9                   	leave  
   136f2:	c3                   	ret    

000136f3 <console_close>:

void console_close(int console){
   136f3:	55                   	push   %ebp
   136f4:	89 e5                	mov    %esp,%ebp
    
}
   136f6:	90                   	nop
   136f7:	5d                   	pop    %ebp
   136f8:	c3                   	ret    

000136f9 <console_select>:

/** 
 * @brief 选择对应的console 
 * @param idx 要切换到的console的索引号
*/ 
void console_select(int idx){
   136f9:	55                   	push   %ebp
   136fa:	89 e5                	mov    %esp,%ebp
   136fc:	83 ec 18             	sub    $0x18,%esp
    console_t* console=console_buf+idx;
   136ff:	8b 45 08             	mov    0x8(%ebp),%eax
   13702:	6b c0 54             	imul   $0x54,%eax,%eax
   13705:	05 00 24 03 00       	add    $0x32400,%eax
   1370a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    
    // 如果显存地址为0说明未初始化，要初始化对应的console
    if(console->disp_base==0){
   1370d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13710:	8b 40 04             	mov    0x4(%eax),%eax
   13713:	85 c0                	test   %eax,%eax
   13715:	75 0e                	jne    13725 <console_select+0x2c>
        console_init(idx);
   13717:	83 ec 0c             	sub    $0xc,%esp
   1371a:	ff 75 08             	pushl  0x8(%ebp)
   1371d:	e8 56 f9 ff ff       	call   13078 <console_init>
   13722:	83 c4 10             	add    $0x10,%esp
    }

    uint16_t pos=idx*console->display_cols*console->display_rows;
   13725:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13728:	8b 40 14             	mov    0x14(%eax),%eax
   1372b:	89 c2                	mov    %eax,%edx
   1372d:	8b 45 08             	mov    0x8(%ebp),%eax
   13730:	0f af d0             	imul   %eax,%edx
   13733:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13736:	8b 40 10             	mov    0x10(%eax),%eax
   13739:	0f af c2             	imul   %edx,%eax
   1373c:	66 89 45 f2          	mov    %ax,-0xe(%ebp)

    outb(0x3D4,0xC);
   13740:	83 ec 08             	sub    $0x8,%esp
   13743:	6a 0c                	push   $0xc
   13745:	68 d4 03 00 00       	push   $0x3d4
   1374a:	e8 04 f5 ff ff       	call   12c53 <outb>
   1374f:	83 c4 10             	add    $0x10,%esp
    
    // 写入高八位
    outb(0x3D5,(uint8_t)((pos >> 8) & 0xFF));
   13752:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
   13756:	66 c1 e8 08          	shr    $0x8,%ax
   1375a:	0f b6 c0             	movzbl %al,%eax
   1375d:	83 ec 08             	sub    $0x8,%esp
   13760:	50                   	push   %eax
   13761:	68 d5 03 00 00       	push   $0x3d5
   13766:	e8 e8 f4 ff ff       	call   12c53 <outb>
   1376b:	83 c4 10             	add    $0x10,%esp

    outb(0x3D4,0xD);
   1376e:	83 ec 08             	sub    $0x8,%esp
   13771:	6a 0d                	push   $0xd
   13773:	68 d4 03 00 00       	push   $0x3d4
   13778:	e8 d6 f4 ff ff       	call   12c53 <outb>
   1377d:	83 c4 10             	add    $0x10,%esp

    // 写入低八位
    outb(0x3D5,(uint8_t)(pos & 0xFF));
   13780:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
   13784:	0f b6 c0             	movzbl %al,%eax
   13787:	83 ec 08             	sub    $0x8,%esp
   1378a:	50                   	push   %eax
   1378b:	68 d5 03 00 00       	push   $0x3d5
   13790:	e8 be f4 ff ff       	call   12c53 <outb>
   13795:	83 c4 10             	add    $0x10,%esp

    curr_console_idx=idx;
   13798:	8b 45 08             	mov    0x8(%ebp),%eax
   1379b:	a3 a0 26 03 00       	mov    %eax,0x326a0

    update_cursor_pos(console);
   137a0:	83 ec 0c             	sub    $0xc,%esp
   137a3:	ff 75 f4             	pushl  -0xc(%ebp)
   137a6:	e8 3b f5 ff ff       	call   12ce6 <update_cursor_pos>
   137ab:	83 c4 10             	add    $0x10,%esp
}
   137ae:	90                   	nop
   137af:	c9                   	leave  
   137b0:	c3                   	ret    

000137b1 <is_devid_bad>:
    &dev_tty_desc,
};

static device_t dev_tb[DEV_TABLE_SIZE];

static int is_devid_bad(int dev_id){
   137b1:	55                   	push   %ebp
   137b2:	89 e5                	mov    %esp,%ebp
    if((dev_id<0) || (dev_id>=DEV_TABLE_SIZE)){
   137b4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   137b8:	78 06                	js     137c0 <is_devid_bad+0xf>
   137ba:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   137be:	7e 07                	jle    137c7 <is_devid_bad+0x16>
        return 1;
   137c0:	b8 01 00 00 00       	mov    $0x1,%eax
   137c5:	eb 24                	jmp    137eb <is_devid_bad+0x3a>
    }

    if(dev_tb[dev_id].desc==(dev_desc_t*)0){
   137c7:	8b 55 08             	mov    0x8(%ebp),%edx
   137ca:	89 d0                	mov    %edx,%eax
   137cc:	c1 e0 02             	shl    $0x2,%eax
   137cf:	01 d0                	add    %edx,%eax
   137d1:	c1 e0 02             	shl    $0x2,%eax
   137d4:	05 c0 26 03 00       	add    $0x326c0,%eax
   137d9:	8b 00                	mov    (%eax),%eax
   137db:	85 c0                	test   %eax,%eax
   137dd:	75 07                	jne    137e6 <is_devid_bad+0x35>
        return 1;
   137df:	b8 01 00 00 00       	mov    $0x1,%eax
   137e4:	eb 05                	jmp    137eb <is_devid_bad+0x3a>
    }

    return 0;
   137e6:	b8 00 00 00 00       	mov    $0x0,%eax
}
   137eb:	5d                   	pop    %ebp
   137ec:	c3                   	ret    

000137ed <dev_open>:

// major打开的主设备号，minor从设备号，data向设备传入的参数
int dev_open(int major,int minor,void* data){
   137ed:	55                   	push   %ebp
   137ee:	89 e5                	mov    %esp,%ebp
   137f0:	83 ec 28             	sub    $0x28,%esp
    irq_state_t state=irq_enter_protection();
   137f3:	e8 15 f4 ff ff       	call   12c0d <irq_enter_protection>
   137f8:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    device_t* free_dev=(device_t*)0;
   137fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    for(int i=0;i<sizeof(dev_tb)/sizeof(dev_tb[0]);i++){
   13802:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   13809:	eb 68                	jmp    13873 <dev_open+0x86>
        device_t* dev=dev_tb+i;
   1380b:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1380e:	89 d0                	mov    %edx,%eax
   13810:	c1 e0 02             	shl    $0x2,%eax
   13813:	01 d0                	add    %edx,%eax
   13815:	c1 e0 02             	shl    $0x2,%eax
   13818:	05 c0 26 03 00       	add    $0x326c0,%eax
   1381d:	89 45 dc             	mov    %eax,-0x24(%ebp)
        if(dev->open_count == 0){
   13820:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13823:	8b 40 10             	mov    0x10(%eax),%eax
   13826:	85 c0                	test   %eax,%eax
   13828:	75 08                	jne    13832 <dev_open+0x45>
            free_dev=dev;
   1382a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1382d:	89 45 f4             	mov    %eax,-0xc(%ebp)
   13830:	eb 3d                	jmp    1386f <dev_open+0x82>
        }
        else if((dev->desc->major == major) && (dev->minor == minor)){
   13832:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13835:	8b 00                	mov    (%eax),%eax
   13837:	8b 40 20             	mov    0x20(%eax),%eax
   1383a:	39 45 08             	cmp    %eax,0x8(%ebp)
   1383d:	75 30                	jne    1386f <dev_open+0x82>
   1383f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13842:	8b 40 08             	mov    0x8(%eax),%eax
   13845:	39 45 0c             	cmp    %eax,0xc(%ebp)
   13848:	75 25                	jne    1386f <dev_open+0x82>
            dev->open_count++;
   1384a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1384d:	8b 40 10             	mov    0x10(%eax),%eax
   13850:	8d 50 01             	lea    0x1(%eax),%edx
   13853:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13856:	89 50 10             	mov    %edx,0x10(%eax)
            irq_leave_protection(state);
   13859:	83 ec 0c             	sub    $0xc,%esp
   1385c:	ff 75 e4             	pushl  -0x1c(%ebp)
   1385f:	e8 c1 f3 ff ff       	call   12c25 <irq_leave_protection>
   13864:	83 c4 10             	add    $0x10,%esp
            return i;
   13867:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1386a:	e9 cc 00 00 00       	jmp    1393b <dev_open+0x14e>
    for(int i=0;i<sizeof(dev_tb)/sizeof(dev_tb[0]);i++){
   1386f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   13873:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13876:	83 f8 7f             	cmp    $0x7f,%eax
   13879:	76 90                	jbe    1380b <dev_open+0x1e>
        }
    }

    dev_desc_t* desc=(dev_desc_t*)0;
   1387b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(int i=0;i<sizeof(dev_desc_tbl)/sizeof(dev_desc_tbl[0]);i++){
   13882:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   13889:	eb 25                	jmp    138b0 <dev_open+0xc3>
        if(dev_desc_tbl[i]->major == major){
   1388b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1388e:	8b 04 85 50 70 01 00 	mov    0x17050(,%eax,4),%eax
   13895:	8b 40 20             	mov    0x20(%eax),%eax
   13898:	39 45 08             	cmp    %eax,0x8(%ebp)
   1389b:	75 0f                	jne    138ac <dev_open+0xbf>
            desc=dev_desc_tbl[i];
   1389d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   138a0:	8b 04 85 50 70 01 00 	mov    0x17050(,%eax,4),%eax
   138a7:	89 45 ec             	mov    %eax,-0x14(%ebp)
            break;
   138aa:	eb 0a                	jmp    138b6 <dev_open+0xc9>
    for(int i=0;i<sizeof(dev_desc_tbl)/sizeof(dev_desc_tbl[0]);i++){
   138ac:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   138b0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   138b4:	74 d5                	je     1388b <dev_open+0x9e>
        }
    }

    if(desc && free_dev){
   138b6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   138ba:	74 6c                	je     13928 <dev_open+0x13b>
   138bc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   138c0:	74 66                	je     13928 <dev_open+0x13b>
       free_dev->minor=minor;
   138c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   138c5:	8b 55 0c             	mov    0xc(%ebp),%edx
   138c8:	89 50 08             	mov    %edx,0x8(%eax)
       free_dev->desc=desc;
   138cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   138ce:	8b 55 ec             	mov    -0x14(%ebp),%edx
   138d1:	89 10                	mov    %edx,(%eax)
       free_dev->data=data;
   138d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   138d6:	8b 55 10             	mov    0x10(%ebp),%edx
   138d9:	89 50 0c             	mov    %edx,0xc(%eax)

       int err=desc->open(free_dev);
   138dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
   138df:	8b 40 24             	mov    0x24(%eax),%eax
   138e2:	83 ec 0c             	sub    $0xc,%esp
   138e5:	ff 75 f4             	pushl  -0xc(%ebp)
   138e8:	ff d0                	call   *%eax
   138ea:	83 c4 10             	add    $0x10,%esp
   138ed:	89 45 e0             	mov    %eax,-0x20(%ebp)
       if(err==0){
   138f0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   138f4:	75 32                	jne    13928 <dev_open+0x13b>
           free_dev->open_count++;
   138f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   138f9:	8b 40 10             	mov    0x10(%eax),%eax
   138fc:	8d 50 01             	lea    0x1(%eax),%edx
   138ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13902:	89 50 10             	mov    %edx,0x10(%eax)
           irq_leave_protection(state);
   13905:	83 ec 0c             	sub    $0xc,%esp
   13908:	ff 75 e4             	pushl  -0x1c(%ebp)
   1390b:	e8 15 f3 ff ff       	call   12c25 <irq_leave_protection>
   13910:	83 c4 10             	add    $0x10,%esp

           // dev_tb是起始位置，free_dev是当前位置，两者相减得到当前位置的偏移量
           return free_dev-dev_tb;
   13913:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13916:	ba c0 26 03 00       	mov    $0x326c0,%edx
   1391b:	29 d0                	sub    %edx,%eax
   1391d:	c1 f8 02             	sar    $0x2,%eax
   13920:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
   13926:	eb 13                	jmp    1393b <dev_open+0x14e>
       }
    }

    irq_leave_protection(state);
   13928:	83 ec 0c             	sub    $0xc,%esp
   1392b:	ff 75 e4             	pushl  -0x1c(%ebp)
   1392e:	e8 f2 f2 ff ff       	call   12c25 <irq_leave_protection>
   13933:	83 c4 10             	add    $0x10,%esp
    return -1;
   13936:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   1393b:	c9                   	leave  
   1393c:	c3                   	ret    

0001393d <dev_read>:

// dev_id:设备id，addr:从哪里开始读取
int dev_read(int dev_id,int addr,char* buf,int size){
   1393d:	55                   	push   %ebp
   1393e:	89 e5                	mov    %esp,%ebp
   13940:	83 ec 18             	sub    $0x18,%esp
    if(is_devid_bad(dev_id)){
   13943:	ff 75 08             	pushl  0x8(%ebp)
   13946:	e8 66 fe ff ff       	call   137b1 <is_devid_bad>
   1394b:	83 c4 04             	add    $0x4,%esp
   1394e:	85 c0                	test   %eax,%eax
   13950:	74 07                	je     13959 <dev_read+0x1c>
        return -1;
   13952:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13957:	eb 2e                	jmp    13987 <dev_read+0x4a>
    }

    device_t* dev=dev_tb+dev_id;
   13959:	8b 55 08             	mov    0x8(%ebp),%edx
   1395c:	89 d0                	mov    %edx,%eax
   1395e:	c1 e0 02             	shl    $0x2,%eax
   13961:	01 d0                	add    %edx,%eax
   13963:	c1 e0 02             	shl    $0x2,%eax
   13966:	05 c0 26 03 00       	add    $0x326c0,%eax
   1396b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return dev->desc->read(dev,addr,buf,size);
   1396e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13971:	8b 00                	mov    (%eax),%eax
   13973:	8b 40 28             	mov    0x28(%eax),%eax
   13976:	ff 75 14             	pushl  0x14(%ebp)
   13979:	ff 75 10             	pushl  0x10(%ebp)
   1397c:	ff 75 0c             	pushl  0xc(%ebp)
   1397f:	ff 75 f4             	pushl  -0xc(%ebp)
   13982:	ff d0                	call   *%eax
   13984:	83 c4 10             	add    $0x10,%esp
}
   13987:	c9                   	leave  
   13988:	c3                   	ret    

00013989 <dev_write>:

int dev_write(int dev_id,int addr,char* buf,int size){
   13989:	55                   	push   %ebp
   1398a:	89 e5                	mov    %esp,%ebp
   1398c:	83 ec 18             	sub    $0x18,%esp
    if(is_devid_bad(dev_id)){
   1398f:	ff 75 08             	pushl  0x8(%ebp)
   13992:	e8 1a fe ff ff       	call   137b1 <is_devid_bad>
   13997:	83 c4 04             	add    $0x4,%esp
   1399a:	85 c0                	test   %eax,%eax
   1399c:	74 07                	je     139a5 <dev_write+0x1c>
        return -1;
   1399e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   139a3:	eb 2e                	jmp    139d3 <dev_write+0x4a>
    }

    device_t* dev=dev_tb+dev_id;
   139a5:	8b 55 08             	mov    0x8(%ebp),%edx
   139a8:	89 d0                	mov    %edx,%eax
   139aa:	c1 e0 02             	shl    $0x2,%eax
   139ad:	01 d0                	add    %edx,%eax
   139af:	c1 e0 02             	shl    $0x2,%eax
   139b2:	05 c0 26 03 00       	add    $0x326c0,%eax
   139b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return dev->desc->write(dev,addr,buf,size);
   139ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
   139bd:	8b 00                	mov    (%eax),%eax
   139bf:	8b 40 2c             	mov    0x2c(%eax),%eax
   139c2:	ff 75 14             	pushl  0x14(%ebp)
   139c5:	ff 75 10             	pushl  0x10(%ebp)
   139c8:	ff 75 0c             	pushl  0xc(%ebp)
   139cb:	ff 75 f4             	pushl  -0xc(%ebp)
   139ce:	ff d0                	call   *%eax
   139d0:	83 c4 10             	add    $0x10,%esp
}
   139d3:	c9                   	leave  
   139d4:	c3                   	ret    

000139d5 <dev_control>:

int dev_control(int dev_id,int cmd,int arg0,int arg1){
   139d5:	55                   	push   %ebp
   139d6:	89 e5                	mov    %esp,%ebp
   139d8:	83 ec 18             	sub    $0x18,%esp
    if(is_devid_bad(dev_id)){
   139db:	ff 75 08             	pushl  0x8(%ebp)
   139de:	e8 ce fd ff ff       	call   137b1 <is_devid_bad>
   139e3:	83 c4 04             	add    $0x4,%esp
   139e6:	85 c0                	test   %eax,%eax
   139e8:	74 07                	je     139f1 <dev_control+0x1c>
        return -1;
   139ea:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   139ef:	eb 2e                	jmp    13a1f <dev_control+0x4a>
    }

    device_t* dev=dev_tb+dev_id;
   139f1:	8b 55 08             	mov    0x8(%ebp),%edx
   139f4:	89 d0                	mov    %edx,%eax
   139f6:	c1 e0 02             	shl    $0x2,%eax
   139f9:	01 d0                	add    %edx,%eax
   139fb:	c1 e0 02             	shl    $0x2,%eax
   139fe:	05 c0 26 03 00       	add    $0x326c0,%eax
   13a03:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return dev->desc->control(dev,cmd,arg0,arg1);
   13a06:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13a09:	8b 00                	mov    (%eax),%eax
   13a0b:	8b 40 30             	mov    0x30(%eax),%eax
   13a0e:	ff 75 14             	pushl  0x14(%ebp)
   13a11:	ff 75 10             	pushl  0x10(%ebp)
   13a14:	ff 75 0c             	pushl  0xc(%ebp)
   13a17:	ff 75 f4             	pushl  -0xc(%ebp)
   13a1a:	ff d0                	call   *%eax
   13a1c:	83 c4 10             	add    $0x10,%esp
}
   13a1f:	c9                   	leave  
   13a20:	c3                   	ret    

00013a21 <dev_close>:

void dev_close(int dev_id){
   13a21:	55                   	push   %ebp
   13a22:	89 e5                	mov    %esp,%ebp
   13a24:	83 ec 18             	sub    $0x18,%esp
    if(is_devid_bad(dev_id)){
   13a27:	ff 75 08             	pushl  0x8(%ebp)
   13a2a:	e8 82 fd ff ff       	call   137b1 <is_devid_bad>
   13a2f:	83 c4 04             	add    $0x4,%esp
   13a32:	85 c0                	test   %eax,%eax
   13a34:	75 6c                	jne    13aa2 <dev_close+0x81>
        return;
    }
    
    device_t* dev=dev_tb+dev_id;
   13a36:	8b 55 08             	mov    0x8(%ebp),%edx
   13a39:	89 d0                	mov    %edx,%eax
   13a3b:	c1 e0 02             	shl    $0x2,%eax
   13a3e:	01 d0                	add    %edx,%eax
   13a40:	c1 e0 02             	shl    $0x2,%eax
   13a43:	05 c0 26 03 00       	add    $0x326c0,%eax
   13a48:	89 45 f4             	mov    %eax,-0xc(%ebp)

    irq_state_t state=irq_enter_protection();
   13a4b:	e8 bd f1 ff ff       	call   12c0d <irq_enter_protection>
   13a50:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if(--dev->open_count == 0){
   13a53:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13a56:	8b 40 10             	mov    0x10(%eax),%eax
   13a59:	8d 50 ff             	lea    -0x1(%eax),%edx
   13a5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13a5f:	89 50 10             	mov    %edx,0x10(%eax)
   13a62:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13a65:	8b 40 10             	mov    0x10(%eax),%eax
   13a68:	85 c0                	test   %eax,%eax
   13a6a:	75 25                	jne    13a91 <dev_close+0x70>
        dev->desc->close(dev);
   13a6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13a6f:	8b 00                	mov    (%eax),%eax
   13a71:	8b 40 34             	mov    0x34(%eax),%eax
   13a74:	83 ec 0c             	sub    $0xc,%esp
   13a77:	ff 75 f4             	pushl  -0xc(%ebp)
   13a7a:	ff d0                	call   *%eax
   13a7c:	83 c4 10             	add    $0x10,%esp
        kernel_memset(dev,0,sizeof(device_t));
   13a7f:	83 ec 04             	sub    $0x4,%esp
   13a82:	6a 14                	push   $0x14
   13a84:	6a 00                	push   $0x0
   13a86:	ff 75 f4             	pushl  -0xc(%ebp)
   13a89:	e8 61 17 00 00       	call   151ef <kernel_memset>
   13a8e:	83 c4 10             	add    $0x10,%esp
    }

    irq_leave_protection(state);
   13a91:	83 ec 0c             	sub    $0xc,%esp
   13a94:	ff 75 f0             	pushl  -0x10(%ebp)
   13a97:	e8 89 f1 ff ff       	call   12c25 <irq_leave_protection>
   13a9c:	83 c4 10             	add    $0x10,%esp
    
    return;
   13a9f:	90                   	nop
   13aa0:	eb 01                	jmp    13aa3 <dev_close+0x82>
        return;
   13aa2:	90                   	nop
}
   13aa3:	c9                   	leave  
   13aa4:	c3                   	ret    

00013aa5 <inb>:
static inline uint8_t inb(uint16_t port){
   13aa5:	55                   	push   %ebp
   13aa6:	89 e5                	mov    %esp,%ebp
   13aa8:	83 ec 14             	sub    $0x14,%esp
   13aab:	8b 45 08             	mov    0x8(%ebp),%eax
   13aae:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__(
   13ab2:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   13ab6:	89 c2                	mov    %eax,%edx
   13ab8:	ec                   	in     (%dx),%al
   13ab9:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   13abc:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   13ac0:	c9                   	leave  
   13ac1:	c3                   	ret    

00013ac2 <kbd_init>:

};



void kbd_init(void){
   13ac2:	55                   	push   %ebp
   13ac3:	89 e5                	mov    %esp,%ebp
   13ac5:	83 ec 08             	sub    $0x8,%esp
    static int inited=0;

    if(!inited){
   13ac8:	a1 c4 30 03 00       	mov    0x330c4,%eax
   13acd:	85 c0                	test   %eax,%eax
   13acf:	75 3d                	jne    13b0e <kbd_init+0x4c>
        kernel_memset(&kbd_stat,0,sizeof(kbd_stat));
   13ad1:	83 ec 04             	sub    $0x4,%esp
   13ad4:	6a 04                	push   $0x4
   13ad6:	6a 00                	push   $0x0
   13ad8:	68 c0 30 03 00       	push   $0x330c0
   13add:	e8 0d 17 00 00       	call   151ef <kernel_memset>
   13ae2:	83 c4 10             	add    $0x10,%esp
        irq_install(IRQ1_KEYBOARD,(irq_handler_t)exception_handler_kbd);
   13ae5:	83 ec 08             	sub    $0x8,%esp
   13ae8:	68 a8 02 01 00       	push   $0x102a8
   13aed:	6a 21                	push   $0x21
   13aef:	e8 fc eb ff ff       	call   126f0 <irq_install>
   13af4:	83 c4 10             	add    $0x10,%esp
        irq_enable(IRQ1_KEYBOARD);
   13af7:	83 ec 0c             	sub    $0xc,%esp
   13afa:	6a 21                	push   $0x21
   13afc:	e8 2f e9 ff ff       	call   12430 <irq_enable>
   13b01:	83 c4 10             	add    $0x10,%esp

        inited=1;
   13b04:	c7 05 c4 30 03 00 01 	movl   $0x1,0x330c4
   13b0b:	00 00 00 
    }

}
   13b0e:	90                   	nop
   13b0f:	c9                   	leave  
   13b10:	c3                   	ret    

00013b11 <is_make_code>:

static inline int is_make_code(uint8_t key_code){
   13b11:	55                   	push   %ebp
   13b12:	89 e5                	mov    %esp,%ebp
   13b14:	83 ec 04             	sub    $0x4,%esp
   13b17:	8b 45 08             	mov    0x8(%ebp),%eax
   13b1a:	88 45 fc             	mov    %al,-0x4(%ebp)
    return !(key_code & 0x80);
   13b1d:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
   13b21:	f7 d0                	not    %eax
   13b23:	c0 e8 07             	shr    $0x7,%al
   13b26:	0f b6 c0             	movzbl %al,%eax
}
   13b29:	c9                   	leave  
   13b2a:	c3                   	ret    

00013b2b <get_key>:

static inline char get_key(uint8_t key_code){
   13b2b:	55                   	push   %ebp
   13b2c:	89 e5                	mov    %esp,%ebp
   13b2e:	83 ec 04             	sub    $0x4,%esp
   13b31:	8b 45 08             	mov    0x8(%ebp),%eax
   13b34:	88 45 fc             	mov    %al,-0x4(%ebp)
    return key_code & 0x7f;
   13b37:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
   13b3b:	83 e0 7f             	and    $0x7f,%eax
}
   13b3e:	c9                   	leave  
   13b3f:	c3                   	ret    

00013b40 <do_fx_key>:

/**
 * @brief 根据F1-F8的按键值，切换到对应的屏幕
 * @param key F1-F8的按键值
*/
static void do_fx_key(int key){
   13b40:	55                   	push   %ebp
   13b41:	89 e5                	mov    %esp,%ebp
   13b43:	83 ec 18             	sub    $0x18,%esp
    int index=key-KEY_F1;
   13b46:	8b 45 08             	mov    0x8(%ebp),%eax
   13b49:	83 e8 3b             	sub    $0x3b,%eax
   13b4c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(kbd_stat.lctrl_press || kbd_stat.rctrl_press){
   13b4f:	0f b6 05 c0 30 03 00 	movzbl 0x330c0,%eax
   13b56:	83 e0 20             	and    $0x20,%eax
   13b59:	84 c0                	test   %al,%al
   13b5b:	75 0e                	jne    13b6b <do_fx_key+0x2b>
   13b5d:	0f b6 05 c0 30 03 00 	movzbl 0x330c0,%eax
   13b64:	83 e0 40             	and    $0x40,%eax
   13b67:	84 c0                	test   %al,%al
   13b69:	74 0e                	je     13b79 <do_fx_key+0x39>
        tty_select(index);
   13b6b:	83 ec 0c             	sub    $0xc,%esp
   13b6e:	ff 75 f4             	pushl  -0xc(%ebp)
   13b71:	e8 da 08 00 00       	call   14450 <tty_select>
   13b76:	83 c4 10             	add    $0x10,%esp
    }
}
   13b79:	90                   	nop
   13b7a:	c9                   	leave  
   13b7b:	c3                   	ret    

00013b7c <do_normal_key>:

static void do_normal_key(uint8_t raw_code){
   13b7c:	55                   	push   %ebp
   13b7d:	89 e5                	mov    %esp,%ebp
   13b7f:	83 ec 28             	sub    $0x28,%esp
   13b82:	8b 45 08             	mov    0x8(%ebp),%eax
   13b85:	88 45 e4             	mov    %al,-0x1c(%ebp)
    char key=get_key(raw_code);
   13b88:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   13b8c:	50                   	push   %eax
   13b8d:	e8 99 ff ff ff       	call   13b2b <get_key>
   13b92:	83 c4 04             	add    $0x4,%esp
   13b95:	88 45 f7             	mov    %al,-0x9(%ebp)
    int is_make=is_make_code(raw_code);
   13b98:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   13b9c:	50                   	push   %eax
   13b9d:	e8 6f ff ff ff       	call   13b11 <is_make_code>
   13ba2:	83 c4 04             	add    $0x4,%esp
   13ba5:	89 45 f0             	mov    %eax,-0x10(%ebp)

    switch(key)
   13ba8:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   13bac:	83 e8 1d             	sub    $0x1d,%eax
   13baf:	83 f8 25             	cmp    $0x25,%eax
   13bb2:	0f 87 fc 00 00 00    	ja     13cb4 <do_normal_key+0x138>
   13bb8:	8b 04 85 94 63 01 00 	mov    0x16394(,%eax,4),%eax
   13bbf:	ff e0                	jmp    *%eax
    {
    case KEY_RSHIFT:
        kbd_stat.rshift_press=is_make ? 1 : 0;
   13bc1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   13bc5:	0f 95 c0             	setne  %al
   13bc8:	c1 e0 07             	shl    $0x7,%eax
   13bcb:	c0 f8 07             	sar    $0x7,%al
   13bce:	83 e0 01             	and    $0x1,%eax
   13bd1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   13bd8:	0f b6 05 c0 30 03 00 	movzbl 0x330c0,%eax
   13bdf:	83 e0 fb             	and    $0xfffffffb,%eax
   13be2:	09 d0                	or     %edx,%eax
   13be4:	a2 c0 30 03 00       	mov    %al,0x330c0
        break;
   13be9:	e9 5e 01 00 00       	jmp    13d4c <do_normal_key+0x1d0>
    case KEY_LSHIFT:
        kbd_stat.lshift_press=is_make ? 1 : 0;
   13bee:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   13bf2:	0f 95 c0             	setne  %al
   13bf5:	c1 e0 07             	shl    $0x7,%eax
   13bf8:	c0 f8 07             	sar    $0x7,%al
   13bfb:	83 e0 01             	and    $0x1,%eax
   13bfe:	8d 14 00             	lea    (%eax,%eax,1),%edx
   13c01:	0f b6 05 c0 30 03 00 	movzbl 0x330c0,%eax
   13c08:	83 e0 fd             	and    $0xfffffffd,%eax
   13c0b:	09 d0                	or     %edx,%eax
   13c0d:	a2 c0 30 03 00       	mov    %al,0x330c0
        break;
   13c12:	e9 35 01 00 00       	jmp    13d4c <do_normal_key+0x1d0>
    case KEY_CAPS:
        if(is_make){
   13c17:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   13c1b:	0f 84 27 01 00 00    	je     13d48 <do_normal_key+0x1cc>
            kbd_stat.caps_lock=~kbd_stat.caps_lock;
   13c21:	0f b6 05 c0 30 03 00 	movzbl 0x330c0,%eax
   13c28:	c1 e0 07             	shl    $0x7,%eax
   13c2b:	c0 f8 07             	sar    $0x7,%al
   13c2e:	f7 d0                	not    %eax
   13c30:	c1 e0 07             	shl    $0x7,%eax
   13c33:	c0 f8 07             	sar    $0x7,%al
   13c36:	83 e0 01             	and    $0x1,%eax
   13c39:	89 c2                	mov    %eax,%edx
   13c3b:	0f b6 05 c0 30 03 00 	movzbl 0x330c0,%eax
   13c42:	83 e0 fe             	and    $0xfffffffe,%eax
   13c45:	09 d0                	or     %edx,%eax
   13c47:	a2 c0 30 03 00       	mov    %al,0x330c0
        }
        break;
   13c4c:	e9 f7 00 00 00       	jmp    13d48 <do_normal_key+0x1cc>
    case KEY_ALT:
        kbd_stat.lalt_press=is_make;
   13c51:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13c54:	c1 e0 07             	shl    $0x7,%eax
   13c57:	c0 f8 07             	sar    $0x7,%al
   13c5a:	83 e0 01             	and    $0x1,%eax
   13c5d:	c1 e0 04             	shl    $0x4,%eax
   13c60:	89 c2                	mov    %eax,%edx
   13c62:	0f b6 05 c0 30 03 00 	movzbl 0x330c0,%eax
   13c69:	83 e0 ef             	and    $0xffffffef,%eax
   13c6c:	09 d0                	or     %edx,%eax
   13c6e:	a2 c0 30 03 00       	mov    %al,0x330c0
        break;
   13c73:	e9 d4 00 00 00       	jmp    13d4c <do_normal_key+0x1d0>
    case KEY_CTRL:
        kbd_stat.lctrl_press=is_make;
   13c78:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13c7b:	c1 e0 07             	shl    $0x7,%eax
   13c7e:	c0 f8 07             	sar    $0x7,%al
   13c81:	83 e0 01             	and    $0x1,%eax
   13c84:	c1 e0 05             	shl    $0x5,%eax
   13c87:	89 c2                	mov    %eax,%edx
   13c89:	0f b6 05 c0 30 03 00 	movzbl 0x330c0,%eax
   13c90:	83 e0 df             	and    $0xffffffdf,%eax
   13c93:	09 d0                	or     %edx,%eax
   13c95:	a2 c0 30 03 00       	mov    %al,0x330c0
        break;
   13c9a:	e9 ad 00 00 00       	jmp    13d4c <do_normal_key+0x1d0>
    case KEY_F4:
    case KEY_F5:
    case KEY_F6:
    case KEY_F7:
    case KEY_F8:
        do_fx_key(key);
   13c9f:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   13ca3:	83 ec 0c             	sub    $0xc,%esp
   13ca6:	50                   	push   %eax
   13ca7:	e8 94 fe ff ff       	call   13b40 <do_fx_key>
   13cac:	83 c4 10             	add    $0x10,%esp
        break;
   13caf:	e9 98 00 00 00       	jmp    13d4c <do_normal_key+0x1d0>
    default:
        if(is_make){
   13cb4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   13cb8:	0f 84 8d 00 00 00    	je     13d4b <do_normal_key+0x1cf>
            if(kbd_stat.lshift_press || kbd_stat.rshift_press){
   13cbe:	0f b6 05 c0 30 03 00 	movzbl 0x330c0,%eax
   13cc5:	83 e0 02             	and    $0x2,%eax
   13cc8:	84 c0                	test   %al,%al
   13cca:	75 0e                	jne    13cda <do_normal_key+0x15e>
   13ccc:	0f b6 05 c0 30 03 00 	movzbl 0x330c0,%eax
   13cd3:	83 e0 04             	and    $0x4,%eax
   13cd6:	84 c0                	test   %al,%al
   13cd8:	74 11                	je     13ceb <do_normal_key+0x16f>
                key=map_table[key].func;
   13cda:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   13cde:	0f b6 84 00 21 63 01 	movzbl 0x16321(%eax,%eax,1),%eax
   13ce5:	00 
   13ce6:	88 45 f7             	mov    %al,-0x9(%ebp)
   13ce9:	eb 0f                	jmp    13cfa <do_normal_key+0x17e>
            }
            else{
                key=map_table[key].normal;
   13ceb:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   13cef:	0f b6 84 00 20 63 01 	movzbl 0x16320(%eax,%eax,1),%eax
   13cf6:	00 
   13cf7:	88 45 f7             	mov    %al,-0x9(%ebp)
            }

            if(kbd_stat.caps_lock){
   13cfa:	0f b6 05 c0 30 03 00 	movzbl 0x330c0,%eax
   13d01:	83 e0 01             	and    $0x1,%eax
   13d04:	84 c0                	test   %al,%al
   13d06:	74 2e                	je     13d36 <do_normal_key+0x1ba>
                if((key>='A') && (key <='Z')){
   13d08:	80 7d f7 40          	cmpb   $0x40,-0x9(%ebp)
   13d0c:	7e 12                	jle    13d20 <do_normal_key+0x1a4>
   13d0e:	80 7d f7 5a          	cmpb   $0x5a,-0x9(%ebp)
   13d12:	7f 0c                	jg     13d20 <do_normal_key+0x1a4>
                    key=key-'A'+'a';
   13d14:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
   13d18:	83 c0 20             	add    $0x20,%eax
   13d1b:	88 45 f7             	mov    %al,-0x9(%ebp)
   13d1e:	eb 16                	jmp    13d36 <do_normal_key+0x1ba>
                }
                else if((key >= 'a') && (key <= 'z')){
   13d20:	80 7d f7 60          	cmpb   $0x60,-0x9(%ebp)
   13d24:	7e 10                	jle    13d36 <do_normal_key+0x1ba>
   13d26:	80 7d f7 7a          	cmpb   $0x7a,-0x9(%ebp)
   13d2a:	7f 0a                	jg     13d36 <do_normal_key+0x1ba>
                    key=key-'a'+'A';
   13d2c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
   13d30:	83 e8 20             	sub    $0x20,%eax
   13d33:	88 45 f7             	mov    %al,-0x9(%ebp)
                }
            }

            tty_in(key);
   13d36:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   13d3a:	83 ec 0c             	sub    $0xc,%esp
   13d3d:	50                   	push   %eax
   13d3e:	e8 a0 06 00 00       	call   143e3 <tty_in>
   13d43:	83 c4 10             	add    $0x10,%esp
        }
        break;
   13d46:	eb 03                	jmp    13d4b <do_normal_key+0x1cf>
        break;
   13d48:	90                   	nop
   13d49:	eb 01                	jmp    13d4c <do_normal_key+0x1d0>
        break;
   13d4b:	90                   	nop
    }
}
   13d4c:	90                   	nop
   13d4d:	c9                   	leave  
   13d4e:	c3                   	ret    

00013d4f <do_e0_key>:

void do_e0_key(uint8_t raw_code){
   13d4f:	55                   	push   %ebp
   13d50:	89 e5                	mov    %esp,%ebp
   13d52:	83 ec 14             	sub    $0x14,%esp
   13d55:	8b 45 08             	mov    0x8(%ebp),%eax
   13d58:	88 45 ec             	mov    %al,-0x14(%ebp)
    char key=get_key(raw_code);
   13d5b:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
   13d5f:	50                   	push   %eax
   13d60:	e8 c6 fd ff ff       	call   13b2b <get_key>
   13d65:	83 c4 04             	add    $0x4,%esp
   13d68:	88 45 ff             	mov    %al,-0x1(%ebp)
    int is_make=is_make_code(raw_code);
   13d6b:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
   13d6f:	50                   	push   %eax
   13d70:	e8 9c fd ff ff       	call   13b11 <is_make_code>
   13d75:	83 c4 04             	add    $0x4,%esp
   13d78:	89 45 f8             	mov    %eax,-0x8(%ebp)

    switch (key)
   13d7b:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
   13d7f:	83 f8 1d             	cmp    $0x1d,%eax
   13d82:	74 07                	je     13d8b <do_e0_key+0x3c>
   13d84:	83 f8 38             	cmp    $0x38,%eax
   13d87:	74 26                	je     13daf <do_e0_key+0x60>
        break;
    case KEY_ALT:
        kbd_stat.ralt_press;
        break;
    default:
        break;
   13d89:	eb 25                	jmp    13db0 <do_e0_key+0x61>
        kbd_stat.rctrl_press=is_make;
   13d8b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13d8e:	c1 e0 07             	shl    $0x7,%eax
   13d91:	c0 f8 07             	sar    $0x7,%al
   13d94:	83 e0 01             	and    $0x1,%eax
   13d97:	c1 e0 06             	shl    $0x6,%eax
   13d9a:	89 c2                	mov    %eax,%edx
   13d9c:	0f b6 05 c0 30 03 00 	movzbl 0x330c0,%eax
   13da3:	83 e0 bf             	and    $0xffffffbf,%eax
   13da6:	09 d0                	or     %edx,%eax
   13da8:	a2 c0 30 03 00       	mov    %al,0x330c0
        break;
   13dad:	eb 01                	jmp    13db0 <do_e0_key+0x61>
        break;
   13daf:	90                   	nop
    }
}
   13db0:	90                   	nop
   13db1:	c9                   	leave  
   13db2:	c3                   	ret    

00013db3 <do_handler_kbd>:

void do_handler_kbd(exception_frame_t *frame){
   13db3:	55                   	push   %ebp
   13db4:	89 e5                	mov    %esp,%ebp
   13db6:	83 ec 18             	sub    $0x18,%esp
    static enum{
        NORMAL,
        BEGIN_E0,
        BEGIN_E1,
    }recv_state=NORMAL;
    uint8_t status=inb(KBD_PORT_STAT);
   13db9:	6a 64                	push   $0x64
   13dbb:	e8 e5 fc ff ff       	call   13aa5 <inb>
   13dc0:	83 c4 04             	add    $0x4,%esp
   13dc3:	88 45 f7             	mov    %al,-0x9(%ebp)

    if(!(status & KBD_STAT_RECV_READY)){
   13dc6:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
   13dca:	83 e0 01             	and    $0x1,%eax
   13dcd:	85 c0                	test   %eax,%eax
   13dcf:	75 12                	jne    13de3 <do_handler_kbd+0x30>
        pic_send_eoi(IRQ1_KEYBOARD);
   13dd1:	83 ec 0c             	sub    $0xc,%esp
   13dd4:	6a 21                	push   $0x21
   13dd6:	e8 07 ee ff ff       	call   12be2 <pic_send_eoi>
   13ddb:	83 c4 10             	add    $0x10,%esp
        return;
   13dde:	e9 8e 00 00 00       	jmp    13e71 <do_handler_kbd+0xbe>
    }

    uint8_t raw_code=inb(KBD_PORT_DATA);
   13de3:	83 ec 0c             	sub    $0xc,%esp
   13de6:	6a 60                	push   $0x60
   13de8:	e8 b8 fc ff ff       	call   13aa5 <inb>
   13ded:	83 c4 10             	add    $0x10,%esp
   13df0:	88 45 f6             	mov    %al,-0xa(%ebp)

    if(raw_code == KEY_E0){
   13df3:	80 7d f6 e0          	cmpb   $0xe0,-0xa(%ebp)
   13df7:	75 0a                	jne    13e03 <do_handler_kbd+0x50>
        recv_state=BEGIN_E0;
   13df9:	c7 05 c8 30 03 00 01 	movl   $0x1,0x330c8
   13e00:	00 00 00 
    }

    if(raw_code == KEY_E1){
   13e03:	80 7d f6 e1          	cmpb   $0xe1,-0xa(%ebp)
   13e07:	75 0c                	jne    13e15 <do_handler_kbd+0x62>
        recv_state=BEGIN_E1;
   13e09:	c7 05 c8 30 03 00 02 	movl   $0x2,0x330c8
   13e10:	00 00 00 
   13e13:	eb 4f                	jmp    13e64 <do_handler_kbd+0xb1>
    }
    else{
        switch (recv_state)
   13e15:	a1 c8 30 03 00       	mov    0x330c8,%eax
   13e1a:	83 f8 01             	cmp    $0x1,%eax
   13e1d:	74 1e                	je     13e3d <do_handler_kbd+0x8a>
   13e1f:	83 f8 01             	cmp    $0x1,%eax
   13e22:	72 07                	jb     13e2b <do_handler_kbd+0x78>
   13e24:	83 f8 02             	cmp    $0x2,%eax
   13e27:	74 30                	je     13e59 <do_handler_kbd+0xa6>
            break;
        case BEGIN_E1:
            recv_state=NORMAL;
            break;
        default:
            break;
   13e29:	eb 39                	jmp    13e64 <do_handler_kbd+0xb1>
            do_normal_key(raw_code);
   13e2b:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
   13e2f:	83 ec 0c             	sub    $0xc,%esp
   13e32:	50                   	push   %eax
   13e33:	e8 44 fd ff ff       	call   13b7c <do_normal_key>
   13e38:	83 c4 10             	add    $0x10,%esp
            break;
   13e3b:	eb 27                	jmp    13e64 <do_handler_kbd+0xb1>
            do_e0_key(raw_code);
   13e3d:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
   13e41:	83 ec 0c             	sub    $0xc,%esp
   13e44:	50                   	push   %eax
   13e45:	e8 05 ff ff ff       	call   13d4f <do_e0_key>
   13e4a:	83 c4 10             	add    $0x10,%esp
            recv_state=NORMAL;
   13e4d:	c7 05 c8 30 03 00 00 	movl   $0x0,0x330c8
   13e54:	00 00 00 
            break;
   13e57:	eb 0b                	jmp    13e64 <do_handler_kbd+0xb1>
            recv_state=NORMAL;
   13e59:	c7 05 c8 30 03 00 00 	movl   $0x0,0x330c8
   13e60:	00 00 00 
            break;
   13e63:	90                   	nop
        }
    }

    pic_send_eoi(IRQ1_KEYBOARD);
   13e64:	83 ec 0c             	sub    $0xc,%esp
   13e67:	6a 21                	push   $0x21
   13e69:	e8 74 ed ff ff       	call   12be2 <pic_send_eoi>
   13e6e:	83 c4 10             	add    $0x10,%esp
   13e71:	c9                   	leave  
   13e72:	c3                   	ret    

00013e73 <outb>:
static inline void outb(uint16_t port,uint8_t data){
   13e73:	55                   	push   %ebp
   13e74:	89 e5                	mov    %esp,%ebp
   13e76:	83 ec 08             	sub    $0x8,%esp
   13e79:	8b 55 08             	mov    0x8(%ebp),%edx
   13e7c:	8b 45 0c             	mov    0xc(%ebp),%eax
   13e7f:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   13e83:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile(
   13e86:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   13e8a:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   13e8e:	ee                   	out    %al,(%dx)
}
   13e8f:	90                   	nop
   13e90:	c9                   	leave  
   13e91:	c3                   	ret    

00013e92 <do_handler_time>:
#include "dev/time.h"

// 定时器计数
static uint32_t sys_tick;

void do_handler_time(exception_frame_t* frame){
   13e92:	55                   	push   %ebp
   13e93:	89 e5                	mov    %esp,%ebp
   13e95:	83 ec 08             	sub    $0x8,%esp
    sys_tick++;
   13e98:	a1 cc 30 03 00       	mov    0x330cc,%eax
   13e9d:	83 c0 01             	add    $0x1,%eax
   13ea0:	a3 cc 30 03 00       	mov    %eax,0x330cc
    pic_send_eoi(IRQ0_TIMER);
   13ea5:	83 ec 0c             	sub    $0xc,%esp
   13ea8:	6a 20                	push   $0x20
   13eaa:	e8 33 ed ff ff       	call   12be2 <pic_send_eoi>
   13eaf:	83 c4 10             	add    $0x10,%esp
    task_time_tick();
   13eb2:	e8 de d7 ff ff       	call   11695 <task_time_tick>
}
   13eb7:	90                   	nop
   13eb8:	c9                   	leave  
   13eb9:	c3                   	ret    

00013eba <init_pit>:

// 定时器硬件初始化
static void init_pit(void){
   13eba:	55                   	push   %ebp
   13ebb:	89 e5                	mov    %esp,%ebp
   13ebd:	83 ec 18             	sub    $0x18,%esp
    
    uint32_t reload_count = PIT_OSC_FREQ / (1000.0 / OS_TICK_MS);
   13ec0:	c7 45 f4 9b 2e 00 00 	movl   $0x2e9b,-0xc(%ebp)
    // 设置多少秒产生中断
    outb(PIT_COMMAND_MODE_PORT, PIT_CHANNEL0 | PIT_LOAD_LOHI | PIT_MODE3);
   13ec7:	6a 36                	push   $0x36
   13ec9:	6a 43                	push   $0x43
   13ecb:	e8 a3 ff ff ff       	call   13e73 <outb>
   13ed0:	83 c4 08             	add    $0x8,%esp
    outb(PIT_CHANNEL0_DATA_PORT, reload_count & 0xFF);   // 加载低8位
   13ed3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13ed6:	0f b6 c0             	movzbl %al,%eax
   13ed9:	50                   	push   %eax
   13eda:	6a 40                	push   $0x40
   13edc:	e8 92 ff ff ff       	call   13e73 <outb>
   13ee1:	83 c4 08             	add    $0x8,%esp
    outb(PIT_CHANNEL0_DATA_PORT, (reload_count >> 8) & 0xFF); // 再加载高8位
   13ee4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13ee7:	c1 e8 08             	shr    $0x8,%eax
   13eea:	0f b6 c0             	movzbl %al,%eax
   13eed:	50                   	push   %eax
   13eee:	6a 40                	push   $0x40
   13ef0:	e8 7e ff ff ff       	call   13e73 <outb>
   13ef5:	83 c4 08             	add    $0x8,%esp

    irq_install(IRQ0_TIMER, (irq_handler_t)exception_handler_time);
   13ef8:	83 ec 08             	sub    $0x8,%esp
   13efb:	68 89 02 01 00       	push   $0x10289
   13f00:	6a 20                	push   $0x20
   13f02:	e8 e9 e7 ff ff       	call   126f0 <irq_install>
   13f07:	83 c4 10             	add    $0x10,%esp
    irq_enable(IRQ0_TIMER);
   13f0a:	83 ec 0c             	sub    $0xc,%esp
   13f0d:	6a 20                	push   $0x20
   13f0f:	e8 1c e5 ff ff       	call   12430 <irq_enable>
   13f14:	83 c4 10             	add    $0x10,%esp
}
   13f17:	90                   	nop
   13f18:	c9                   	leave  
   13f19:	c3                   	ret    

00013f1a <time_init>:

// 定时器初始化
void time_init(void){
   13f1a:	55                   	push   %ebp
   13f1b:	89 e5                	mov    %esp,%ebp
   13f1d:	83 ec 08             	sub    $0x8,%esp
    sys_tick=0;
   13f20:	c7 05 cc 30 03 00 00 	movl   $0x0,0x330cc
   13f27:	00 00 00 
    init_pit();
   13f2a:	e8 8b ff ff ff       	call   13eba <init_pit>
   13f2f:	90                   	nop
   13f30:	c9                   	leave  
   13f31:	c3                   	ret    

00013f32 <get_tty>:
static tty_t tty_devs[TTY_NR];

/// @brief 当前tty设备的索引
static int curr_tty=0;

static tty_t* get_tty(device_t* dev){
   13f32:	55                   	push   %ebp
   13f33:	89 e5                	mov    %esp,%ebp
   13f35:	83 ec 18             	sub    $0x18,%esp
    int idx=dev->minor;
   13f38:	8b 45 08             	mov    0x8(%ebp),%eax
   13f3b:	8b 40 08             	mov    0x8(%eax),%eax
   13f3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if((idx<0) || (idx>=TTY_NR) || (!dev->open_count)){
   13f41:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   13f45:	78 10                	js     13f57 <get_tty+0x25>
   13f47:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   13f4b:	7f 0a                	jg     13f57 <get_tty+0x25>
   13f4d:	8b 45 08             	mov    0x8(%ebp),%eax
   13f50:	8b 40 10             	mov    0x10(%eax),%eax
   13f53:	85 c0                	test   %eax,%eax
   13f55:	75 1a                	jne    13f71 <get_tty+0x3f>
        log_printf("tty is not opened. tty=%d\n",idx);
   13f57:	83 ec 08             	sub    $0x8,%esp
   13f5a:	ff 75 f4             	pushl  -0xc(%ebp)
   13f5d:	68 2c 64 01 00       	push   $0x1642c
   13f62:	e8 ab 18 00 00       	call   15812 <log_printf>
   13f67:	83 c4 10             	add    $0x10,%esp
        return (tty_t*)0;
   13f6a:	b8 00 00 00 00       	mov    $0x0,%eax
   13f6f:	eb 0e                	jmp    13f7f <get_tty+0x4d>
    }

    return tty_devs+idx;
   13f71:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13f74:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   13f7a:	05 e0 30 03 00       	add    $0x330e0,%eax
}
   13f7f:	c9                   	leave  
   13f80:	c3                   	ret    

00013f81 <tty_fifo_init>:

void tty_fifo_init(tty_fifo_t* fifo,char* buf,int size){
   13f81:	55                   	push   %ebp
   13f82:	89 e5                	mov    %esp,%ebp
    fifo->buf=buf;
   13f84:	8b 45 08             	mov    0x8(%ebp),%eax
   13f87:	8b 55 0c             	mov    0xc(%ebp),%edx
   13f8a:	89 10                	mov    %edx,(%eax)
    fifo->size=size;
   13f8c:	8b 45 08             	mov    0x8(%ebp),%eax
   13f8f:	8b 55 10             	mov    0x10(%ebp),%edx
   13f92:	89 50 04             	mov    %edx,0x4(%eax)
    fifo->count=0;
   13f95:	8b 45 08             	mov    0x8(%ebp),%eax
   13f98:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    fifo->read=fifo->write=0;
   13f9f:	8b 45 08             	mov    0x8(%ebp),%eax
   13fa2:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
   13fa9:	8b 45 08             	mov    0x8(%ebp),%eax
   13fac:	8b 50 0c             	mov    0xc(%eax),%edx
   13faf:	8b 45 08             	mov    0x8(%ebp),%eax
   13fb2:	89 50 08             	mov    %edx,0x8(%eax)
}
   13fb5:	90                   	nop
   13fb6:	5d                   	pop    %ebp
   13fb7:	c3                   	ret    

00013fb8 <tty_fifo_put>:
 * @brief 向tty的输出缓存中写入一个字符
 * @param fifo tty的输出缓存
 * @param c 要写入的字符
 * @return 0 成功，-1 失败
 */
int tty_fifo_put(tty_fifo_t* fifo,char c){
   13fb8:	55                   	push   %ebp
   13fb9:	89 e5                	mov    %esp,%ebp
   13fbb:	53                   	push   %ebx
   13fbc:	83 ec 24             	sub    $0x24,%esp
   13fbf:	8b 45 0c             	mov    0xc(%ebp),%eax
   13fc2:	88 45 e4             	mov    %al,-0x1c(%ebp)
    irq_state_t state=irq_enter_protection();
   13fc5:	e8 43 ec ff ff       	call   12c0d <irq_enter_protection>
   13fca:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(fifo->count>=fifo->size){
   13fcd:	8b 45 08             	mov    0x8(%ebp),%eax
   13fd0:	8b 50 10             	mov    0x10(%eax),%edx
   13fd3:	8b 45 08             	mov    0x8(%ebp),%eax
   13fd6:	8b 40 04             	mov    0x4(%eax),%eax
   13fd9:	39 c2                	cmp    %eax,%edx
   13fdb:	7c 15                	jl     13ff2 <tty_fifo_put+0x3a>

        irq_leave_protection(state);
   13fdd:	83 ec 0c             	sub    $0xc,%esp
   13fe0:	ff 75 f4             	pushl  -0xc(%ebp)
   13fe3:	e8 3d ec ff ff       	call   12c25 <irq_leave_protection>
   13fe8:	83 c4 10             	add    $0x10,%esp
        return -1;
   13feb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13ff0:	eb 4b                	jmp    1403d <tty_fifo_put+0x85>
    }

    fifo->buf[fifo->write++]=c;
   13ff2:	8b 45 08             	mov    0x8(%ebp),%eax
   13ff5:	8b 18                	mov    (%eax),%ebx
   13ff7:	8b 45 08             	mov    0x8(%ebp),%eax
   13ffa:	8b 40 0c             	mov    0xc(%eax),%eax
   13ffd:	8d 48 01             	lea    0x1(%eax),%ecx
   14000:	8b 55 08             	mov    0x8(%ebp),%edx
   14003:	89 4a 0c             	mov    %ecx,0xc(%edx)
   14006:	8d 14 03             	lea    (%ebx,%eax,1),%edx
   14009:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   1400d:	88 02                	mov    %al,(%edx)
    if(fifo->write>=fifo->size){
   1400f:	8b 45 08             	mov    0x8(%ebp),%eax
   14012:	8b 50 0c             	mov    0xc(%eax),%edx
   14015:	8b 45 08             	mov    0x8(%ebp),%eax
   14018:	8b 40 04             	mov    0x4(%eax),%eax
   1401b:	39 c2                	cmp    %eax,%edx
   1401d:	7c 0a                	jl     14029 <tty_fifo_put+0x71>
        fifo->write=0;
   1401f:	8b 45 08             	mov    0x8(%ebp),%eax
   14022:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    }
    
    fifo->count++;
   14029:	8b 45 08             	mov    0x8(%ebp),%eax
   1402c:	8b 40 10             	mov    0x10(%eax),%eax
   1402f:	8d 50 01             	lea    0x1(%eax),%edx
   14032:	8b 45 08             	mov    0x8(%ebp),%eax
   14035:	89 50 10             	mov    %edx,0x10(%eax)

    return 0;
   14038:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1403d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14040:	c9                   	leave  
   14041:	c3                   	ret    

00014042 <tty_fifo_get>:

int tty_fifo_get(tty_fifo_t* fifo,char* c){
   14042:	55                   	push   %ebp
   14043:	89 e5                	mov    %esp,%ebp
   14045:	53                   	push   %ebx
   14046:	83 ec 14             	sub    $0x14,%esp
    irq_state_t state=irq_enter_protection();
   14049:	e8 bf eb ff ff       	call   12c0d <irq_enter_protection>
   1404e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(fifo->count<=0){
   14051:	8b 45 08             	mov    0x8(%ebp),%eax
   14054:	8b 40 10             	mov    0x10(%eax),%eax
   14057:	85 c0                	test   %eax,%eax
   14059:	7f 15                	jg     14070 <tty_fifo_get+0x2e>
        irq_leave_protection(state);
   1405b:	83 ec 0c             	sub    $0xc,%esp
   1405e:	ff 75 f4             	pushl  -0xc(%ebp)
   14061:	e8 bf eb ff ff       	call   12c25 <irq_leave_protection>
   14066:	83 c4 10             	add    $0x10,%esp
        return -1;
   14069:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1406e:	eb 5a                	jmp    140ca <tty_fifo_get+0x88>
    }

    *c=fifo->buf[fifo->read++];
   14070:	8b 45 08             	mov    0x8(%ebp),%eax
   14073:	8b 18                	mov    (%eax),%ebx
   14075:	8b 45 08             	mov    0x8(%ebp),%eax
   14078:	8b 40 08             	mov    0x8(%eax),%eax
   1407b:	8d 48 01             	lea    0x1(%eax),%ecx
   1407e:	8b 55 08             	mov    0x8(%ebp),%edx
   14081:	89 4a 08             	mov    %ecx,0x8(%edx)
   14084:	01 d8                	add    %ebx,%eax
   14086:	0f b6 10             	movzbl (%eax),%edx
   14089:	8b 45 0c             	mov    0xc(%ebp),%eax
   1408c:	88 10                	mov    %dl,(%eax)
    if(fifo->read>=fifo->size){
   1408e:	8b 45 08             	mov    0x8(%ebp),%eax
   14091:	8b 50 08             	mov    0x8(%eax),%edx
   14094:	8b 45 08             	mov    0x8(%ebp),%eax
   14097:	8b 40 04             	mov    0x4(%eax),%eax
   1409a:	39 c2                	cmp    %eax,%edx
   1409c:	7c 0a                	jl     140a8 <tty_fifo_get+0x66>
        fifo->read=0;
   1409e:	8b 45 08             	mov    0x8(%ebp),%eax
   140a1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    }
    fifo->count--;
   140a8:	8b 45 08             	mov    0x8(%ebp),%eax
   140ab:	8b 40 10             	mov    0x10(%eax),%eax
   140ae:	8d 50 ff             	lea    -0x1(%eax),%edx
   140b1:	8b 45 08             	mov    0x8(%ebp),%eax
   140b4:	89 50 10             	mov    %edx,0x10(%eax)

    irq_leave_protection(state);
   140b7:	83 ec 0c             	sub    $0xc,%esp
   140ba:	ff 75 f4             	pushl  -0xc(%ebp)
   140bd:	e8 63 eb ff ff       	call   12c25 <irq_leave_protection>
   140c2:	83 c4 10             	add    $0x10,%esp
    return 0;
   140c5:	b8 00 00 00 00       	mov    $0x0,%eax
}
   140ca:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   140cd:	c9                   	leave  
   140ce:	c3                   	ret    

000140cf <tty_open>:

int tty_open(device_t* dev){
   140cf:	55                   	push   %ebp
   140d0:	89 e5                	mov    %esp,%ebp
   140d2:	83 ec 18             	sub    $0x18,%esp
    int idx=dev->minor;
   140d5:	8b 45 08             	mov    0x8(%ebp),%eax
   140d8:	8b 40 08             	mov    0x8(%eax),%eax
   140db:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if((idx<0)&&(idx>=TTY_NR)){
   140de:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   140e2:	79 23                	jns    14107 <tty_open+0x38>
   140e4:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   140e8:	7e 1d                	jle    14107 <tty_open+0x38>
        log_printf("open tty failed. incorrect tty num=%d\n",idx);
   140ea:	83 ec 08             	sub    $0x8,%esp
   140ed:	ff 75 f4             	pushl  -0xc(%ebp)
   140f0:	68 48 64 01 00       	push   $0x16448
   140f5:	e8 18 17 00 00       	call   15812 <log_printf>
   140fa:	83 c4 10             	add    $0x10,%esp
        return -1;
   140fd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14102:	e9 c6 00 00 00       	jmp    141cd <tty_open+0xfe>
    }

    tty_t* tty=tty_devs+idx;
   14107:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1410a:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   14110:	05 e0 30 03 00       	add    $0x330e0,%eax
   14115:	89 45 f0             	mov    %eax,-0x10(%ebp)

    tty_fifo_init(&tty->ofifo,tty->obuf,TTY_OBUF_SIZE);
   14118:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1411b:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1411e:	81 c2 00 04 00 00    	add    $0x400,%edx
   14124:	83 ec 04             	sub    $0x4,%esp
   14127:	68 00 02 00 00       	push   $0x200
   1412c:	50                   	push   %eax
   1412d:	52                   	push   %edx
   1412e:	e8 4e fe ff ff       	call   13f81 <tty_fifo_init>
   14133:	83 c4 10             	add    $0x10,%esp
    sem_init(&tty->osem,TTY_OBUF_SIZE);
   14136:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14139:	05 2c 04 00 00       	add    $0x42c,%eax
   1413e:	83 ec 08             	sub    $0x8,%esp
   14141:	68 00 02 00 00       	push   $0x200
   14146:	50                   	push   %eax
   14147:	e8 32 0b 00 00       	call   14c7e <sem_init>
   1414c:	83 c4 10             	add    $0x10,%esp
    tty_fifo_init(&tty->ififo,tty->ibuf,TTY_IBUF_SIZE);
   1414f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14152:	8d 90 00 02 00 00    	lea    0x200(%eax),%edx
   14158:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1415b:	05 14 04 00 00       	add    $0x414,%eax
   14160:	83 ec 04             	sub    $0x4,%esp
   14163:	68 00 02 00 00       	push   $0x200
   14168:	52                   	push   %edx
   14169:	50                   	push   %eax
   1416a:	e8 12 fe ff ff       	call   13f81 <tty_fifo_init>
   1416f:	83 c4 10             	add    $0x10,%esp
    sem_init(&tty->isem,0);
   14172:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14175:	05 3c 04 00 00       	add    $0x43c,%eax
   1417a:	83 ec 08             	sub    $0x8,%esp
   1417d:	6a 00                	push   $0x0
   1417f:	50                   	push   %eax
   14180:	e8 f9 0a 00 00       	call   14c7e <sem_init>
   14185:	83 c4 10             	add    $0x10,%esp

    tty->oflags=TTY_OCRLF;
   14188:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1418b:	c7 80 50 04 00 00 01 	movl   $0x1,0x450(%eax)
   14192:	00 00 00 
    tty->console_index=idx;
   14195:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14198:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1419b:	89 90 28 04 00 00    	mov    %edx,0x428(%eax)

    tty->iflags=TTY_IECHO | TTY_INCLR;
   141a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   141a4:	c7 80 4c 04 00 00 03 	movl   $0x3,0x44c(%eax)
   141ab:	00 00 00 

    kbd_init();    
   141ae:	e8 0f f9 ff ff       	call   13ac2 <kbd_init>
    console_init(tty->console_index);
   141b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   141b6:	8b 80 28 04 00 00    	mov    0x428(%eax),%eax
   141bc:	83 ec 0c             	sub    $0xc,%esp
   141bf:	50                   	push   %eax
   141c0:	e8 b3 ee ff ff       	call   13078 <console_init>
   141c5:	83 c4 10             	add    $0x10,%esp
    
    return 0;
   141c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
   141cd:	c9                   	leave  
   141ce:	c3                   	ret    

000141cf <tty_read>:

int tty_read(device_t* dev,int addr,char* buf,int size){
   141cf:	55                   	push   %ebp
   141d0:	89 e5                	mov    %esp,%ebp
   141d2:	83 ec 18             	sub    $0x18,%esp
    if(size < 0){
   141d5:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   141d9:	79 0a                	jns    141e5 <tty_read+0x16>
        return -1;
   141db:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   141e0:	e9 ef 00 00 00       	jmp    142d4 <tty_read+0x105>
    }

    tty_t* tty=get_tty(dev);
   141e5:	83 ec 0c             	sub    $0xc,%esp
   141e8:	ff 75 08             	pushl  0x8(%ebp)
   141eb:	e8 42 fd ff ff       	call   13f32 <get_tty>
   141f0:	83 c4 10             	add    $0x10,%esp
   141f3:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char* pbuf=buf;
   141f6:	8b 45 10             	mov    0x10(%ebp),%eax
   141f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int len=0;
   141fc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    while(len < size){
   14203:	e9 bd 00 00 00       	jmp    142c5 <tty_read+0xf6>
        sem_wait(&tty->isem);
   14208:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1420b:	05 3c 04 00 00       	add    $0x43c,%eax
   14210:	83 ec 0c             	sub    $0xc,%esp
   14213:	50                   	push   %eax
   14214:	e8 88 0a 00 00       	call   14ca1 <sem_wait>
   14219:	83 c4 10             	add    $0x10,%esp

        char ch;
        tty_fifo_get(&tty->ififo,&ch);
   1421c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1421f:	8d 90 14 04 00 00    	lea    0x414(%eax),%edx
   14225:	83 ec 08             	sub    $0x8,%esp
   14228:	8d 45 eb             	lea    -0x15(%ebp),%eax
   1422b:	50                   	push   %eax
   1422c:	52                   	push   %edx
   1422d:	e8 10 fe ff ff       	call   14042 <tty_fifo_get>
   14232:	83 c4 10             	add    $0x10,%esp
        switch(ch){
   14235:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   14239:	0f be c0             	movsbl %al,%eax
   1423c:	83 f8 0a             	cmp    $0xa,%eax
   1423f:	75 3d                	jne    1427e <tty_read+0xaf>
            case '\n':
                if((tty->iflags & TTY_INCLR) && (len < size-1)){
   14241:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14244:	8b 80 4c 04 00 00    	mov    0x44c(%eax),%eax
   1424a:	83 e0 01             	and    $0x1,%eax
   1424d:	85 c0                	test   %eax,%eax
   1424f:	74 1b                	je     1426c <tty_read+0x9d>
   14251:	8b 45 14             	mov    0x14(%ebp),%eax
   14254:	83 e8 01             	sub    $0x1,%eax
   14257:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1425a:	7d 10                	jge    1426c <tty_read+0x9d>
                    *pbuf++='\r';
   1425c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1425f:	8d 50 01             	lea    0x1(%eax),%edx
   14262:	89 55 f4             	mov    %edx,-0xc(%ebp)
   14265:	c6 00 0d             	movb   $0xd,(%eax)
                    len++;
   14268:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
                }
                *pbuf++='\n';
   1426c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1426f:	8d 50 01             	lea    0x1(%eax),%edx
   14272:	89 55 f4             	mov    %edx,-0xc(%ebp)
   14275:	c6 00 0a             	movb   $0xa,(%eax)
                len++;
   14278:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
                break;
   1427c:	eb 14                	jmp    14292 <tty_read+0xc3>
            default:
                *pbuf++=ch;
   1427e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14281:	8d 50 01             	lea    0x1(%eax),%edx
   14284:	89 55 f4             	mov    %edx,-0xc(%ebp)
   14287:	0f b6 55 eb          	movzbl -0x15(%ebp),%edx
   1428b:	88 10                	mov    %dl,(%eax)
                len++;
   1428d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
                break;
   14291:	90                   	nop
        }

        // 处理回显
        if(tty->iflags & TTY_IECHO){
   14292:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14295:	8b 80 4c 04 00 00    	mov    0x44c(%eax),%eax
   1429b:	83 e0 02             	and    $0x2,%eax
   1429e:	85 c0                	test   %eax,%eax
   142a0:	74 13                	je     142b5 <tty_read+0xe6>
            tty_write(dev,0,&ch,1);
   142a2:	6a 01                	push   $0x1
   142a4:	8d 45 eb             	lea    -0x15(%ebp),%eax
   142a7:	50                   	push   %eax
   142a8:	6a 00                	push   $0x0
   142aa:	ff 75 08             	pushl  0x8(%ebp)
   142ad:	e8 24 00 00 00       	call   142d6 <tty_write>
   142b2:	83 c4 10             	add    $0x10,%esp
        }

        if((ch == '\n') || (ch == '\r')){
   142b5:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   142b9:	3c 0a                	cmp    $0xa,%al
   142bb:	74 14                	je     142d1 <tty_read+0x102>
   142bd:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   142c1:	3c 0d                	cmp    $0xd,%al
   142c3:	74 0c                	je     142d1 <tty_read+0x102>
    while(len < size){
   142c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   142c8:	3b 45 14             	cmp    0x14(%ebp),%eax
   142cb:	0f 8c 37 ff ff ff    	jl     14208 <tty_read+0x39>
            break;
        }
    }
    return len;
   142d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   142d4:	c9                   	leave  
   142d5:	c3                   	ret    

000142d6 <tty_write>:

int tty_write(device_t* dev,int addr,char* buf,int size){
   142d6:	55                   	push   %ebp
   142d7:	89 e5                	mov    %esp,%ebp
   142d9:	83 ec 28             	sub    $0x28,%esp
    if (size < 0){
   142dc:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   142e0:	79 0a                	jns    142ec <tty_write+0x16>
        return -1;
   142e2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   142e7:	e9 e5 00 00 00       	jmp    143d1 <tty_write+0xfb>
    }

    tty_t* tty=get_tty(dev);
   142ec:	83 ec 0c             	sub    $0xc,%esp
   142ef:	ff 75 08             	pushl  0x8(%ebp)
   142f2:	e8 3b fc ff ff       	call   13f32 <get_tty>
   142f7:	83 c4 10             	add    $0x10,%esp
   142fa:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (!tty){
   142fd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14301:	75 0a                	jne    1430d <tty_write+0x37>
        return -1;
   14303:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14308:	e9 c4 00 00 00       	jmp    143d1 <tty_write+0xfb>
    }

    int len =0;
   1430d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while(size){
   14314:	e9 a5 00 00 00       	jmp    143be <tty_write+0xe8>
        char c=*buf++;
   14319:	8b 45 10             	mov    0x10(%ebp),%eax
   1431c:	8d 50 01             	lea    0x1(%eax),%edx
   1431f:	89 55 10             	mov    %edx,0x10(%ebp)
   14322:	0f b6 00             	movzbl (%eax),%eax
   14325:	88 45 ef             	mov    %al,-0x11(%ebp)

        if(c == '\n' && (tty->oflags & TTY_OCRLF)){
   14328:	80 7d ef 0a          	cmpb   $0xa,-0x11(%ebp)
   1432c:	75 43                	jne    14371 <tty_write+0x9b>
   1432e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14331:	8b 80 50 04 00 00    	mov    0x450(%eax),%eax
   14337:	83 e0 01             	and    $0x1,%eax
   1433a:	85 c0                	test   %eax,%eax
   1433c:	74 33                	je     14371 <tty_write+0x9b>
            sem_wait(&tty->osem);
   1433e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14341:	05 2c 04 00 00       	add    $0x42c,%eax
   14346:	83 ec 0c             	sub    $0xc,%esp
   14349:	50                   	push   %eax
   1434a:	e8 52 09 00 00       	call   14ca1 <sem_wait>
   1434f:	83 c4 10             	add    $0x10,%esp
            int err=tty_fifo_put(&tty->ofifo,'\r');
   14352:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14355:	05 00 04 00 00       	add    $0x400,%eax
   1435a:	83 ec 08             	sub    $0x8,%esp
   1435d:	6a 0d                	push   $0xd
   1435f:	50                   	push   %eax
   14360:	e8 53 fc ff ff       	call   13fb8 <tty_fifo_put>
   14365:	83 c4 10             	add    $0x10,%esp
   14368:	89 45 e8             	mov    %eax,-0x18(%ebp)
            if (err<0){
   1436b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1436f:	78 59                	js     143ca <tty_write+0xf4>
                break;
            }
        }

        sem_wait(&tty->osem);
   14371:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14374:	05 2c 04 00 00       	add    $0x42c,%eax
   14379:	83 ec 0c             	sub    $0xc,%esp
   1437c:	50                   	push   %eax
   1437d:	e8 1f 09 00 00       	call   14ca1 <sem_wait>
   14382:	83 c4 10             	add    $0x10,%esp
        int err=tty_fifo_put(&tty->ofifo,c);
   14385:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
   14389:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1438c:	81 c2 00 04 00 00    	add    $0x400,%edx
   14392:	83 ec 08             	sub    $0x8,%esp
   14395:	50                   	push   %eax
   14396:	52                   	push   %edx
   14397:	e8 1c fc ff ff       	call   13fb8 <tty_fifo_put>
   1439c:	83 c4 10             	add    $0x10,%esp
   1439f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (err<0){
   143a2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   143a6:	78 25                	js     143cd <tty_write+0xf7>
            break;
        }
        len++;
   143a8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
        size--;
   143ac:	83 6d 14 01          	subl   $0x1,0x14(%ebp)

        console_write(tty);
   143b0:	83 ec 0c             	sub    $0xc,%esp
   143b3:	ff 75 f0             	pushl  -0x10(%ebp)
   143b6:	e8 51 f2 ff ff       	call   1360c <console_write>
   143bb:	83 c4 10             	add    $0x10,%esp
    while(size){
   143be:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   143c2:	0f 85 51 ff ff ff    	jne    14319 <tty_write+0x43>
   143c8:	eb 04                	jmp    143ce <tty_write+0xf8>
                break;
   143ca:	90                   	nop
   143cb:	eb 01                	jmp    143ce <tty_write+0xf8>
            break;
   143cd:	90                   	nop
    }

    return len;
   143ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   143d1:	c9                   	leave  
   143d2:	c3                   	ret    

000143d3 <tty_control>:

int tty_control(device_t*dev,int cmd,int arg0,int arg1){
   143d3:	55                   	push   %ebp
   143d4:	89 e5                	mov    %esp,%ebp
    return 0;
   143d6:	b8 00 00 00 00       	mov    $0x0,%eax
}
   143db:	5d                   	pop    %ebp
   143dc:	c3                   	ret    

000143dd <tty_close>:

void tty_close(device_t* dev){
   143dd:	55                   	push   %ebp
   143de:	89 e5                	mov    %esp,%ebp

}
   143e0:	90                   	nop
   143e1:	5d                   	pop    %ebp
   143e2:	c3                   	ret    

000143e3 <tty_in>:

/**
* @brief 选择curr_tty索引的tty设备，然后将ch放入tty的输入缓存中
* @param ch 要放入tty设备的输入缓存中的字符
*/ 
void tty_in(char ch){
   143e3:	55                   	push   %ebp
   143e4:	89 e5                	mov    %esp,%ebp
   143e6:	83 ec 28             	sub    $0x28,%esp
   143e9:	8b 45 08             	mov    0x8(%ebp),%eax
   143ec:	88 45 e4             	mov    %al,-0x1c(%ebp)
    tty_t* tty=tty_devs+curr_tty;
   143ef:	a1 80 53 03 00       	mov    0x35380,%eax
   143f4:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   143fa:	05 e0 30 03 00       	add    $0x330e0,%eax
   143ff:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(sem_count(&tty->isem) >= TTY_IBUF_SIZE){
   14402:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14405:	05 3c 04 00 00       	add    $0x43c,%eax
   1440a:	83 ec 0c             	sub    $0xc,%esp
   1440d:	50                   	push   %eax
   1440e:	e8 80 09 00 00       	call   14d93 <sem_count>
   14413:	83 c4 10             	add    $0x10,%esp
   14416:	3d ff 01 00 00       	cmp    $0x1ff,%eax
   1441b:	7f 30                	jg     1444d <tty_in+0x6a>
        return;
    }

    tty_fifo_put(&tty->ififo,ch);
   1441d:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
   14421:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14424:	81 c2 14 04 00 00    	add    $0x414,%edx
   1442a:	83 ec 08             	sub    $0x8,%esp
   1442d:	50                   	push   %eax
   1442e:	52                   	push   %edx
   1442f:	e8 84 fb ff ff       	call   13fb8 <tty_fifo_put>
   14434:	83 c4 10             	add    $0x10,%esp
    sem_notify(&tty->isem);
   14437:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1443a:	05 3c 04 00 00       	add    $0x43c,%eax
   1443f:	83 ec 0c             	sub    $0xc,%esp
   14442:	50                   	push   %eax
   14443:	e8 c7 08 00 00       	call   14d0f <sem_notify>
   14448:	83 c4 10             	add    $0x10,%esp
   1444b:	eb 01                	jmp    1444e <tty_in+0x6b>
        return;
   1444d:	90                   	nop

}
   1444e:	c9                   	leave  
   1444f:	c3                   	ret    

00014450 <tty_select>:

/**
 * @brief 选择tty设备
 * @param tty 要切换的tty设备的索引号
*/
void tty_select(int tty){
   14450:	55                   	push   %ebp
   14451:	89 e5                	mov    %esp,%ebp
   14453:	83 ec 08             	sub    $0x8,%esp
    if(tty!=curr_tty){
   14456:	a1 80 53 03 00       	mov    0x35380,%eax
   1445b:	39 45 08             	cmp    %eax,0x8(%ebp)
   1445e:	74 16                	je     14476 <tty_select+0x26>
        console_select(tty);
   14460:	83 ec 0c             	sub    $0xc,%esp
   14463:	ff 75 08             	pushl  0x8(%ebp)
   14466:	e8 8e f2 ff ff       	call   136f9 <console_select>
   1446b:	83 c4 10             	add    $0x10,%esp
        curr_tty=tty;
   1446e:	8b 45 08             	mov    0x8(%ebp),%eax
   14471:	a3 80 53 03 00       	mov    %eax,0x35380
    }
}
   14476:	90                   	nop
   14477:	c9                   	leave  
   14478:	c3                   	ret    

00014479 <file_alloc>:
#include "ipc/mutex.h"

static file_t file_table[FILE_TABLE_SIZE]; // 文件表
static mutex_t file_alloc_mutex; // 文件表的互斥锁

file_t* file_alloc(void){
   14479:	55                   	push   %ebp
   1447a:	89 e5                	mov    %esp,%ebp
   1447c:	83 ec 18             	sub    $0x18,%esp
    file_t* file=(file_t*)0;
   1447f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    mutex_lock(&file_alloc_mutex);
   14486:	83 ec 0c             	sub    $0xc,%esp
   14489:	68 a0 13 05 00       	push   $0x513a0
   1448e:	e8 92 06 00 00       	call   14b25 <mutex_lock>
   14493:	83 c4 10             	add    $0x10,%esp

    for(int i=0;i<FILE_TABLE_SIZE;i++){
   14496:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1449d:	eb 40                	jmp    144df <file_alloc+0x66>
       file_t* p_file=file_table+i;
   1449f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   144a2:	6b c0 38             	imul   $0x38,%eax,%eax
   144a5:	05 a0 53 03 00       	add    $0x353a0,%eax
   144aa:	89 45 ec             	mov    %eax,-0x14(%ebp)
       if(p_file->ref==0){
   144ad:	8b 45 ec             	mov    -0x14(%ebp),%eax
   144b0:	8b 40 28             	mov    0x28(%eax),%eax
   144b3:	85 c0                	test   %eax,%eax
   144b5:	75 24                	jne    144db <file_alloc+0x62>
           kernel_memset(p_file,0,sizeof(file_t));
   144b7:	83 ec 04             	sub    $0x4,%esp
   144ba:	6a 38                	push   $0x38
   144bc:	6a 00                	push   $0x0
   144be:	ff 75 ec             	pushl  -0x14(%ebp)
   144c1:	e8 29 0d 00 00       	call   151ef <kernel_memset>
   144c6:	83 c4 10             	add    $0x10,%esp
           p_file->ref=1;
   144c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   144cc:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
           file=p_file;
   144d3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   144d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
           break;
   144d9:	eb 0d                	jmp    144e8 <file_alloc+0x6f>
    for(int i=0;i<FILE_TABLE_SIZE;i++){
   144db:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   144df:	81 7d f0 ff 07 00 00 	cmpl   $0x7ff,-0x10(%ebp)
   144e6:	7e b7                	jle    1449f <file_alloc+0x26>
       }
    }

    mutex_unlock(&file_alloc_mutex);
   144e8:	83 ec 0c             	sub    $0xc,%esp
   144eb:	68 a0 13 05 00       	push   $0x513a0
   144f0:	e8 bf 06 00 00       	call   14bb4 <mutex_unlock>
   144f5:	83 c4 10             	add    $0x10,%esp
    return file;
   144f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   144fb:	c9                   	leave  
   144fc:	c3                   	ret    

000144fd <file_free>:

void file_free(file_t* file){
   144fd:	55                   	push   %ebp
   144fe:	89 e5                	mov    %esp,%ebp
   14500:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&file_alloc_mutex);
   14503:	83 ec 0c             	sub    $0xc,%esp
   14506:	68 a0 13 05 00       	push   $0x513a0
   1450b:	e8 15 06 00 00       	call   14b25 <mutex_lock>
   14510:	83 c4 10             	add    $0x10,%esp

    if(file->ref){
   14513:	8b 45 08             	mov    0x8(%ebp),%eax
   14516:	8b 40 28             	mov    0x28(%eax),%eax
   14519:	85 c0                	test   %eax,%eax
   1451b:	74 0f                	je     1452c <file_free+0x2f>
        file->ref--;
   1451d:	8b 45 08             	mov    0x8(%ebp),%eax
   14520:	8b 40 28             	mov    0x28(%eax),%eax
   14523:	8d 50 ff             	lea    -0x1(%eax),%edx
   14526:	8b 45 08             	mov    0x8(%ebp),%eax
   14529:	89 50 28             	mov    %edx,0x28(%eax)
    }
    
    mutex_unlock(&file_alloc_mutex);
   1452c:	83 ec 0c             	sub    $0xc,%esp
   1452f:	68 a0 13 05 00       	push   $0x513a0
   14534:	e8 7b 06 00 00       	call   14bb4 <mutex_unlock>
   14539:	83 c4 10             	add    $0x10,%esp
}
   1453c:	90                   	nop
   1453d:	c9                   	leave  
   1453e:	c3                   	ret    

0001453f <file_table_init>:

void file_table_init(void){
   1453f:	55                   	push   %ebp
   14540:	89 e5                	mov    %esp,%ebp
   14542:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&file_alloc_mutex);
   14545:	83 ec 0c             	sub    $0xc,%esp
   14548:	68 a0 13 05 00       	push   $0x513a0
   1454d:	e8 a5 05 00 00       	call   14af7 <mutex_init>
   14552:	83 c4 10             	add    $0x10,%esp
    kernel_memset(file_table,0,sizeof(file_table));
   14555:	83 ec 04             	sub    $0x4,%esp
   14558:	68 00 c0 01 00       	push   $0x1c000
   1455d:	6a 00                	push   $0x0
   1455f:	68 a0 53 03 00       	push   $0x353a0
   14564:	e8 86 0c 00 00       	call   151ef <kernel_memset>
   14569:	83 c4 10             	add    $0x10,%esp
   1456c:	90                   	nop
   1456d:	c9                   	leave  
   1456e:	c3                   	ret    

0001456f <inb>:
static inline uint8_t inb(uint16_t port){
   1456f:	55                   	push   %ebp
   14570:	89 e5                	mov    %esp,%ebp
   14572:	83 ec 14             	sub    $0x14,%esp
   14575:	8b 45 08             	mov    0x8(%ebp),%eax
   14578:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__(
   1457c:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   14580:	89 c2                	mov    %eax,%edx
   14582:	ec                   	in     (%dx),%al
   14583:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   14586:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   1458a:	c9                   	leave  
   1458b:	c3                   	ret    

0001458c <inw>:
static inline uint16_t inw(uint16_t port){
   1458c:	55                   	push   %ebp
   1458d:	89 e5                	mov    %esp,%ebp
   1458f:	83 ec 14             	sub    $0x14,%esp
   14592:	8b 45 08             	mov    0x8(%ebp),%eax
   14595:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__(
   14599:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   1459d:	89 c2                	mov    %eax,%edx
   1459f:	66 ed                	in     (%dx),%ax
   145a1:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    return rv;
   145a5:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
}
   145a9:	c9                   	leave  
   145aa:	c3                   	ret    

000145ab <outb>:
static inline void outb(uint16_t port,uint8_t data){
   145ab:	55                   	push   %ebp
   145ac:	89 e5                	mov    %esp,%ebp
   145ae:	83 ec 08             	sub    $0x8,%esp
   145b1:	8b 55 08             	mov    0x8(%ebp),%edx
   145b4:	8b 45 0c             	mov    0xc(%ebp),%eax
   145b7:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   145bb:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile(
   145be:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   145c2:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   145c6:	ee                   	out    %al,(%dx)
}
   145c7:	90                   	nop
   145c8:	c9                   	leave  
   145c9:	c3                   	ret    

000145ca <read_disk>:
#define TEMP_FILE_ID        100

static uint8_t TEMP_ADDR[100*1024];
static uint8_t* temp_pos;

static void read_disk(int sector, int sector_count, uint8_t * buf) {
   145ca:	55                   	push   %ebp
   145cb:	89 e5                	mov    %esp,%ebp
   145cd:	53                   	push   %ebx
   145ce:	83 ec 10             	sub    $0x10,%esp
    outb(0x1F6, (uint8_t) (0xE0));
   145d1:	68 e0 00 00 00       	push   $0xe0
   145d6:	68 f6 01 00 00       	push   $0x1f6
   145db:	e8 cb ff ff ff       	call   145ab <outb>
   145e0:	83 c4 08             	add    $0x8,%esp

	outb(0x1F2, (uint8_t) (sector_count >> 8));
   145e3:	8b 45 0c             	mov    0xc(%ebp),%eax
   145e6:	c1 f8 08             	sar    $0x8,%eax
   145e9:	0f b6 c0             	movzbl %al,%eax
   145ec:	50                   	push   %eax
   145ed:	68 f2 01 00 00       	push   $0x1f2
   145f2:	e8 b4 ff ff ff       	call   145ab <outb>
   145f7:	83 c4 08             	add    $0x8,%esp
    outb(0x1F3, (uint8_t) (sector >> 24));		
   145fa:	8b 45 08             	mov    0x8(%ebp),%eax
   145fd:	c1 f8 18             	sar    $0x18,%eax
   14600:	0f b6 c0             	movzbl %al,%eax
   14603:	50                   	push   %eax
   14604:	68 f3 01 00 00       	push   $0x1f3
   14609:	e8 9d ff ff ff       	call   145ab <outb>
   1460e:	83 c4 08             	add    $0x8,%esp
    outb(0x1F4, (uint8_t) (0));					
   14611:	6a 00                	push   $0x0
   14613:	68 f4 01 00 00       	push   $0x1f4
   14618:	e8 8e ff ff ff       	call   145ab <outb>
   1461d:	83 c4 08             	add    $0x8,%esp
    outb(0x1F5, (uint8_t) (0));					
   14620:	6a 00                	push   $0x0
   14622:	68 f5 01 00 00       	push   $0x1f5
   14627:	e8 7f ff ff ff       	call   145ab <outb>
   1462c:	83 c4 08             	add    $0x8,%esp

    outb(0x1F2, (uint8_t) (sector_count));
   1462f:	8b 45 0c             	mov    0xc(%ebp),%eax
   14632:	0f b6 c0             	movzbl %al,%eax
   14635:	50                   	push   %eax
   14636:	68 f2 01 00 00       	push   $0x1f2
   1463b:	e8 6b ff ff ff       	call   145ab <outb>
   14640:	83 c4 08             	add    $0x8,%esp
	outb(0x1F3, (uint8_t) (sector));			
   14643:	8b 45 08             	mov    0x8(%ebp),%eax
   14646:	0f b6 c0             	movzbl %al,%eax
   14649:	50                   	push   %eax
   1464a:	68 f3 01 00 00       	push   $0x1f3
   1464f:	e8 57 ff ff ff       	call   145ab <outb>
   14654:	83 c4 08             	add    $0x8,%esp
	outb(0x1F4, (uint8_t) (sector >> 8));		
   14657:	8b 45 08             	mov    0x8(%ebp),%eax
   1465a:	c1 f8 08             	sar    $0x8,%eax
   1465d:	0f b6 c0             	movzbl %al,%eax
   14660:	50                   	push   %eax
   14661:	68 f4 01 00 00       	push   $0x1f4
   14666:	e8 40 ff ff ff       	call   145ab <outb>
   1466b:	83 c4 08             	add    $0x8,%esp
	outb(0x1F5, (uint8_t) (sector >> 16));		
   1466e:	8b 45 08             	mov    0x8(%ebp),%eax
   14671:	c1 f8 10             	sar    $0x10,%eax
   14674:	0f b6 c0             	movzbl %al,%eax
   14677:	50                   	push   %eax
   14678:	68 f5 01 00 00       	push   $0x1f5
   1467d:	e8 29 ff ff ff       	call   145ab <outb>
   14682:	83 c4 08             	add    $0x8,%esp

	outb(0x1F7, (uint8_t) 0x24);
   14685:	6a 24                	push   $0x24
   14687:	68 f7 01 00 00       	push   $0x1f7
   1468c:	e8 1a ff ff ff       	call   145ab <outb>
   14691:	83 c4 08             	add    $0x8,%esp

	
	uint16_t *data_buf = (uint16_t*) buf;
   14694:	8b 45 10             	mov    0x10(%ebp),%eax
   14697:	89 45 f8             	mov    %eax,-0x8(%ebp)

	// 这里是要读取的扇区
	while (sector_count-- > 0) {
   1469a:	eb 4a                	jmp    146e6 <read_disk+0x11c>
		
		while ((inb(0x1F7) & 0x88) != 0x8) {}
   1469c:	90                   	nop
   1469d:	68 f7 01 00 00       	push   $0x1f7
   146a2:	e8 c8 fe ff ff       	call   1456f <inb>
   146a7:	83 c4 04             	add    $0x4,%esp
   146aa:	0f b6 c0             	movzbl %al,%eax
   146ad:	25 88 00 00 00       	and    $0x88,%eax
   146b2:	83 f8 08             	cmp    $0x8,%eax
   146b5:	75 e6                	jne    1469d <read_disk+0xd3>

		// 以每次2字节方式读取每个扇区
		for (int i = 0; i < SECTOR_SIZE / 2; i++) {
   146b7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   146be:	eb 1d                	jmp    146dd <read_disk+0x113>
			*data_buf++ = inw(0x1F0);
   146c0:	8b 5d f8             	mov    -0x8(%ebp),%ebx
   146c3:	8d 43 02             	lea    0x2(%ebx),%eax
   146c6:	89 45 f8             	mov    %eax,-0x8(%ebp)
   146c9:	68 f0 01 00 00       	push   $0x1f0
   146ce:	e8 b9 fe ff ff       	call   1458c <inw>
   146d3:	83 c4 04             	add    $0x4,%esp
   146d6:	66 89 03             	mov    %ax,(%ebx)
		for (int i = 0; i < SECTOR_SIZE / 2; i++) {
   146d9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   146dd:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   146e4:	7e da                	jle    146c0 <read_disk+0xf6>
	while (sector_count-- > 0) {
   146e6:	8b 45 0c             	mov    0xc(%ebp),%eax
   146e9:	8d 50 ff             	lea    -0x1(%eax),%edx
   146ec:	89 55 0c             	mov    %edx,0xc(%ebp)
   146ef:	85 c0                	test   %eax,%eax
   146f1:	7f a9                	jg     1469c <read_disk+0xd2>
		}
	}
}
   146f3:	90                   	nop
   146f4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   146f7:	c9                   	leave  
   146f8:	c3                   	ret    

000146f9 <is_path_valid>:

static int is_path_valid(const char* path){
   146f9:	55                   	push   %ebp
   146fa:	89 e5                	mov    %esp,%ebp
    if((path==(const char*)0) || (path[0]=='\0')){
   146fc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   14700:	74 0a                	je     1470c <is_path_valid+0x13>
   14702:	8b 45 08             	mov    0x8(%ebp),%eax
   14705:	0f b6 00             	movzbl (%eax),%eax
   14708:	84 c0                	test   %al,%al
   1470a:	75 07                	jne    14713 <is_path_valid+0x1a>
        return 0;
   1470c:	b8 00 00 00 00       	mov    $0x0,%eax
   14711:	eb 05                	jmp    14718 <is_path_valid+0x1f>
    }

    return 1;
   14713:	b8 01 00 00 00       	mov    $0x1,%eax
}
   14718:	5d                   	pop    %ebp
   14719:	c3                   	ret    

0001471a <sys_open>:

int sys_open(const char* name,int flags,...){
   1471a:	55                   	push   %ebp
   1471b:	89 e5                	mov    %esp,%ebp
   1471d:	83 ec 18             	sub    $0x18,%esp
    if(kernel_strncmp(name,"tty:",3)==0){
   14720:	83 ec 04             	sub    $0x4,%esp
   14723:	6a 03                	push   $0x3
   14725:	68 6f 64 01 00       	push   $0x1646f
   1472a:	ff 75 08             	pushl  0x8(%ebp)
   1472d:	e8 b9 09 00 00       	call   150eb <kernel_strncmp>
   14732:	83 c4 10             	add    $0x10,%esp
   14735:	85 c0                	test   %eax,%eax
   14737:	0f 85 04 01 00 00    	jne    14841 <sys_open+0x127>
        if(!is_path_valid(name)){
   1473d:	83 ec 0c             	sub    $0xc,%esp
   14740:	ff 75 08             	pushl  0x8(%ebp)
   14743:	e8 b1 ff ff ff       	call   146f9 <is_path_valid>
   14748:	83 c4 10             	add    $0x10,%esp
   1474b:	85 c0                	test   %eax,%eax
   1474d:	75 1a                	jne    14769 <sys_open+0x4f>
            log_printf("path is invalid\n");
   1474f:	83 ec 0c             	sub    $0xc,%esp
   14752:	68 74 64 01 00       	push   $0x16474
   14757:	e8 b6 10 00 00       	call   15812 <log_printf>
   1475c:	83 c4 10             	add    $0x10,%esp
            return -1;
   1475f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14764:	e9 0f 01 00 00       	jmp    14878 <sys_open+0x15e>
        }

        int fd=-1;
   14769:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
        file_t* file=file_alloc();
   14770:	e8 04 fd ff ff       	call   14479 <file_alloc>
   14775:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(file){
   14778:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1477c:	0f 84 8e 00 00 00    	je     14810 <sys_open+0xf6>
            fd=task_alloc_fd(file);
   14782:	83 ec 0c             	sub    $0xc,%esp
   14785:	ff 75 f0             	pushl  -0x10(%ebp)
   14788:	e8 67 d8 ff ff       	call   11ff4 <task_alloc_fd>
   1478d:	83 c4 10             	add    $0x10,%esp
   14790:	89 45 f4             	mov    %eax,-0xc(%ebp)
            if(fd<0){
   14793:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14797:	78 7a                	js     14813 <sys_open+0xf9>
        else{
            goto sys_open_failed;
        }

        // 因为有：所以是4 tty:0
        int num=name[4]-'0';
   14799:	8b 45 08             	mov    0x8(%ebp),%eax
   1479c:	83 c0 04             	add    $0x4,%eax
   1479f:	0f b6 00             	movzbl (%eax),%eax
   147a2:	0f be c0             	movsbl %al,%eax
   147a5:	83 e8 30             	sub    $0x30,%eax
   147a8:	89 45 ec             	mov    %eax,-0x14(%ebp)
        int dev_id=dev_open(DEV_TTY,num,0);
   147ab:	83 ec 04             	sub    $0x4,%esp
   147ae:	6a 00                	push   $0x0
   147b0:	ff 75 ec             	pushl  -0x14(%ebp)
   147b3:	6a 01                	push   $0x1
   147b5:	e8 33 f0 ff ff       	call   137ed <dev_open>
   147ba:	83 c4 10             	add    $0x10,%esp
   147bd:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if(dev_id<0){
   147c0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   147c4:	78 50                	js     14816 <sys_open+0xfc>
            goto sys_open_failed;
        }

        file->dev_id=dev_id;
   147c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   147c9:	8b 55 e8             	mov    -0x18(%ebp),%edx
   147cc:	89 50 2c             	mov    %edx,0x2c(%eax)
        file->mode=0;
   147cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
   147d2:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
        file->pos=0;
   147d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   147dc:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
        file->ref=1;
   147e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   147e6:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
        file->type=FILE_TYPE_TTY;
   147ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
   147f0:	c7 40 20 01 00 00 00 	movl   $0x1,0x20(%eax)
        kernel_strncpy(file->file_name,name,FILE_NAME_SIZE);
   147f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   147fa:	83 ec 04             	sub    $0x4,%esp
   147fd:	6a 20                	push   $0x20
   147ff:	ff 75 08             	pushl  0x8(%ebp)
   14802:	50                   	push   %eax
   14803:	e8 73 08 00 00       	call   1507b <kernel_strncpy>
   14808:	83 c4 10             	add    $0x10,%esp
        return fd;
   1480b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1480e:	eb 68                	jmp    14878 <sys_open+0x15e>
            goto sys_open_failed;
   14810:	90                   	nop
   14811:	eb 04                	jmp    14817 <sys_open+0xfd>
                goto sys_open_failed;
   14813:	90                   	nop
   14814:	eb 01                	jmp    14817 <sys_open+0xfd>
            goto sys_open_failed;
   14816:	90                   	nop

sys_open_failed:
        if(file){
   14817:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1481b:	74 0e                	je     1482b <sys_open+0x111>
            file_free(file);
   1481d:	83 ec 0c             	sub    $0xc,%esp
   14820:	ff 75 f0             	pushl  -0x10(%ebp)
   14823:	e8 d5 fc ff ff       	call   144fd <file_free>
   14828:	83 c4 10             	add    $0x10,%esp
        }
        if(fd>=0){
   1482b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1482f:	78 42                	js     14873 <sys_open+0x159>
            task_remove_fd(fd);
   14831:	83 ec 0c             	sub    $0xc,%esp
   14834:	ff 75 f4             	pushl  -0xc(%ebp)
   14837:	e8 09 d8 ff ff       	call   12045 <task_remove_fd>
   1483c:	83 c4 10             	add    $0x10,%esp
   1483f:	eb 32                	jmp    14873 <sys_open+0x159>
        }
        
    }
    else{
        if(name[0]=='/'){
   14841:	8b 45 08             	mov    0x8(%ebp),%eax
   14844:	0f b6 00             	movzbl (%eax),%eax
   14847:	3c 2f                	cmp    $0x2f,%al
   14849:	75 28                	jne    14873 <sys_open+0x159>
            read_disk(5000,80,(uint8_t*)TEMP_ADDR);
   1484b:	83 ec 04             	sub    $0x4,%esp
   1484e:	68 c0 13 05 00       	push   $0x513c0
   14853:	6a 50                	push   $0x50
   14855:	68 88 13 00 00       	push   $0x1388
   1485a:	e8 6b fd ff ff       	call   145ca <read_disk>
   1485f:	83 c4 10             	add    $0x10,%esp
            temp_pos=(uint8_t*)TEMP_ADDR;
   14862:	c7 05 c0 a3 06 00 c0 	movl   $0x513c0,0x6a3c0
   14869:	13 05 00 

            return TEMP_FILE_ID;
   1486c:	b8 64 00 00 00       	mov    $0x64,%eax
   14871:	eb 05                	jmp    14878 <sys_open+0x15e>
        }
    }

    return -1;
   14873:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   14878:	c9                   	leave  
   14879:	c3                   	ret    

0001487a <sys_read>:

int sys_read(int file,char* ptr,int len){
   1487a:	55                   	push   %ebp
   1487b:	89 e5                	mov    %esp,%ebp
   1487d:	83 ec 18             	sub    $0x18,%esp
   if(file==TEMP_FILE_ID){
   14880:	83 7d 08 64          	cmpl   $0x64,0x8(%ebp)
   14884:	75 2d                	jne    148b3 <sys_read+0x39>
        kernel_memcpy(ptr,temp_pos,len);
   14886:	8b 55 10             	mov    0x10(%ebp),%edx
   14889:	a1 c0 a3 06 00       	mov    0x6a3c0,%eax
   1488e:	83 ec 04             	sub    $0x4,%esp
   14891:	52                   	push   %edx
   14892:	50                   	push   %eax
   14893:	ff 75 0c             	pushl  0xc(%ebp)
   14896:	e8 05 09 00 00       	call   151a0 <kernel_memcpy>
   1489b:	83 c4 10             	add    $0x10,%esp
        temp_pos+=len;
   1489e:	8b 15 c0 a3 06 00    	mov    0x6a3c0,%edx
   148a4:	8b 45 10             	mov    0x10(%ebp),%eax
   148a7:	01 d0                	add    %edx,%eax
   148a9:	a3 c0 a3 06 00       	mov    %eax,0x6a3c0

        return len;
   148ae:	8b 45 10             	mov    0x10(%ebp),%eax
   148b1:	eb 4c                	jmp    148ff <sys_read+0x85>
   }
   else{
        file=0;
   148b3:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
        
        file_t* p_file=task_file(file);
   148ba:	83 ec 0c             	sub    $0xc,%esp
   148bd:	ff 75 08             	pushl  0x8(%ebp)
   148c0:	e8 fe d6 ff ff       	call   11fc3 <task_file>
   148c5:	83 c4 10             	add    $0x10,%esp
   148c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(!p_file){
   148cb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   148cf:	75 17                	jne    148e8 <sys_read+0x6e>
            log_printf("file not opened\n");
   148d1:	83 ec 0c             	sub    $0xc,%esp
   148d4:	68 85 64 01 00       	push   $0x16485
   148d9:	e8 34 0f 00 00       	call   15812 <log_printf>
   148de:	83 c4 10             	add    $0x10,%esp
            return -1;
   148e1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   148e6:	eb 17                	jmp    148ff <sys_read+0x85>
        }

        return dev_read(p_file->dev_id,0,ptr,len);
   148e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   148eb:	8b 40 2c             	mov    0x2c(%eax),%eax
   148ee:	ff 75 10             	pushl  0x10(%ebp)
   148f1:	ff 75 0c             	pushl  0xc(%ebp)
   148f4:	6a 00                	push   $0x0
   148f6:	50                   	push   %eax
   148f7:	e8 41 f0 ff ff       	call   1393d <dev_read>
   148fc:	83 c4 10             	add    $0x10,%esp
    }
   
   return -1;
}
   148ff:	c9                   	leave  
   14900:	c3                   	ret    

00014901 <sys_write>:

// 这里file就是fd
int sys_write(int file,char* ptr,int len){
   14901:	55                   	push   %ebp
   14902:	89 e5                	mov    %esp,%ebp
   14904:	83 ec 18             	sub    $0x18,%esp
    // file=0;

    file_t* p_file=task_file(file);
   14907:	83 ec 0c             	sub    $0xc,%esp
   1490a:	ff 75 08             	pushl  0x8(%ebp)
   1490d:	e8 b1 d6 ff ff       	call   11fc3 <task_file>
   14912:	83 c4 10             	add    $0x10,%esp
   14915:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!p_file){
   14918:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1491c:	75 17                	jne    14935 <sys_write+0x34>
        log_printf("file not opened\n");
   1491e:	83 ec 0c             	sub    $0xc,%esp
   14921:	68 85 64 01 00       	push   $0x16485
   14926:	e8 e7 0e 00 00       	call   15812 <log_printf>
   1492b:	83 c4 10             	add    $0x10,%esp
        return -1;
   1492e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14933:	eb 17                	jmp    1494c <sys_write+0x4b>
    }

    return dev_write(p_file->dev_id,0,ptr,len);
   14935:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14938:	8b 40 2c             	mov    0x2c(%eax),%eax
   1493b:	ff 75 10             	pushl  0x10(%ebp)
   1493e:	ff 75 0c             	pushl  0xc(%ebp)
   14941:	6a 00                	push   $0x0
   14943:	50                   	push   %eax
   14944:	e8 40 f0 ff ff       	call   13989 <dev_write>
   14949:	83 c4 10             	add    $0x10,%esp
}
   1494c:	c9                   	leave  
   1494d:	c3                   	ret    

0001494e <sys_lseek>:

int sys_lseek(int file,int ptr,int dir){
   1494e:	55                   	push   %ebp
   1494f:	89 e5                	mov    %esp,%ebp
    if(file==TEMP_FILE_ID){
   14951:	83 7d 08 64          	cmpl   $0x64,0x8(%ebp)
   14955:	75 14                	jne    1496b <sys_lseek+0x1d>

        temp_pos=(uint8_t*)(TEMP_ADDR+ptr);
   14957:	8b 45 0c             	mov    0xc(%ebp),%eax
   1495a:	05 c0 13 05 00       	add    $0x513c0,%eax
   1495f:	a3 c0 a3 06 00       	mov    %eax,0x6a3c0
        return 0;
   14964:	b8 00 00 00 00       	mov    $0x0,%eax
   14969:	eb 05                	jmp    14970 <sys_lseek+0x22>
    }

    return -1;
   1496b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}   
   14970:	5d                   	pop    %ebp
   14971:	c3                   	ret    

00014972 <sys_close>:

int sys_close(int file){
   14972:	55                   	push   %ebp
   14973:	89 e5                	mov    %esp,%ebp
    return 0;
   14975:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1497a:	5d                   	pop    %ebp
   1497b:	c3                   	ret    

0001497c <sys_isatty>:

int sys_isatty(int file){
   1497c:	55                   	push   %ebp
   1497d:	89 e5                	mov    %esp,%ebp
    return -1;
   1497f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   14984:	5d                   	pop    %ebp
   14985:	c3                   	ret    

00014986 <sys_fstat>:

int sys_fstat(int file,struct stat* st){
   14986:	55                   	push   %ebp
   14987:	89 e5                	mov    %esp,%ebp
    return -1;
   14989:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   1498e:	5d                   	pop    %ebp
   1498f:	c3                   	ret    

00014990 <fs_init>:

void fs_init(void){
   14990:	55                   	push   %ebp
   14991:	89 e5                	mov    %esp,%ebp
   14993:	83 ec 08             	sub    $0x8,%esp
    file_table_init();
   14996:	e8 a4 fb ff ff       	call   1453f <file_table_init>
}
   1499b:	90                   	nop
   1499c:	c9                   	leave  
   1499d:	c3                   	ret    

0001499e <sys_dup>:
/**
* @brief 复制文件描述符，返回新的文件描述符
* @return 新的文件描述符，失败返回-1
* @param file 旧的文件描述符
*/
int sys_dup(int file){
   1499e:	55                   	push   %ebp
   1499f:	89 e5                	mov    %esp,%ebp
   149a1:	83 ec 18             	sub    $0x18,%esp
    if((file<0) && (file>=TASK_OFILE_NR)){
   149a4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   149a8:	79 0d                	jns    149b7 <sys_dup+0x19>
   149aa:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   149ae:	7e 07                	jle    149b7 <sys_dup+0x19>
        return -1;
   149b0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   149b5:	eb 6e                	jmp    14a25 <sys_dup+0x87>
    }

    file_t* p_file=task_file(file);
   149b7:	83 ec 0c             	sub    $0xc,%esp
   149ba:	ff 75 08             	pushl  0x8(%ebp)
   149bd:	e8 01 d6 ff ff       	call   11fc3 <task_file>
   149c2:	83 c4 10             	add    $0x10,%esp
   149c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!p_file){
   149c8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   149cc:	75 17                	jne    149e5 <sys_dup+0x47>
        log_printf("file not opened\n");
   149ce:	83 ec 0c             	sub    $0xc,%esp
   149d1:	68 85 64 01 00       	push   $0x16485
   149d6:	e8 37 0e 00 00       	call   15812 <log_printf>
   149db:	83 c4 10             	add    $0x10,%esp
        return -1;
   149de:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   149e3:	eb 40                	jmp    14a25 <sys_dup+0x87>
    }

    int fd=task_alloc_fd(p_file);
   149e5:	83 ec 0c             	sub    $0xc,%esp
   149e8:	ff 75 f4             	pushl  -0xc(%ebp)
   149eb:	e8 04 d6 ff ff       	call   11ff4 <task_alloc_fd>
   149f0:	83 c4 10             	add    $0x10,%esp
   149f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(fd >= 0){
   149f6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   149fa:	78 14                	js     14a10 <sys_dup+0x72>
        p_file->ref++;
   149fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   149ff:	8b 40 28             	mov    0x28(%eax),%eax
   14a02:	8d 50 01             	lea    0x1(%eax),%edx
   14a05:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14a08:	89 50 28             	mov    %edx,0x28(%eax)
        return fd;
   14a0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14a0e:	eb 15                	jmp    14a25 <sys_dup+0x87>
    }

    log_printf("alloc fd failed\n");
   14a10:	83 ec 0c             	sub    $0xc,%esp
   14a13:	68 96 64 01 00       	push   $0x16496
   14a18:	e8 f5 0d 00 00       	call   15812 <log_printf>
   14a1d:	83 c4 10             	add    $0x10,%esp
    return -1;
   14a20:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14a25:	c9                   	leave  
   14a26:	c3                   	ret    

00014a27 <kernel_init>:
#include "ipc/sem.h"
#include "cpu/cpu.h"
#include "dev/kbd.h"
#include "fs/fs.h"

void kernel_init(boot_info_t* boot_info){
   14a27:	55                   	push   %ebp
   14a28:	89 e5                	mov    %esp,%ebp
   14a2a:	83 ec 08             	sub    $0x8,%esp
    irq_init();
   14a2d:	e8 10 db ff ff       	call   12542 <irq_init>

    cpu_init();
   14a32:	e8 ce d7 ff ff       	call   12205 <cpu_init>
    log_init();
   14a37:	e8 a7 0d 00 00       	call   157e3 <log_init>

    memory_init(boot_info);
   14a3c:	83 ec 0c             	sub    $0xc,%esp
   14a3f:	ff 75 08             	pushl  0x8(%ebp)
   14a42:	e8 dc bc ff ff       	call   10723 <memory_init>
   14a47:	83 c4 10             	add    $0x10,%esp
    fs_init();
   14a4a:	e8 41 ff ff ff       	call   14990 <fs_init>
    
    time_init();
   14a4f:	e8 c6 f4 ff ff       	call   13f1a <time_init>

    task_manager_init();
   14a54:	e8 f1 c8 ff ff       	call   1134a <task_manager_init>

}
   14a59:	90                   	nop
   14a5a:	c9                   	leave  
   14a5b:	c3                   	ret    

00014a5c <move_to_first_task>:

void move_to_first_task(void){
   14a5c:	55                   	push   %ebp
   14a5d:	89 e5                	mov    %esp,%ebp
   14a5f:	56                   	push   %esi
   14a60:	53                   	push   %ebx
   14a61:	83 ec 10             	sub    $0x10,%esp
    task_t* curr=task_current();
   14a64:	e8 66 cb ff ff       	call   115cf <task_current>
   14a69:	89 45 f4             	mov    %eax,-0xc(%ebp)
    ASSERT(curr!=0);
   14a6c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14a70:	75 19                	jne    14a8b <move_to_first_task+0x2f>
   14a72:	68 a8 64 01 00       	push   $0x164a8
   14a77:	68 fc 64 01 00       	push   $0x164fc
   14a7c:	6a 23                	push   $0x23
   14a7e:	68 b0 64 01 00       	push   $0x164b0
   14a83:	e8 ba 0a 00 00       	call   15542 <panic>
   14a88:	83 c4 10             	add    $0x10,%esp
    tss_t* tss=&(curr->tss);
   14a8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14a8e:	05 58 02 00 00       	add    $0x258,%eax
   14a93:	89 45 f0             	mov    %eax,-0x10(%ebp)
        "push %[eflags]\n\t"
        "push %[cs]\n\t"
        "push %[eip]\n\t"
        "iret"
        :
        :[ss]"r"(tss->ss),[esp]"r"(tss->esp),[eflags]"r"(tss->eflags),[cs]"r"(tss->cs),
   14a96:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14a99:	8b 40 50             	mov    0x50(%eax),%eax
   14a9c:	8b 55 f0             	mov    -0x10(%ebp),%edx
   14a9f:	8b 52 38             	mov    0x38(%edx),%edx
   14aa2:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   14aa5:	8b 49 24             	mov    0x24(%ecx),%ecx
   14aa8:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   14aab:	8b 5b 4c             	mov    0x4c(%ebx),%ebx
         [eip]"r"(tss->eip)
   14aae:	8b 75 f0             	mov    -0x10(%ebp),%esi
   14ab1:	8b 76 20             	mov    0x20(%esi),%esi
    __asm__ __volatile__(
   14ab4:	50                   	push   %eax
   14ab5:	52                   	push   %edx
   14ab6:	51                   	push   %ecx
   14ab7:	53                   	push   %ebx
   14ab8:	56                   	push   %esi
   14ab9:	cf                   	iret   
    );
}
   14aba:	90                   	nop
   14abb:	8d 65 f8             	lea    -0x8(%ebp),%esp
   14abe:	5b                   	pop    %ebx
   14abf:	5e                   	pop    %esi
   14ac0:	5d                   	pop    %ebp
   14ac1:	c3                   	ret    

00014ac2 <init_main>:

void init_main(){
   14ac2:	55                   	push   %ebp
   14ac3:	89 e5                	mov    %esp,%ebp
   14ac5:	83 ec 18             	sub    $0x18,%esp
    int count=0;
   14ac8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    log_printf("Kernel is running....");
   14acf:	83 ec 0c             	sub    $0xc,%esp
   14ad2:	68 e3 64 01 00       	push   $0x164e3
   14ad7:	e8 36 0d 00 00       	call   15812 <log_printf>
   14adc:	83 c4 10             	add    $0x10,%esp
    task_first_init();
   14adf:	e8 4d c9 ff ff       	call   11431 <task_first_init>
    move_to_first_task();
   14ae4:	e8 73 ff ff ff       	call   14a5c <move_to_first_task>
}
   14ae9:	90                   	nop
   14aea:	c9                   	leave  
   14aeb:	c3                   	ret    

00014aec <list_count>:
static inline int list_count(list_t* list){
   14aec:	55                   	push   %ebp
   14aed:	89 e5                	mov    %esp,%ebp
    return list->count;
   14aef:	8b 45 08             	mov    0x8(%ebp),%eax
   14af2:	8b 40 08             	mov    0x8(%eax),%eax
}
   14af5:	5d                   	pop    %ebp
   14af6:	c3                   	ret    

00014af7 <mutex_init>:
#include "ipc/mutex.h"

void mutex_init(mutex_t* mutex){
   14af7:	55                   	push   %ebp
   14af8:	89 e5                	mov    %esp,%ebp
   14afa:	83 ec 08             	sub    $0x8,%esp
    mutex->locked_count=0;
   14afd:	8b 45 08             	mov    0x8(%ebp),%eax
   14b00:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    mutex->owner=(task_t*)0;
   14b07:	8b 45 08             	mov    0x8(%ebp),%eax
   14b0a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    list_init(&mutex->wait_list); 
   14b10:	8b 45 08             	mov    0x8(%ebp),%eax
   14b13:	83 c0 08             	add    $0x8,%eax
   14b16:	83 ec 0c             	sub    $0xc,%esp
   14b19:	50                   	push   %eax
   14b1a:	e8 df 0a 00 00       	call   155fe <list_init>
   14b1f:	83 c4 10             	add    $0x10,%esp
}
   14b22:	90                   	nop
   14b23:	c9                   	leave  
   14b24:	c3                   	ret    

00014b25 <mutex_lock>:

void mutex_lock(mutex_t* mutex){
   14b25:	55                   	push   %ebp
   14b26:	89 e5                	mov    %esp,%ebp
   14b28:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   14b2b:	e8 dd e0 ff ff       	call   12c0d <irq_enter_protection>
   14b30:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t* curr=task_current();
   14b33:	e8 97 ca ff ff       	call   115cf <task_current>
   14b38:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(mutex->locked_count==0){
   14b3b:	8b 45 08             	mov    0x8(%ebp),%eax
   14b3e:	8b 40 04             	mov    0x4(%eax),%eax
   14b41:	85 c0                	test   %eax,%eax
   14b43:	75 14                	jne    14b59 <mutex_lock+0x34>
        mutex->locked_count=1;
   14b45:	8b 45 08             	mov    0x8(%ebp),%eax
   14b48:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
        mutex->owner=curr;
   14b4f:	8b 45 08             	mov    0x8(%ebp),%eax
   14b52:	8b 55 f0             	mov    -0x10(%ebp),%edx
   14b55:	89 10                	mov    %edx,(%eax)
   14b57:	eb 4a                	jmp    14ba3 <mutex_lock+0x7e>
    }
    else if(mutex->owner==curr){
   14b59:	8b 45 08             	mov    0x8(%ebp),%eax
   14b5c:	8b 00                	mov    (%eax),%eax
   14b5e:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   14b61:	75 11                	jne    14b74 <mutex_lock+0x4f>
        mutex->locked_count++;
   14b63:	8b 45 08             	mov    0x8(%ebp),%eax
   14b66:	8b 40 04             	mov    0x4(%eax),%eax
   14b69:	8d 50 01             	lea    0x1(%eax),%edx
   14b6c:	8b 45 08             	mov    0x8(%ebp),%eax
   14b6f:	89 50 04             	mov    %edx,0x4(%eax)
   14b72:	eb 2f                	jmp    14ba3 <mutex_lock+0x7e>
    }
    else{
        task_set_block(curr);
   14b74:	83 ec 0c             	sub    $0xc,%esp
   14b77:	ff 75 f0             	pushl  -0x10(%ebp)
   14b7a:	e8 de c9 ff ff       	call   1155d <task_set_block>
   14b7f:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&mutex->wait_list,&curr->wait_node);
   14b82:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14b85:	8d 90 50 02 00 00    	lea    0x250(%eax),%edx
   14b8b:	8b 45 08             	mov    0x8(%ebp),%eax
   14b8e:	83 c0 08             	add    $0x8,%eax
   14b91:	83 ec 08             	sub    $0x8,%esp
   14b94:	52                   	push   %edx
   14b95:	50                   	push   %eax
   14b96:	e8 e7 0a 00 00       	call   15682 <list_insert_last>
   14b9b:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   14b9e:	e8 97 ca ff ff       	call   1163a <task_dispatch>
    }
    irq_leave_protection(state);
   14ba3:	83 ec 0c             	sub    $0xc,%esp
   14ba6:	ff 75 f4             	pushl  -0xc(%ebp)
   14ba9:	e8 77 e0 ff ff       	call   12c25 <irq_leave_protection>
   14bae:	83 c4 10             	add    $0x10,%esp
}
   14bb1:	90                   	nop
   14bb2:	c9                   	leave  
   14bb3:	c3                   	ret    

00014bb4 <mutex_unlock>:

void mutex_unlock(mutex_t* mutex){
   14bb4:	55                   	push   %ebp
   14bb5:	89 e5                	mov    %esp,%ebp
   14bb7:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   14bba:	e8 4e e0 ff ff       	call   12c0d <irq_enter_protection>
   14bbf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t* curr=task_current();
   14bc2:	e8 08 ca ff ff       	call   115cf <task_current>
   14bc7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(mutex->owner==curr){
   14bca:	8b 45 08             	mov    0x8(%ebp),%eax
   14bcd:	8b 00                	mov    (%eax),%eax
   14bcf:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   14bd2:	0f 85 8a 00 00 00    	jne    14c62 <mutex_unlock+0xae>
        if(--mutex->locked_count==0){
   14bd8:	8b 45 08             	mov    0x8(%ebp),%eax
   14bdb:	8b 40 04             	mov    0x4(%eax),%eax
   14bde:	8d 50 ff             	lea    -0x1(%eax),%edx
   14be1:	8b 45 08             	mov    0x8(%ebp),%eax
   14be4:	89 50 04             	mov    %edx,0x4(%eax)
   14be7:	8b 45 08             	mov    0x8(%ebp),%eax
   14bea:	8b 40 04             	mov    0x4(%eax),%eax
   14bed:	85 c0                	test   %eax,%eax
   14bef:	75 71                	jne    14c62 <mutex_unlock+0xae>
            mutex->owner=(task_t*)0;
   14bf1:	8b 45 08             	mov    0x8(%ebp),%eax
   14bf4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
            if(list_count(&mutex->wait_list)){
   14bfa:	8b 45 08             	mov    0x8(%ebp),%eax
   14bfd:	83 c0 08             	add    $0x8,%eax
   14c00:	83 ec 0c             	sub    $0xc,%esp
   14c03:	50                   	push   %eax
   14c04:	e8 e3 fe ff ff       	call   14aec <list_count>
   14c09:	83 c4 10             	add    $0x10,%esp
   14c0c:	85 c0                	test   %eax,%eax
   14c0e:	74 52                	je     14c62 <mutex_unlock+0xae>
                list_node_t* node=list_remove_first(&mutex->wait_list);
   14c10:	8b 45 08             	mov    0x8(%ebp),%eax
   14c13:	83 c0 08             	add    $0x8,%eax
   14c16:	83 ec 0c             	sub    $0xc,%esp
   14c19:	50                   	push   %eax
   14c1a:	e8 c7 0a 00 00       	call   156e6 <list_remove_first>
   14c1f:	83 c4 10             	add    $0x10,%esp
   14c22:	89 45 ec             	mov    %eax,-0x14(%ebp)
                task_t* task=list_node_parent(node,task_t,wait_node);
   14c25:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   14c29:	74 0a                	je     14c35 <mutex_unlock+0x81>
   14c2b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14c2e:	2d 50 02 00 00       	sub    $0x250,%eax
   14c33:	eb 05                	jmp    14c3a <mutex_unlock+0x86>
   14c35:	b8 00 00 00 00       	mov    $0x0,%eax
   14c3a:	89 45 e8             	mov    %eax,-0x18(%ebp)
                task_set_ready(task);
   14c3d:	83 ec 0c             	sub    $0xc,%esp
   14c40:	ff 75 e8             	pushl  -0x18(%ebp)
   14c43:	e8 df c8 ff ff       	call   11527 <task_set_ready>
   14c48:	83 c4 10             	add    $0x10,%esp
                mutex->locked_count=1;
   14c4b:	8b 45 08             	mov    0x8(%ebp),%eax
   14c4e:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
                mutex->owner=task;
   14c55:	8b 45 08             	mov    0x8(%ebp),%eax
   14c58:	8b 55 e8             	mov    -0x18(%ebp),%edx
   14c5b:	89 10                	mov    %edx,(%eax)
                task_dispatch();
   14c5d:	e8 d8 c9 ff ff       	call   1163a <task_dispatch>
            }
        }
    }
    irq_leave_protection(state);
   14c62:	83 ec 0c             	sub    $0xc,%esp
   14c65:	ff 75 f4             	pushl  -0xc(%ebp)
   14c68:	e8 b8 df ff ff       	call   12c25 <irq_leave_protection>
   14c6d:	83 c4 10             	add    $0x10,%esp
   14c70:	90                   	nop
   14c71:	c9                   	leave  
   14c72:	c3                   	ret    

00014c73 <list_count>:
static inline int list_count(list_t* list){
   14c73:	55                   	push   %ebp
   14c74:	89 e5                	mov    %esp,%ebp
    return list->count;
   14c76:	8b 45 08             	mov    0x8(%ebp),%eax
   14c79:	8b 40 08             	mov    0x8(%eax),%eax
}
   14c7c:	5d                   	pop    %ebp
   14c7d:	c3                   	ret    

00014c7e <sem_init>:
#include "ipc/sem.h"

void sem_init(sem_t* sem,int init_count){
   14c7e:	55                   	push   %ebp
   14c7f:	89 e5                	mov    %esp,%ebp
   14c81:	83 ec 08             	sub    $0x8,%esp
    sem->count=init_count;
   14c84:	8b 45 08             	mov    0x8(%ebp),%eax
   14c87:	8b 55 0c             	mov    0xc(%ebp),%edx
   14c8a:	89 10                	mov    %edx,(%eax)
    list_init(&sem->wait_list);
   14c8c:	8b 45 08             	mov    0x8(%ebp),%eax
   14c8f:	83 c0 04             	add    $0x4,%eax
   14c92:	83 ec 0c             	sub    $0xc,%esp
   14c95:	50                   	push   %eax
   14c96:	e8 63 09 00 00       	call   155fe <list_init>
   14c9b:	83 c4 10             	add    $0x10,%esp
}
   14c9e:	90                   	nop
   14c9f:	c9                   	leave  
   14ca0:	c3                   	ret    

00014ca1 <sem_wait>:

void sem_wait(sem_t* sem){
   14ca1:	55                   	push   %ebp
   14ca2:	89 e5                	mov    %esp,%ebp
   14ca4:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   14ca7:	e8 61 df ff ff       	call   12c0d <irq_enter_protection>
   14cac:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(sem->count>0){
   14caf:	8b 45 08             	mov    0x8(%ebp),%eax
   14cb2:	8b 00                	mov    (%eax),%eax
   14cb4:	85 c0                	test   %eax,%eax
   14cb6:	7e 0f                	jle    14cc7 <sem_wait+0x26>
        sem->count--;
   14cb8:	8b 45 08             	mov    0x8(%ebp),%eax
   14cbb:	8b 00                	mov    (%eax),%eax
   14cbd:	8d 50 ff             	lea    -0x1(%eax),%edx
   14cc0:	8b 45 08             	mov    0x8(%ebp),%eax
   14cc3:	89 10                	mov    %edx,(%eax)
   14cc5:	eb 37                	jmp    14cfe <sem_wait+0x5d>
    }
    else{
        task_t* curr=task_current();
   14cc7:	e8 03 c9 ff ff       	call   115cf <task_current>
   14ccc:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_set_block(curr);
   14ccf:	83 ec 0c             	sub    $0xc,%esp
   14cd2:	ff 75 f0             	pushl  -0x10(%ebp)
   14cd5:	e8 83 c8 ff ff       	call   1155d <task_set_block>
   14cda:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&sem->wait_list,&curr->wait_node);
   14cdd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14ce0:	8d 90 50 02 00 00    	lea    0x250(%eax),%edx
   14ce6:	8b 45 08             	mov    0x8(%ebp),%eax
   14ce9:	83 c0 04             	add    $0x4,%eax
   14cec:	83 ec 08             	sub    $0x8,%esp
   14cef:	52                   	push   %edx
   14cf0:	50                   	push   %eax
   14cf1:	e8 8c 09 00 00       	call   15682 <list_insert_last>
   14cf6:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   14cf9:	e8 3c c9 ff ff       	call   1163a <task_dispatch>
    }
    irq_leave_protection(state);
   14cfe:	83 ec 0c             	sub    $0xc,%esp
   14d01:	ff 75 f4             	pushl  -0xc(%ebp)
   14d04:	e8 1c df ff ff       	call   12c25 <irq_leave_protection>
   14d09:	83 c4 10             	add    $0x10,%esp
}
   14d0c:	90                   	nop
   14d0d:	c9                   	leave  
   14d0e:	c3                   	ret    

00014d0f <sem_notify>:

void sem_notify(sem_t* sem){
   14d0f:	55                   	push   %ebp
   14d10:	89 e5                	mov    %esp,%ebp
   14d12:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   14d15:	e8 f3 de ff ff       	call   12c0d <irq_enter_protection>
   14d1a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(list_count(&sem->wait_list)){
   14d1d:	8b 45 08             	mov    0x8(%ebp),%eax
   14d20:	83 c0 04             	add    $0x4,%eax
   14d23:	83 ec 0c             	sub    $0xc,%esp
   14d26:	50                   	push   %eax
   14d27:	e8 47 ff ff ff       	call   14c73 <list_count>
   14d2c:	83 c4 10             	add    $0x10,%esp
   14d2f:	85 c0                	test   %eax,%eax
   14d31:	74 42                	je     14d75 <sem_notify+0x66>
        list_node_t* node=list_remove_first(&sem->wait_list);
   14d33:	8b 45 08             	mov    0x8(%ebp),%eax
   14d36:	83 c0 04             	add    $0x4,%eax
   14d39:	83 ec 0c             	sub    $0xc,%esp
   14d3c:	50                   	push   %eax
   14d3d:	e8 a4 09 00 00       	call   156e6 <list_remove_first>
   14d42:	83 c4 10             	add    $0x10,%esp
   14d45:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_t* task=list_node_parent(node,task_t,wait_node);
   14d48:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14d4c:	74 0a                	je     14d58 <sem_notify+0x49>
   14d4e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14d51:	2d 50 02 00 00       	sub    $0x250,%eax
   14d56:	eb 05                	jmp    14d5d <sem_notify+0x4e>
   14d58:	b8 00 00 00 00       	mov    $0x0,%eax
   14d5d:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_set_ready(task);
   14d60:	83 ec 0c             	sub    $0xc,%esp
   14d63:	ff 75 ec             	pushl  -0x14(%ebp)
   14d66:	e8 bc c7 ff ff       	call   11527 <task_set_ready>
   14d6b:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   14d6e:	e8 c7 c8 ff ff       	call   1163a <task_dispatch>
   14d73:	eb 0d                	jmp    14d82 <sem_notify+0x73>
    }
    else{
        sem->count++;
   14d75:	8b 45 08             	mov    0x8(%ebp),%eax
   14d78:	8b 00                	mov    (%eax),%eax
   14d7a:	8d 50 01             	lea    0x1(%eax),%edx
   14d7d:	8b 45 08             	mov    0x8(%ebp),%eax
   14d80:	89 10                	mov    %edx,(%eax)
    }
    irq_leave_protection(state);
   14d82:	83 ec 0c             	sub    $0xc,%esp
   14d85:	ff 75 f4             	pushl  -0xc(%ebp)
   14d88:	e8 98 de ff ff       	call   12c25 <irq_leave_protection>
   14d8d:	83 c4 10             	add    $0x10,%esp
}
   14d90:	90                   	nop
   14d91:	c9                   	leave  
   14d92:	c3                   	ret    

00014d93 <sem_count>:

int sem_count(sem_t* sem){
   14d93:	55                   	push   %ebp
   14d94:	89 e5                	mov    %esp,%ebp
   14d96:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   14d99:	e8 6f de ff ff       	call   12c0d <irq_enter_protection>
   14d9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int count=sem->count;
   14da1:	8b 45 08             	mov    0x8(%ebp),%eax
   14da4:	8b 00                	mov    (%eax),%eax
   14da6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    irq_leave_protection(state);
   14da9:	83 ec 0c             	sub    $0xc,%esp
   14dac:	ff 75 f4             	pushl  -0xc(%ebp)
   14daf:	e8 71 de ff ff       	call   12c25 <irq_leave_protection>
   14db4:	83 c4 10             	add    $0x10,%esp
    return count;
   14db7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14dba:	c9                   	leave  
   14dbb:	c3                   	ret    

00014dbc <bitmap_byte_count>:
#include "tools/bitmap.h"
#include "tools/klib.h"

int bitmap_byte_count(int bit_count){
   14dbc:	55                   	push   %ebp
   14dbd:	89 e5                	mov    %esp,%ebp
    return (bit_count+8-1)/8;
   14dbf:	8b 45 08             	mov    0x8(%ebp),%eax
   14dc2:	83 c0 07             	add    $0x7,%eax
   14dc5:	8d 50 07             	lea    0x7(%eax),%edx
   14dc8:	85 c0                	test   %eax,%eax
   14dca:	0f 48 c2             	cmovs  %edx,%eax
   14dcd:	c1 f8 03             	sar    $0x3,%eax
}
   14dd0:	5d                   	pop    %ebp
   14dd1:	c3                   	ret    

00014dd2 <bitmap_init>:

void bitmap_init(bitmap_t* bitmap,uint8_t* bits,int count,int init_bit){
   14dd2:	55                   	push   %ebp
   14dd3:	89 e5                	mov    %esp,%ebp
   14dd5:	83 ec 18             	sub    $0x18,%esp
    bitmap->bit_count=count;
   14dd8:	8b 45 08             	mov    0x8(%ebp),%eax
   14ddb:	8b 55 10             	mov    0x10(%ebp),%edx
   14dde:	89 10                	mov    %edx,(%eax)
    bitmap->bits=bits;
   14de0:	8b 45 08             	mov    0x8(%ebp),%eax
   14de3:	8b 55 0c             	mov    0xc(%ebp),%edx
   14de6:	89 50 04             	mov    %edx,0x4(%eax)
    int bytes=bitmap_byte_count(bitmap->bit_count);
   14de9:	8b 45 08             	mov    0x8(%ebp),%eax
   14dec:	8b 00                	mov    (%eax),%eax
   14dee:	50                   	push   %eax
   14def:	e8 c8 ff ff ff       	call   14dbc <bitmap_byte_count>
   14df4:	83 c4 04             	add    $0x4,%esp
   14df7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kernel_memset(bitmap->bits,init_bit? 0xFF : 0,bytes);
   14dfa:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   14dfe:	74 07                	je     14e07 <bitmap_init+0x35>
   14e00:	ba ff 00 00 00       	mov    $0xff,%edx
   14e05:	eb 05                	jmp    14e0c <bitmap_init+0x3a>
   14e07:	ba 00 00 00 00       	mov    $0x0,%edx
   14e0c:	8b 45 08             	mov    0x8(%ebp),%eax
   14e0f:	8b 40 04             	mov    0x4(%eax),%eax
   14e12:	83 ec 04             	sub    $0x4,%esp
   14e15:	ff 75 f4             	pushl  -0xc(%ebp)
   14e18:	52                   	push   %edx
   14e19:	50                   	push   %eax
   14e1a:	e8 d0 03 00 00       	call   151ef <kernel_memset>
   14e1f:	83 c4 10             	add    $0x10,%esp
}
   14e22:	90                   	nop
   14e23:	c9                   	leave  
   14e24:	c3                   	ret    

00014e25 <bitmap_get_bit>:

int bitmap_get_bit(bitmap_t* bitmap,int index){
   14e25:	55                   	push   %ebp
   14e26:	89 e5                	mov    %esp,%ebp
   14e28:	53                   	push   %ebx
    if(index>bitmap->bit_count) return -1;
   14e29:	8b 45 08             	mov    0x8(%ebp),%eax
   14e2c:	8b 00                	mov    (%eax),%eax
   14e2e:	39 45 0c             	cmp    %eax,0xc(%ebp)
   14e31:	7e 07                	jle    14e3a <bitmap_get_bit+0x15>
   14e33:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14e38:	eb 37                	jmp    14e71 <bitmap_get_bit+0x4c>
    return bitmap->bits[index/8] & (1<<(index % 8));
   14e3a:	8b 45 08             	mov    0x8(%ebp),%eax
   14e3d:	8b 50 04             	mov    0x4(%eax),%edx
   14e40:	8b 45 0c             	mov    0xc(%ebp),%eax
   14e43:	8d 48 07             	lea    0x7(%eax),%ecx
   14e46:	85 c0                	test   %eax,%eax
   14e48:	0f 48 c1             	cmovs  %ecx,%eax
   14e4b:	c1 f8 03             	sar    $0x3,%eax
   14e4e:	01 d0                	add    %edx,%eax
   14e50:	0f b6 00             	movzbl (%eax),%eax
   14e53:	0f b6 d8             	movzbl %al,%ebx
   14e56:	8b 45 0c             	mov    0xc(%ebp),%eax
   14e59:	99                   	cltd   
   14e5a:	c1 ea 1d             	shr    $0x1d,%edx
   14e5d:	01 d0                	add    %edx,%eax
   14e5f:	83 e0 07             	and    $0x7,%eax
   14e62:	29 d0                	sub    %edx,%eax
   14e64:	ba 01 00 00 00       	mov    $0x1,%edx
   14e69:	89 c1                	mov    %eax,%ecx
   14e6b:	d3 e2                	shl    %cl,%edx
   14e6d:	89 d0                	mov    %edx,%eax
   14e6f:	21 d8                	and    %ebx,%eax
}
   14e71:	5b                   	pop    %ebx
   14e72:	5d                   	pop    %ebp
   14e73:	c3                   	ret    

00014e74 <bitmap_set_bit>:

void bitmap_set_bit(bitmap_t* bitmap,int index,int count,int bit){
   14e74:	55                   	push   %ebp
   14e75:	89 e5                	mov    %esp,%ebp
   14e77:	56                   	push   %esi
   14e78:	53                   	push   %ebx
   14e79:	83 ec 10             	sub    $0x10,%esp
    if(index+count>bitmap->bit_count) return;
   14e7c:	8b 55 0c             	mov    0xc(%ebp),%edx
   14e7f:	8b 45 10             	mov    0x10(%ebp),%eax
   14e82:	01 c2                	add    %eax,%edx
   14e84:	8b 45 08             	mov    0x8(%ebp),%eax
   14e87:	8b 00                	mov    (%eax),%eax
   14e89:	39 c2                	cmp    %eax,%edx
   14e8b:	0f 8f c6 00 00 00    	jg     14f57 <bitmap_set_bit+0xe3>
    for(int i=0;(i<count) && (index<bitmap->bit_count);i++,index++){
   14e91:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14e98:	e9 a2 00 00 00       	jmp    14f3f <bitmap_set_bit+0xcb>
        if(bit){
   14e9d:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   14ea1:	74 4a                	je     14eed <bitmap_set_bit+0x79>
            bitmap->bits[index/8] |=(1<<(index%8));
   14ea3:	8b 45 08             	mov    0x8(%ebp),%eax
   14ea6:	8b 50 04             	mov    0x4(%eax),%edx
   14ea9:	8b 45 0c             	mov    0xc(%ebp),%eax
   14eac:	8d 48 07             	lea    0x7(%eax),%ecx
   14eaf:	85 c0                	test   %eax,%eax
   14eb1:	0f 48 c1             	cmovs  %ecx,%eax
   14eb4:	c1 f8 03             	sar    $0x3,%eax
   14eb7:	89 c3                	mov    %eax,%ebx
   14eb9:	89 d8                	mov    %ebx,%eax
   14ebb:	01 d0                	add    %edx,%eax
   14ebd:	0f b6 00             	movzbl (%eax),%eax
   14ec0:	89 c6                	mov    %eax,%esi
   14ec2:	8b 45 0c             	mov    0xc(%ebp),%eax
   14ec5:	99                   	cltd   
   14ec6:	c1 ea 1d             	shr    $0x1d,%edx
   14ec9:	01 d0                	add    %edx,%eax
   14ecb:	83 e0 07             	and    $0x7,%eax
   14ece:	29 d0                	sub    %edx,%eax
   14ed0:	ba 01 00 00 00       	mov    $0x1,%edx
   14ed5:	89 c1                	mov    %eax,%ecx
   14ed7:	d3 e2                	shl    %cl,%edx
   14ed9:	89 d0                	mov    %edx,%eax
   14edb:	89 f2                	mov    %esi,%edx
   14edd:	09 c2                	or     %eax,%edx
   14edf:	8b 45 08             	mov    0x8(%ebp),%eax
   14ee2:	8b 40 04             	mov    0x4(%eax),%eax
   14ee5:	89 d9                	mov    %ebx,%ecx
   14ee7:	01 c8                	add    %ecx,%eax
   14ee9:	88 10                	mov    %dl,(%eax)
   14eeb:	eb 4a                	jmp    14f37 <bitmap_set_bit+0xc3>
        }
        else{
            bitmap->bits[index/8]&=~(1<<(index%8));
   14eed:	8b 45 08             	mov    0x8(%ebp),%eax
   14ef0:	8b 50 04             	mov    0x4(%eax),%edx
   14ef3:	8b 45 0c             	mov    0xc(%ebp),%eax
   14ef6:	8d 48 07             	lea    0x7(%eax),%ecx
   14ef9:	85 c0                	test   %eax,%eax
   14efb:	0f 48 c1             	cmovs  %ecx,%eax
   14efe:	c1 f8 03             	sar    $0x3,%eax
   14f01:	89 c3                	mov    %eax,%ebx
   14f03:	89 d8                	mov    %ebx,%eax
   14f05:	01 d0                	add    %edx,%eax
   14f07:	0f b6 00             	movzbl (%eax),%eax
   14f0a:	89 c6                	mov    %eax,%esi
   14f0c:	8b 45 0c             	mov    0xc(%ebp),%eax
   14f0f:	99                   	cltd   
   14f10:	c1 ea 1d             	shr    $0x1d,%edx
   14f13:	01 d0                	add    %edx,%eax
   14f15:	83 e0 07             	and    $0x7,%eax
   14f18:	29 d0                	sub    %edx,%eax
   14f1a:	ba 01 00 00 00       	mov    $0x1,%edx
   14f1f:	89 c1                	mov    %eax,%ecx
   14f21:	d3 e2                	shl    %cl,%edx
   14f23:	89 d0                	mov    %edx,%eax
   14f25:	f7 d0                	not    %eax
   14f27:	89 f2                	mov    %esi,%edx
   14f29:	21 c2                	and    %eax,%edx
   14f2b:	8b 45 08             	mov    0x8(%ebp),%eax
   14f2e:	8b 40 04             	mov    0x4(%eax),%eax
   14f31:	89 d9                	mov    %ebx,%ecx
   14f33:	01 c8                	add    %ecx,%eax
   14f35:	88 10                	mov    %dl,(%eax)
    for(int i=0;(i<count) && (index<bitmap->bit_count);i++,index++){
   14f37:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14f3b:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
   14f3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14f42:	3b 45 10             	cmp    0x10(%ebp),%eax
   14f45:	7d 11                	jge    14f58 <bitmap_set_bit+0xe4>
   14f47:	8b 45 08             	mov    0x8(%ebp),%eax
   14f4a:	8b 00                	mov    (%eax),%eax
   14f4c:	39 45 0c             	cmp    %eax,0xc(%ebp)
   14f4f:	0f 8c 48 ff ff ff    	jl     14e9d <bitmap_set_bit+0x29>
   14f55:	eb 01                	jmp    14f58 <bitmap_set_bit+0xe4>
    if(index+count>bitmap->bit_count) return;
   14f57:	90                   	nop
        }
    }
}
   14f58:	83 c4 10             	add    $0x10,%esp
   14f5b:	5b                   	pop    %ebx
   14f5c:	5e                   	pop    %esi
   14f5d:	5d                   	pop    %ebp
   14f5e:	c3                   	ret    

00014f5f <bitmap_is_set>:

int bitmap_is_set(bitmap_t* bitmap,int index){
   14f5f:	55                   	push   %ebp
   14f60:	89 e5                	mov    %esp,%ebp
    return bitmap_get_bit(bitmap,index) ? 1 : 0;
   14f62:	ff 75 0c             	pushl  0xc(%ebp)
   14f65:	ff 75 08             	pushl  0x8(%ebp)
   14f68:	e8 b8 fe ff ff       	call   14e25 <bitmap_get_bit>
   14f6d:	83 c4 08             	add    $0x8,%esp
   14f70:	85 c0                	test   %eax,%eax
   14f72:	0f 95 c0             	setne  %al
   14f75:	0f b6 c0             	movzbl %al,%eax
}
   14f78:	c9                   	leave  
   14f79:	c3                   	ret    

00014f7a <bitmap_alloc_nbits>:

int bitmap_alloc_nbits(bitmap_t* bitmap,int bit,int count){
   14f7a:	55                   	push   %ebp
   14f7b:	89 e5                	mov    %esp,%ebp
   14f7d:	83 ec 10             	sub    $0x10,%esp
    int search_idx = 0;
   14f80:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    int ok_idx = -1;
   14f87:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)

    while (search_idx < bitmap->bit_count) {
   14f8e:	e9 85 00 00 00       	jmp    15018 <bitmap_alloc_nbits+0x9e>
        if (bitmap_get_bit(bitmap, search_idx) != bit) {
   14f93:	ff 75 fc             	pushl  -0x4(%ebp)
   14f96:	ff 75 08             	pushl  0x8(%ebp)
   14f99:	e8 87 fe ff ff       	call   14e25 <bitmap_get_bit>
   14f9e:	83 c4 08             	add    $0x8,%esp
   14fa1:	39 45 0c             	cmp    %eax,0xc(%ebp)
   14fa4:	74 06                	je     14fac <bitmap_alloc_nbits+0x32>
            search_idx++;
   14fa6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
            continue;
   14faa:	eb 6c                	jmp    15018 <bitmap_alloc_nbits+0x9e>
        }

        ok_idx = search_idx;
   14fac:	8b 45 fc             	mov    -0x4(%ebp),%eax
   14faf:	89 45 f8             	mov    %eax,-0x8(%ebp)

        int i;
        for (i = 1; (i < count) && (search_idx < bitmap->bit_count); i++) {
   14fb2:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
   14fb9:	eb 27                	jmp    14fe2 <bitmap_alloc_nbits+0x68>
            if (bitmap_get_bit(bitmap, search_idx++) != bit) {
   14fbb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   14fbe:	8d 50 01             	lea    0x1(%eax),%edx
   14fc1:	89 55 fc             	mov    %edx,-0x4(%ebp)
   14fc4:	50                   	push   %eax
   14fc5:	ff 75 08             	pushl  0x8(%ebp)
   14fc8:	e8 58 fe ff ff       	call   14e25 <bitmap_get_bit>
   14fcd:	83 c4 08             	add    $0x8,%esp
   14fd0:	39 45 0c             	cmp    %eax,0xc(%ebp)
   14fd3:	74 09                	je     14fde <bitmap_alloc_nbits+0x64>
                ok_idx = -1;
   14fd5:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)
                break;
   14fdc:	eb 16                	jmp    14ff4 <bitmap_alloc_nbits+0x7a>
        for (i = 1; (i < count) && (search_idx < bitmap->bit_count); i++) {
   14fde:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14fe2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14fe5:	3b 45 10             	cmp    0x10(%ebp),%eax
   14fe8:	7d 0a                	jge    14ff4 <bitmap_alloc_nbits+0x7a>
   14fea:	8b 45 08             	mov    0x8(%ebp),%eax
   14fed:	8b 00                	mov    (%eax),%eax
   14fef:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   14ff2:	7c c7                	jl     14fbb <bitmap_alloc_nbits+0x41>
            }
        }
        
        if (i >= count) {
   14ff4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14ff7:	3b 45 10             	cmp    0x10(%ebp),%eax
   14ffa:	7c 1c                	jl     15018 <bitmap_alloc_nbits+0x9e>
            bitmap_set_bit(bitmap, ok_idx, count, ~bit);
   14ffc:	8b 45 0c             	mov    0xc(%ebp),%eax
   14fff:	f7 d0                	not    %eax
   15001:	50                   	push   %eax
   15002:	ff 75 10             	pushl  0x10(%ebp)
   15005:	ff 75 f8             	pushl  -0x8(%ebp)
   15008:	ff 75 08             	pushl  0x8(%ebp)
   1500b:	e8 64 fe ff ff       	call   14e74 <bitmap_set_bit>
   15010:	83 c4 10             	add    $0x10,%esp
            return ok_idx;
   15013:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15016:	eb 13                	jmp    1502b <bitmap_alloc_nbits+0xb1>
    while (search_idx < bitmap->bit_count) {
   15018:	8b 45 08             	mov    0x8(%ebp),%eax
   1501b:	8b 00                	mov    (%eax),%eax
   1501d:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   15020:	0f 8c 6d ff ff ff    	jl     14f93 <bitmap_alloc_nbits+0x19>
        }
    }

    return -1;
   15026:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1502b:	c9                   	leave  
   1502c:	c3                   	ret    

0001502d <hlt>:
static inline void hlt(void){
   1502d:	55                   	push   %ebp
   1502e:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile("hlt");
   15030:	f4                   	hlt    
}
   15031:	90                   	nop
   15032:	5d                   	pop    %ebp
   15033:	c3                   	ret    

00015034 <kernel_strcpy>:
#include "tools/klib.h"

// 复制字符串
void kernel_strcpy(char* dest,const char* src){
   15034:	55                   	push   %ebp
   15035:	89 e5                	mov    %esp,%ebp
    if(!dest || !src){
   15037:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1503b:	74 3b                	je     15078 <kernel_strcpy+0x44>
   1503d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   15041:	74 35                	je     15078 <kernel_strcpy+0x44>
        return;
    }
    while(*dest&&*src){
   15043:	eb 17                	jmp    1505c <kernel_strcpy+0x28>
        *dest++=*src++;
   15045:	8b 55 0c             	mov    0xc(%ebp),%edx
   15048:	8d 42 01             	lea    0x1(%edx),%eax
   1504b:	89 45 0c             	mov    %eax,0xc(%ebp)
   1504e:	8b 45 08             	mov    0x8(%ebp),%eax
   15051:	8d 48 01             	lea    0x1(%eax),%ecx
   15054:	89 4d 08             	mov    %ecx,0x8(%ebp)
   15057:	0f b6 12             	movzbl (%edx),%edx
   1505a:	88 10                	mov    %dl,(%eax)
    while(*dest&&*src){
   1505c:	8b 45 08             	mov    0x8(%ebp),%eax
   1505f:	0f b6 00             	movzbl (%eax),%eax
   15062:	84 c0                	test   %al,%al
   15064:	74 0a                	je     15070 <kernel_strcpy+0x3c>
   15066:	8b 45 0c             	mov    0xc(%ebp),%eax
   15069:	0f b6 00             	movzbl (%eax),%eax
   1506c:	84 c0                	test   %al,%al
   1506e:	75 d5                	jne    15045 <kernel_strcpy+0x11>
    }
    *dest='\0';
   15070:	8b 45 08             	mov    0x8(%ebp),%eax
   15073:	c6 00 00             	movb   $0x0,(%eax)
   15076:	eb 01                	jmp    15079 <kernel_strcpy+0x45>
        return;
   15078:	90                   	nop
}
   15079:	5d                   	pop    %ebp
   1507a:	c3                   	ret    

0001507b <kernel_strncpy>:

// 复制字符串指明复制多个字符
void kernel_strncpy(char* dest,const char* src,unsigned int size){
   1507b:	55                   	push   %ebp
   1507c:	89 e5                	mov    %esp,%ebp
   1507e:	83 ec 10             	sub    $0x10,%esp
    if(!dest||!src||!size){
   15081:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   15085:	74 61                	je     150e8 <kernel_strncpy+0x6d>
   15087:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1508b:	74 5b                	je     150e8 <kernel_strncpy+0x6d>
   1508d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   15091:	74 55                	je     150e8 <kernel_strncpy+0x6d>
        return;
    }
    char*d=dest;
   15093:	8b 45 08             	mov    0x8(%ebp),%eax
   15096:	89 45 fc             	mov    %eax,-0x4(%ebp)
    const char* s=src;
   15099:	8b 45 0c             	mov    0xc(%ebp),%eax
   1509c:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while((size-->0)&&(*s)){
   1509f:	eb 17                	jmp    150b8 <kernel_strncpy+0x3d>
        *d++=*s++;
   150a1:	8b 55 f8             	mov    -0x8(%ebp),%edx
   150a4:	8d 42 01             	lea    0x1(%edx),%eax
   150a7:	89 45 f8             	mov    %eax,-0x8(%ebp)
   150aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
   150ad:	8d 48 01             	lea    0x1(%eax),%ecx
   150b0:	89 4d fc             	mov    %ecx,-0x4(%ebp)
   150b3:	0f b6 12             	movzbl (%edx),%edx
   150b6:	88 10                	mov    %dl,(%eax)
    while((size-->0)&&(*s)){
   150b8:	8b 45 10             	mov    0x10(%ebp),%eax
   150bb:	8d 50 ff             	lea    -0x1(%eax),%edx
   150be:	89 55 10             	mov    %edx,0x10(%ebp)
   150c1:	85 c0                	test   %eax,%eax
   150c3:	74 0a                	je     150cf <kernel_strncpy+0x54>
   150c5:	8b 45 f8             	mov    -0x8(%ebp),%eax
   150c8:	0f b6 00             	movzbl (%eax),%eax
   150cb:	84 c0                	test   %al,%al
   150cd:	75 d2                	jne    150a1 <kernel_strncpy+0x26>
    }
    if(size==0){
   150cf:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   150d3:	75 0b                	jne    150e0 <kernel_strncpy+0x65>
        *(d-1)='\0';
   150d5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   150d8:	83 e8 01             	sub    $0x1,%eax
   150db:	c6 00 00             	movb   $0x0,(%eax)
   150de:	eb 09                	jmp    150e9 <kernel_strncpy+0x6e>
    }
    else{
        *d='\0';
   150e0:	8b 45 fc             	mov    -0x4(%ebp),%eax
   150e3:	c6 00 00             	movb   $0x0,(%eax)
   150e6:	eb 01                	jmp    150e9 <kernel_strncpy+0x6e>
        return;
   150e8:	90                   	nop
    }
}
   150e9:	c9                   	leave  
   150ea:	c3                   	ret    

000150eb <kernel_strncmp>:


// 比较两个字符串
int kernel_strncmp(const char* s1,const char* s2,unsigned int size){
   150eb:	55                   	push   %ebp
   150ec:	89 e5                	mov    %esp,%ebp
    if(!s1 || !s2){
   150ee:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   150f2:	74 06                	je     150fa <kernel_strncmp+0xf>
   150f4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   150f8:	75 0f                	jne    15109 <kernel_strncmp+0x1e>
        return -1;
   150fa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   150ff:	eb 62                	jmp    15163 <kernel_strncmp+0x78>
    }
    while(*s1 && *s2 && (*s1==*s2) && size){
        s1++;
   15101:	83 45 08 01          	addl   $0x1,0x8(%ebp)
        s2++;
   15105:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
    while(*s1 && *s2 && (*s1==*s2) && size){
   15109:	8b 45 08             	mov    0x8(%ebp),%eax
   1510c:	0f b6 00             	movzbl (%eax),%eax
   1510f:	84 c0                	test   %al,%al
   15111:	74 20                	je     15133 <kernel_strncmp+0x48>
   15113:	8b 45 0c             	mov    0xc(%ebp),%eax
   15116:	0f b6 00             	movzbl (%eax),%eax
   15119:	84 c0                	test   %al,%al
   1511b:	74 16                	je     15133 <kernel_strncmp+0x48>
   1511d:	8b 45 08             	mov    0x8(%ebp),%eax
   15120:	0f b6 10             	movzbl (%eax),%edx
   15123:	8b 45 0c             	mov    0xc(%ebp),%eax
   15126:	0f b6 00             	movzbl (%eax),%eax
   15129:	38 c2                	cmp    %al,%dl
   1512b:	75 06                	jne    15133 <kernel_strncmp+0x48>
   1512d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   15131:	75 ce                	jne    15101 <kernel_strncmp+0x16>
    }
    // 相等返回1
    return !((*s1=='\0') || (*s2=='\0') || (*s1==*s2));
   15133:	8b 45 08             	mov    0x8(%ebp),%eax
   15136:	0f b6 00             	movzbl (%eax),%eax
   15139:	84 c0                	test   %al,%al
   1513b:	74 21                	je     1515e <kernel_strncmp+0x73>
   1513d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15140:	0f b6 00             	movzbl (%eax),%eax
   15143:	84 c0                	test   %al,%al
   15145:	74 17                	je     1515e <kernel_strncmp+0x73>
   15147:	8b 45 08             	mov    0x8(%ebp),%eax
   1514a:	0f b6 10             	movzbl (%eax),%edx
   1514d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15150:	0f b6 00             	movzbl (%eax),%eax
   15153:	38 c2                	cmp    %al,%dl
   15155:	74 07                	je     1515e <kernel_strncmp+0x73>
   15157:	b8 01 00 00 00       	mov    $0x1,%eax
   1515c:	eb 05                	jmp    15163 <kernel_strncmp+0x78>
   1515e:	b8 00 00 00 00       	mov    $0x0,%eax
}
   15163:	5d                   	pop    %ebp
   15164:	c3                   	ret    

00015165 <kernel_strlen>:

// 获取字符串长度
int kernel_strlen(const char* str){
   15165:	55                   	push   %ebp
   15166:	89 e5                	mov    %esp,%ebp
   15168:	83 ec 10             	sub    $0x10,%esp
    if(!str){
   1516b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1516f:	75 07                	jne    15178 <kernel_strlen+0x13>
        return 0;
   15171:	b8 00 00 00 00       	mov    $0x0,%eax
   15176:	eb 26                	jmp    1519e <kernel_strlen+0x39>
    }
    const char*c=str;
   15178:	8b 45 08             	mov    0x8(%ebp),%eax
   1517b:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int len=0;
   1517e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    while(*c++){
   15185:	eb 04                	jmp    1518b <kernel_strlen+0x26>
        len++;
   15187:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    while(*c++){
   1518b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1518e:	8d 50 01             	lea    0x1(%eax),%edx
   15191:	89 55 fc             	mov    %edx,-0x4(%ebp)
   15194:	0f b6 00             	movzbl (%eax),%eax
   15197:	84 c0                	test   %al,%al
   15199:	75 ec                	jne    15187 <kernel_strlen+0x22>
    }
    return len;
   1519b:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
   1519e:	c9                   	leave  
   1519f:	c3                   	ret    

000151a0 <kernel_memcpy>:

// 复制内存的值
void kernel_memcpy(void* dest,void* src,unsigned int size){
   151a0:	55                   	push   %ebp
   151a1:	89 e5                	mov    %esp,%ebp
   151a3:	83 ec 10             	sub    $0x10,%esp
    if(!dest || !src || !size){
   151a6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   151aa:	74 40                	je     151ec <kernel_memcpy+0x4c>
   151ac:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   151b0:	74 3a                	je     151ec <kernel_memcpy+0x4c>
   151b2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   151b6:	74 34                	je     151ec <kernel_memcpy+0x4c>
        return;
    }
    uint8_t* s=(uint8_t*) src;
   151b8:	8b 45 0c             	mov    0xc(%ebp),%eax
   151bb:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint8_t* d=(uint8_t*) dest;
   151be:	8b 45 08             	mov    0x8(%ebp),%eax
   151c1:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while(size--){
   151c4:	eb 17                	jmp    151dd <kernel_memcpy+0x3d>
        *d++=*s++;
   151c6:	8b 55 fc             	mov    -0x4(%ebp),%edx
   151c9:	8d 42 01             	lea    0x1(%edx),%eax
   151cc:	89 45 fc             	mov    %eax,-0x4(%ebp)
   151cf:	8b 45 f8             	mov    -0x8(%ebp),%eax
   151d2:	8d 48 01             	lea    0x1(%eax),%ecx
   151d5:	89 4d f8             	mov    %ecx,-0x8(%ebp)
   151d8:	0f b6 12             	movzbl (%edx),%edx
   151db:	88 10                	mov    %dl,(%eax)
    while(size--){
   151dd:	8b 45 10             	mov    0x10(%ebp),%eax
   151e0:	8d 50 ff             	lea    -0x1(%eax),%edx
   151e3:	89 55 10             	mov    %edx,0x10(%ebp)
   151e6:	85 c0                	test   %eax,%eax
   151e8:	75 dc                	jne    151c6 <kernel_memcpy+0x26>
   151ea:	eb 01                	jmp    151ed <kernel_memcpy+0x4d>
        return;
   151ec:	90                   	nop
    }
    
}
   151ed:	c9                   	leave  
   151ee:	c3                   	ret    

000151ef <kernel_memset>:

// 设置内存的值
void kernel_memset(void* dest,uint8_t v,int size){
   151ef:	55                   	push   %ebp
   151f0:	89 e5                	mov    %esp,%ebp
   151f2:	83 ec 14             	sub    $0x14,%esp
   151f5:	8b 45 0c             	mov    0xc(%ebp),%eax
   151f8:	88 45 ec             	mov    %al,-0x14(%ebp)
    if(!dest || !size){
   151fb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   151ff:	74 2c                	je     1522d <kernel_memset+0x3e>
   15201:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   15205:	74 26                	je     1522d <kernel_memset+0x3e>
        return;
    }
    uint8_t* d=(uint8_t*) dest;
   15207:	8b 45 08             	mov    0x8(%ebp),%eax
   1520a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while(size--){
   1520d:	eb 0f                	jmp    1521e <kernel_memset+0x2f>
        *d++=v;
   1520f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15212:	8d 50 01             	lea    0x1(%eax),%edx
   15215:	89 55 fc             	mov    %edx,-0x4(%ebp)
   15218:	0f b6 55 ec          	movzbl -0x14(%ebp),%edx
   1521c:	88 10                	mov    %dl,(%eax)
    while(size--){
   1521e:	8b 45 10             	mov    0x10(%ebp),%eax
   15221:	8d 50 ff             	lea    -0x1(%eax),%edx
   15224:	89 55 10             	mov    %edx,0x10(%ebp)
   15227:	85 c0                	test   %eax,%eax
   15229:	75 e4                	jne    1520f <kernel_memset+0x20>
   1522b:	eb 01                	jmp    1522e <kernel_memset+0x3f>
        return;
   1522d:	90                   	nop
    }
}
   1522e:	c9                   	leave  
   1522f:	c3                   	ret    

00015230 <kernel_memcmp>:

// 比较内存的值
int kernel_memcmp(void* d1,void* d2,unsigned int size){
   15230:	55                   	push   %ebp
   15231:	89 e5                	mov    %esp,%ebp
   15233:	83 ec 10             	sub    $0x10,%esp
     if(!d1 || !d2 || !size){
   15236:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1523a:	74 0c                	je     15248 <kernel_memcmp+0x18>
   1523c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   15240:	74 06                	je     15248 <kernel_memcmp+0x18>
   15242:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   15246:	75 07                	jne    1524f <kernel_memcmp+0x1f>
        return 1;
   15248:	b8 01 00 00 00       	mov    $0x1,%eax
   1524d:	eb 43                	jmp    15292 <kernel_memcmp+0x62>
    }
    uint8_t* p_d1=(uint8_t*) d1;
   1524f:	8b 45 08             	mov    0x8(%ebp),%eax
   15252:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint8_t* p_d2=(uint8_t*) d2;
   15255:	8b 45 0c             	mov    0xc(%ebp),%eax
   15258:	89 45 f8             	mov    %eax,-0x8(%ebp)
    // 不同返回1，相同返回0
    while(size--){
   1525b:	eb 23                	jmp    15280 <kernel_memcmp+0x50>
        if(*p_d1++!=*p_d2++){
   1525d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15260:	8d 50 01             	lea    0x1(%eax),%edx
   15263:	89 55 fc             	mov    %edx,-0x4(%ebp)
   15266:	0f b6 08             	movzbl (%eax),%ecx
   15269:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1526c:	8d 50 01             	lea    0x1(%eax),%edx
   1526f:	89 55 f8             	mov    %edx,-0x8(%ebp)
   15272:	0f b6 00             	movzbl (%eax),%eax
   15275:	38 c1                	cmp    %al,%cl
   15277:	74 07                	je     15280 <kernel_memcmp+0x50>
            return 1;
   15279:	b8 01 00 00 00       	mov    $0x1,%eax
   1527e:	eb 12                	jmp    15292 <kernel_memcmp+0x62>
    while(size--){
   15280:	8b 45 10             	mov    0x10(%ebp),%eax
   15283:	8d 50 ff             	lea    -0x1(%eax),%edx
   15286:	89 55 10             	mov    %edx,0x10(%ebp)
   15289:	85 c0                	test   %eax,%eax
   1528b:	75 d0                	jne    1525d <kernel_memcmp+0x2d>
        }
    }
    return 0;
   1528d:	b8 00 00 00 00       	mov    $0x0,%eax
}
   15292:	c9                   	leave  
   15293:	c3                   	ret    

00015294 <kernel_sprintf>:

void kernel_sprintf(char* buf,const char* fmt,...){
   15294:	55                   	push   %ebp
   15295:	89 e5                	mov    %esp,%ebp
   15297:	83 ec 18             	sub    $0x18,%esp
    va_list args;
    va_start(args,fmt);
   1529a:	8d 45 10             	lea    0x10(%ebp),%eax
   1529d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kernel_vsprintf(buf,fmt,args);
   152a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   152a3:	83 ec 04             	sub    $0x4,%esp
   152a6:	50                   	push   %eax
   152a7:	ff 75 0c             	pushl  0xc(%ebp)
   152aa:	ff 75 08             	pushl  0x8(%ebp)
   152ad:	e8 45 01 00 00       	call   153f7 <kernel_vsprintf>
   152b2:	83 c4 10             	add    $0x10,%esp
    va_end(args);
}
   152b5:	90                   	nop
   152b6:	c9                   	leave  
   152b7:	c3                   	ret    

000152b8 <kernel_itoa>:

void kernel_itoa(char * buf, int num, int base) {
   152b8:	55                   	push   %ebp
   152b9:	89 e5                	mov    %esp,%ebp
   152bb:	53                   	push   %ebx
   152bc:	83 ec 20             	sub    $0x20,%esp
    static const char * num2ch = {"FEDCBA9876543210123456789ABCDEF"};
    char * p = buf;
   152bf:	8b 45 08             	mov    0x8(%ebp),%eax
   152c2:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int old_num = num;
   152c5:	8b 45 0c             	mov    0xc(%ebp),%eax
   152c8:	89 45 e8             	mov    %eax,-0x18(%ebp)

    if ((base != 2) && (base != 8) && (base != 10) && (base != 16)) {
   152cb:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
   152cf:	74 1d                	je     152ee <kernel_itoa+0x36>
   152d1:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
   152d5:	74 17                	je     152ee <kernel_itoa+0x36>
   152d7:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   152db:	74 11                	je     152ee <kernel_itoa+0x36>
   152dd:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
   152e1:	74 0b                	je     152ee <kernel_itoa+0x36>
        *p = '\0';
   152e3:	8b 45 f8             	mov    -0x8(%ebp),%eax
   152e6:	c6 00 00             	movb   $0x0,(%eax)
        return;
   152e9:	e9 03 01 00 00       	jmp    153f1 <kernel_itoa+0x139>
    }

    int signed_num = 0;
   152ee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    if ((num < 0) && (base == 10)) {
   152f5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   152f9:	79 19                	jns    15314 <kernel_itoa+0x5c>
   152fb:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   152ff:	75 13                	jne    15314 <kernel_itoa+0x5c>
        *p++ = '-';
   15301:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15304:	8d 50 01             	lea    0x1(%eax),%edx
   15307:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1530a:	c6 00 2d             	movb   $0x2d,(%eax)
        signed_num = 1;
   1530d:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    }

    if (signed_num) {
   15314:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   15318:	74 3b                	je     15355 <kernel_itoa+0x9d>
        do {
            char ch = num2ch[num % base + 15];
   1531a:	8b 0d 98 70 01 00    	mov    0x17098,%ecx
   15320:	8b 45 0c             	mov    0xc(%ebp),%eax
   15323:	99                   	cltd   
   15324:	f7 7d 10             	idivl  0x10(%ebp)
   15327:	89 d0                	mov    %edx,%eax
   15329:	83 c0 0f             	add    $0xf,%eax
   1532c:	01 c8                	add    %ecx,%eax
   1532e:	0f b6 00             	movzbl (%eax),%eax
   15331:	88 45 e6             	mov    %al,-0x1a(%ebp)
            *p++ = ch;
   15334:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15337:	8d 50 01             	lea    0x1(%eax),%edx
   1533a:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1533d:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
   15341:	88 10                	mov    %dl,(%eax)
            num /= base;
   15343:	8b 45 0c             	mov    0xc(%ebp),%eax
   15346:	99                   	cltd   
   15347:	f7 7d 10             	idivl  0x10(%ebp)
   1534a:	89 45 0c             	mov    %eax,0xc(%ebp)
        } while (num);
   1534d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   15351:	75 c7                	jne    1531a <kernel_itoa+0x62>
   15353:	eb 4b                	jmp    153a0 <kernel_itoa+0xe8>
    } else {
        uint32_t u_num = (uint32_t)num;
   15355:	8b 45 0c             	mov    0xc(%ebp),%eax
   15358:	89 45 f0             	mov    %eax,-0x10(%ebp)
        do {
            char ch = num2ch[u_num % base + 15];
   1535b:	8b 0d 98 70 01 00    	mov    0x17098,%ecx
   15361:	8b 5d 10             	mov    0x10(%ebp),%ebx
   15364:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15367:	ba 00 00 00 00       	mov    $0x0,%edx
   1536c:	f7 f3                	div    %ebx
   1536e:	89 d0                	mov    %edx,%eax
   15370:	83 c0 0f             	add    $0xf,%eax
   15373:	01 c8                	add    %ecx,%eax
   15375:	0f b6 00             	movzbl (%eax),%eax
   15378:	88 45 e7             	mov    %al,-0x19(%ebp)
            *p++ = ch;
   1537b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1537e:	8d 50 01             	lea    0x1(%eax),%edx
   15381:	89 55 f8             	mov    %edx,-0x8(%ebp)
   15384:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
   15388:	88 10                	mov    %dl,(%eax)
            u_num /= base;
   1538a:	8b 5d 10             	mov    0x10(%ebp),%ebx
   1538d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15390:	ba 00 00 00 00       	mov    $0x0,%edx
   15395:	f7 f3                	div    %ebx
   15397:	89 45 f0             	mov    %eax,-0x10(%ebp)
        } while (u_num);
   1539a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1539e:	75 bb                	jne    1535b <kernel_itoa+0xa3>
    }
    *p-- = '\0';
   153a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   153a3:	8d 50 ff             	lea    -0x1(%eax),%edx
   153a6:	89 55 f8             	mov    %edx,-0x8(%ebp)
   153a9:	c6 00 00             	movb   $0x0,(%eax)

    char * start = (!signed_num) ? buf : buf + 1;
   153ac:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   153b0:	74 08                	je     153ba <kernel_itoa+0x102>
   153b2:	8b 45 08             	mov    0x8(%ebp),%eax
   153b5:	83 c0 01             	add    $0x1,%eax
   153b8:	eb 03                	jmp    153bd <kernel_itoa+0x105>
   153ba:	8b 45 08             	mov    0x8(%ebp),%eax
   153bd:	89 45 ec             	mov    %eax,-0x14(%ebp)
    while (start < p) {
   153c0:	eb 27                	jmp    153e9 <kernel_itoa+0x131>
        char ch = *start;
   153c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   153c5:	0f b6 00             	movzbl (%eax),%eax
   153c8:	88 45 e5             	mov    %al,-0x1b(%ebp)
        *start = *p;
   153cb:	8b 45 f8             	mov    -0x8(%ebp),%eax
   153ce:	0f b6 10             	movzbl (%eax),%edx
   153d1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   153d4:	88 10                	mov    %dl,(%eax)
        *p-- = ch;
   153d6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   153d9:	8d 50 ff             	lea    -0x1(%eax),%edx
   153dc:	89 55 f8             	mov    %edx,-0x8(%ebp)
   153df:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
   153e3:	88 10                	mov    %dl,(%eax)
        start++;
   153e5:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    while (start < p) {
   153e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   153ec:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   153ef:	72 d1                	jb     153c2 <kernel_itoa+0x10a>
    }
}
   153f1:	83 c4 20             	add    $0x20,%esp
   153f4:	5b                   	pop    %ebx
   153f5:	5d                   	pop    %ebp
   153f6:	c3                   	ret    

000153f7 <kernel_vsprintf>:

void kernel_vsprintf(char* buf,const char*fmt,va_list args){
   153f7:	55                   	push   %ebp
   153f8:	89 e5                	mov    %esp,%ebp
   153fa:	83 ec 20             	sub    $0x20,%esp
    enum {NORMAL,READ_FMT} state=NORMAL;
   153fd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    char* curr=buf;
   15404:	8b 45 08             	mov    0x8(%ebp),%eax
   15407:	89 45 f8             	mov    %eax,-0x8(%ebp)
    char ch;
    while((ch=*fmt++)){
   1540a:	e9 17 01 00 00       	jmp    15526 <kernel_vsprintf+0x12f>
       switch (state)
   1540f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15412:	85 c0                	test   %eax,%eax
   15414:	74 0a                	je     15420 <kernel_vsprintf+0x29>
   15416:	83 f8 01             	cmp    $0x1,%eax
   15419:	74 2b                	je     15446 <kernel_vsprintf+0x4f>
   1541b:	e9 06 01 00 00       	jmp    15526 <kernel_vsprintf+0x12f>
       {
            case NORMAL:
                if(ch=='%'){
   15420:	80 7d ef 25          	cmpb   $0x25,-0x11(%ebp)
   15424:	75 0c                	jne    15432 <kernel_vsprintf+0x3b>
                    state=READ_FMT;
   15426:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
   1542d:	e9 f4 00 00 00       	jmp    15526 <kernel_vsprintf+0x12f>
                }
                else{
                    *curr++=ch;
   15432:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15435:	8d 50 01             	lea    0x1(%eax),%edx
   15438:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1543b:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
   1543f:	88 10                	mov    %dl,(%eax)
                }
                break;
   15441:	e9 e0 00 00 00       	jmp    15526 <kernel_vsprintf+0x12f>
            case READ_FMT:
                if(ch=='s'){
   15446:	80 7d ef 73          	cmpb   $0x73,-0x11(%ebp)
   1544a:	75 47                	jne    15493 <kernel_vsprintf+0x9c>
                    const char*str=va_arg(args,char*);
   1544c:	8b 45 10             	mov    0x10(%ebp),%eax
   1544f:	8d 50 04             	lea    0x4(%eax),%edx
   15452:	89 55 10             	mov    %edx,0x10(%ebp)
   15455:	8b 00                	mov    (%eax),%eax
   15457:	89 45 f4             	mov    %eax,-0xc(%ebp)
                    int len=kernel_strlen(str);
   1545a:	ff 75 f4             	pushl  -0xc(%ebp)
   1545d:	e8 03 fd ff ff       	call   15165 <kernel_strlen>
   15462:	83 c4 04             	add    $0x4,%esp
   15465:	89 45 f0             	mov    %eax,-0x10(%ebp)
                    while(len--){
   15468:	eb 17                	jmp    15481 <kernel_vsprintf+0x8a>
                        *curr++=*str++;
   1546a:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1546d:	8d 42 01             	lea    0x1(%edx),%eax
   15470:	89 45 f4             	mov    %eax,-0xc(%ebp)
   15473:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15476:	8d 48 01             	lea    0x1(%eax),%ecx
   15479:	89 4d f8             	mov    %ecx,-0x8(%ebp)
   1547c:	0f b6 12             	movzbl (%edx),%edx
   1547f:	88 10                	mov    %dl,(%eax)
                    while(len--){
   15481:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15484:	8d 50 ff             	lea    -0x1(%eax),%edx
   15487:	89 55 f0             	mov    %edx,-0x10(%ebp)
   1548a:	85 c0                	test   %eax,%eax
   1548c:	75 dc                	jne    1546a <kernel_vsprintf+0x73>
   1548e:	e9 8b 00 00 00       	jmp    1551e <kernel_vsprintf+0x127>
                    }
                }
                else if(ch=='d'){
   15493:	80 7d ef 64          	cmpb   $0x64,-0x11(%ebp)
   15497:	75 2e                	jne    154c7 <kernel_vsprintf+0xd0>
                    int num=va_arg(args,int);
   15499:	8b 45 10             	mov    0x10(%ebp),%eax
   1549c:	8d 50 04             	lea    0x4(%eax),%edx
   1549f:	89 55 10             	mov    %edx,0x10(%ebp)
   154a2:	8b 00                	mov    (%eax),%eax
   154a4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                    kernel_itoa(curr,num,10);
   154a7:	6a 0a                	push   $0xa
   154a9:	ff 75 e4             	pushl  -0x1c(%ebp)
   154ac:	ff 75 f8             	pushl  -0x8(%ebp)
   154af:	e8 04 fe ff ff       	call   152b8 <kernel_itoa>
   154b4:	83 c4 0c             	add    $0xc,%esp
                    curr+=kernel_strlen(curr);
   154b7:	ff 75 f8             	pushl  -0x8(%ebp)
   154ba:	e8 a6 fc ff ff       	call   15165 <kernel_strlen>
   154bf:	83 c4 04             	add    $0x4,%esp
   154c2:	01 45 f8             	add    %eax,-0x8(%ebp)
   154c5:	eb 57                	jmp    1551e <kernel_vsprintf+0x127>
                }
                else if(ch=='x'){
   154c7:	80 7d ef 78          	cmpb   $0x78,-0x11(%ebp)
   154cb:	75 2e                	jne    154fb <kernel_vsprintf+0x104>
                    int num=va_arg(args,int);
   154cd:	8b 45 10             	mov    0x10(%ebp),%eax
   154d0:	8d 50 04             	lea    0x4(%eax),%edx
   154d3:	89 55 10             	mov    %edx,0x10(%ebp)
   154d6:	8b 00                	mov    (%eax),%eax
   154d8:	89 45 e8             	mov    %eax,-0x18(%ebp)
                    kernel_itoa(curr,num,16);
   154db:	6a 10                	push   $0x10
   154dd:	ff 75 e8             	pushl  -0x18(%ebp)
   154e0:	ff 75 f8             	pushl  -0x8(%ebp)
   154e3:	e8 d0 fd ff ff       	call   152b8 <kernel_itoa>
   154e8:	83 c4 0c             	add    $0xc,%esp
                    curr+=kernel_strlen(curr);
   154eb:	ff 75 f8             	pushl  -0x8(%ebp)
   154ee:	e8 72 fc ff ff       	call   15165 <kernel_strlen>
   154f3:	83 c4 04             	add    $0x4,%esp
   154f6:	01 45 f8             	add    %eax,-0x8(%ebp)
   154f9:	eb 23                	jmp    1551e <kernel_vsprintf+0x127>
                }
                else if(ch=='c'){
   154fb:	80 7d ef 63          	cmpb   $0x63,-0x11(%ebp)
   154ff:	75 1d                	jne    1551e <kernel_vsprintf+0x127>
                    char c=va_arg(args,int);
   15501:	8b 45 10             	mov    0x10(%ebp),%eax
   15504:	8d 50 04             	lea    0x4(%eax),%edx
   15507:	89 55 10             	mov    %edx,0x10(%ebp)
   1550a:	8b 00                	mov    (%eax),%eax
   1550c:	88 45 ee             	mov    %al,-0x12(%ebp)
                    *curr++=c;
   1550f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15512:	8d 50 01             	lea    0x1(%eax),%edx
   15515:	89 55 f8             	mov    %edx,-0x8(%ebp)
   15518:	0f b6 55 ee          	movzbl -0x12(%ebp),%edx
   1551c:	88 10                	mov    %dl,(%eax)
                }
                state=NORMAL;
   1551e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
                break;
   15525:	90                   	nop
    while((ch=*fmt++)){
   15526:	8b 45 0c             	mov    0xc(%ebp),%eax
   15529:	8d 50 01             	lea    0x1(%eax),%edx
   1552c:	89 55 0c             	mov    %edx,0xc(%ebp)
   1552f:	0f b6 00             	movzbl (%eax),%eax
   15532:	88 45 ef             	mov    %al,-0x11(%ebp)
   15535:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
   15539:	0f 85 d0 fe ff ff    	jne    1540f <kernel_vsprintf+0x18>
        
       }
    }

}
   1553f:	90                   	nop
   15540:	c9                   	leave  
   15541:	c3                   	ret    

00015542 <panic>:

void panic (const char * file, int line, const char * func, const char * cond){
   15542:	55                   	push   %ebp
   15543:	89 e5                	mov    %esp,%ebp
   15545:	83 ec 08             	sub    $0x8,%esp
    log_printf("assert failed!, %s\n",cond);
   15548:	83 ec 08             	sub    $0x8,%esp
   1554b:	ff 75 14             	pushl  0x14(%ebp)
   1554e:	68 10 65 01 00       	push   $0x16510
   15553:	e8 ba 02 00 00       	call   15812 <log_printf>
   15558:	83 c4 10             	add    $0x10,%esp
    log_printf("file: %s\nline: %d\nfunc: %s\n",file,line,func);
   1555b:	ff 75 10             	pushl  0x10(%ebp)
   1555e:	ff 75 0c             	pushl  0xc(%ebp)
   15561:	ff 75 08             	pushl  0x8(%ebp)
   15564:	68 24 65 01 00       	push   $0x16524
   15569:	e8 a4 02 00 00       	call   15812 <log_printf>
   1556e:	83 c4 10             	add    $0x10,%esp
    for(;;){
        hlt();
   15571:	e8 b7 fa ff ff       	call   1502d <hlt>
   15576:	eb f9                	jmp    15571 <panic+0x2f>

00015578 <string_count>:
    }
}

int string_count(char**start){
   15578:	55                   	push   %ebp
   15579:	89 e5                	mov    %esp,%ebp
   1557b:	83 ec 10             	sub    $0x10,%esp
    int count=0;
   1557e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    if(start){
   15585:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   15589:	74 15                	je     155a0 <string_count+0x28>
        while(*start++){
   1558b:	eb 04                	jmp    15591 <string_count+0x19>
            count++;
   1558d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        while(*start++){
   15591:	8b 45 08             	mov    0x8(%ebp),%eax
   15594:	8d 50 04             	lea    0x4(%eax),%edx
   15597:	89 55 08             	mov    %edx,0x8(%ebp)
   1559a:	8b 00                	mov    (%eax),%eax
   1559c:	85 c0                	test   %eax,%eax
   1559e:	75 ed                	jne    1558d <string_count+0x15>
        }
    }

    return count;
   155a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   155a3:	c9                   	leave  
   155a4:	c3                   	ret    

000155a5 <get_file_name>:

char* get_file_name(char*name){
   155a5:	55                   	push   %ebp
   155a6:	89 e5                	mov    %esp,%ebp
   155a8:	83 ec 10             	sub    $0x10,%esp
    char*s=name;
   155ab:	8b 45 08             	mov    0x8(%ebp),%eax
   155ae:	89 45 fc             	mov    %eax,-0x4(%ebp)

    while(*s!='\0'){
   155b1:	eb 04                	jmp    155b7 <get_file_name+0x12>
        s++;
   155b3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    while(*s!='\0'){
   155b7:	8b 45 fc             	mov    -0x4(%ebp),%eax
   155ba:	0f b6 00             	movzbl (%eax),%eax
   155bd:	84 c0                	test   %al,%al
   155bf:	75 f2                	jne    155b3 <get_file_name+0xe>
    }

    while((*s!='/') && (*s!='\\') && (s>=name)){
   155c1:	eb 04                	jmp    155c7 <get_file_name+0x22>
        s--;
   155c3:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    while((*s!='/') && (*s!='\\') && (s>=name)){
   155c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
   155ca:	0f b6 00             	movzbl (%eax),%eax
   155cd:	3c 2f                	cmp    $0x2f,%al
   155cf:	74 12                	je     155e3 <get_file_name+0x3e>
   155d1:	8b 45 fc             	mov    -0x4(%ebp),%eax
   155d4:	0f b6 00             	movzbl (%eax),%eax
   155d7:	3c 5c                	cmp    $0x5c,%al
   155d9:	74 08                	je     155e3 <get_file_name+0x3e>
   155db:	8b 45 fc             	mov    -0x4(%ebp),%eax
   155de:	3b 45 08             	cmp    0x8(%ebp),%eax
   155e1:	73 e0                	jae    155c3 <get_file_name+0x1e>
    }

    return s+1;
   155e3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   155e6:	83 c0 01             	add    $0x1,%eax
   155e9:	c9                   	leave  
   155ea:	c3                   	ret    

000155eb <list_is_empty>:
static inline int list_is_empty(list_t* list){
   155eb:	55                   	push   %ebp
   155ec:	89 e5                	mov    %esp,%ebp
    return list->count==0;
   155ee:	8b 45 08             	mov    0x8(%ebp),%eax
   155f1:	8b 40 08             	mov    0x8(%eax),%eax
   155f4:	85 c0                	test   %eax,%eax
   155f6:	0f 94 c0             	sete   %al
   155f9:	0f b6 c0             	movzbl %al,%eax
}
   155fc:	5d                   	pop    %ebp
   155fd:	c3                   	ret    

000155fe <list_init>:
#include "tools/list.h"

void list_init(list_t* list){
   155fe:	55                   	push   %ebp
   155ff:	89 e5                	mov    %esp,%ebp
    list->first=list->last=(list_node_t*)0;
   15601:	8b 45 08             	mov    0x8(%ebp),%eax
   15604:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   1560b:	8b 45 08             	mov    0x8(%ebp),%eax
   1560e:	8b 50 04             	mov    0x4(%eax),%edx
   15611:	8b 45 08             	mov    0x8(%ebp),%eax
   15614:	89 10                	mov    %edx,(%eax)
    list->count=0;
   15616:	8b 45 08             	mov    0x8(%ebp),%eax
   15619:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
   15620:	90                   	nop
   15621:	5d                   	pop    %ebp
   15622:	c3                   	ret    

00015623 <list_insert_first>:

void list_insert_first(list_t* list,list_node_t* node){
   15623:	55                   	push   %ebp
   15624:	89 e5                	mov    %esp,%ebp
    node->next=list->first;
   15626:	8b 45 08             	mov    0x8(%ebp),%eax
   15629:	8b 10                	mov    (%eax),%edx
   1562b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1562e:	89 50 04             	mov    %edx,0x4(%eax)
    node->pre=(list_node_t*)0;
   15631:	8b 45 0c             	mov    0xc(%ebp),%eax
   15634:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(list_is_empty(list)){
   1563a:	ff 75 08             	pushl  0x8(%ebp)
   1563d:	e8 a9 ff ff ff       	call   155eb <list_is_empty>
   15642:	83 c4 04             	add    $0x4,%esp
   15645:	85 c0                	test   %eax,%eax
   15647:	74 15                	je     1565e <list_insert_first+0x3b>
        list->last=list->first=node;
   15649:	8b 45 08             	mov    0x8(%ebp),%eax
   1564c:	8b 55 0c             	mov    0xc(%ebp),%edx
   1564f:	89 10                	mov    %edx,(%eax)
   15651:	8b 45 08             	mov    0x8(%ebp),%eax
   15654:	8b 10                	mov    (%eax),%edx
   15656:	8b 45 08             	mov    0x8(%ebp),%eax
   15659:	89 50 04             	mov    %edx,0x4(%eax)
   1565c:	eb 12                	jmp    15670 <list_insert_first+0x4d>
    }
    else{
        list->first->pre=node;
   1565e:	8b 45 08             	mov    0x8(%ebp),%eax
   15661:	8b 00                	mov    (%eax),%eax
   15663:	8b 55 0c             	mov    0xc(%ebp),%edx
   15666:	89 10                	mov    %edx,(%eax)
        list->first=node;
   15668:	8b 45 08             	mov    0x8(%ebp),%eax
   1566b:	8b 55 0c             	mov    0xc(%ebp),%edx
   1566e:	89 10                	mov    %edx,(%eax)
    }
    list->count++;
   15670:	8b 45 08             	mov    0x8(%ebp),%eax
   15673:	8b 40 08             	mov    0x8(%eax),%eax
   15676:	8d 50 01             	lea    0x1(%eax),%edx
   15679:	8b 45 08             	mov    0x8(%ebp),%eax
   1567c:	89 50 08             	mov    %edx,0x8(%eax)
}
   1567f:	90                   	nop
   15680:	c9                   	leave  
   15681:	c3                   	ret    

00015682 <list_insert_last>:

void list_insert_last(list_t*list,list_node_t*node){
   15682:	55                   	push   %ebp
   15683:	89 e5                	mov    %esp,%ebp
    node->pre=list->last;
   15685:	8b 45 08             	mov    0x8(%ebp),%eax
   15688:	8b 50 04             	mov    0x4(%eax),%edx
   1568b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1568e:	89 10                	mov    %edx,(%eax)
    node->next=(list_node_t*)0;
   15690:	8b 45 0c             	mov    0xc(%ebp),%eax
   15693:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    if(list_is_empty(list)){
   1569a:	ff 75 08             	pushl  0x8(%ebp)
   1569d:	e8 49 ff ff ff       	call   155eb <list_is_empty>
   156a2:	83 c4 04             	add    $0x4,%esp
   156a5:	85 c0                	test   %eax,%eax
   156a7:	74 16                	je     156bf <list_insert_last+0x3d>
        list->first=list->last=node;
   156a9:	8b 45 08             	mov    0x8(%ebp),%eax
   156ac:	8b 55 0c             	mov    0xc(%ebp),%edx
   156af:	89 50 04             	mov    %edx,0x4(%eax)
   156b2:	8b 45 08             	mov    0x8(%ebp),%eax
   156b5:	8b 50 04             	mov    0x4(%eax),%edx
   156b8:	8b 45 08             	mov    0x8(%ebp),%eax
   156bb:	89 10                	mov    %edx,(%eax)
   156bd:	eb 15                	jmp    156d4 <list_insert_last+0x52>
    }
    else{
        list->last->next=node;
   156bf:	8b 45 08             	mov    0x8(%ebp),%eax
   156c2:	8b 40 04             	mov    0x4(%eax),%eax
   156c5:	8b 55 0c             	mov    0xc(%ebp),%edx
   156c8:	89 50 04             	mov    %edx,0x4(%eax)
        list->last=node;
   156cb:	8b 45 08             	mov    0x8(%ebp),%eax
   156ce:	8b 55 0c             	mov    0xc(%ebp),%edx
   156d1:	89 50 04             	mov    %edx,0x4(%eax)
    }
    list->count++;
   156d4:	8b 45 08             	mov    0x8(%ebp),%eax
   156d7:	8b 40 08             	mov    0x8(%eax),%eax
   156da:	8d 50 01             	lea    0x1(%eax),%edx
   156dd:	8b 45 08             	mov    0x8(%ebp),%eax
   156e0:	89 50 08             	mov    %edx,0x8(%eax)
}
   156e3:	90                   	nop
   156e4:	c9                   	leave  
   156e5:	c3                   	ret    

000156e6 <list_remove_first>:

list_node_t* list_remove_first(list_t* list){
   156e6:	55                   	push   %ebp
   156e7:	89 e5                	mov    %esp,%ebp
   156e9:	83 ec 10             	sub    $0x10,%esp
    if(list_is_empty(list)){
   156ec:	ff 75 08             	pushl  0x8(%ebp)
   156ef:	e8 f7 fe ff ff       	call   155eb <list_is_empty>
   156f4:	83 c4 04             	add    $0x4,%esp
   156f7:	85 c0                	test   %eax,%eax
   156f9:	74 07                	je     15702 <list_remove_first+0x1c>
        return (list_node_t*)0;
   156fb:	b8 00 00 00 00       	mov    $0x0,%eax
   15700:	eb 5a                	jmp    1575c <list_remove_first+0x76>
    }
    list_node_t* remove_node=list->first;
   15702:	8b 45 08             	mov    0x8(%ebp),%eax
   15705:	8b 00                	mov    (%eax),%eax
   15707:	89 45 fc             	mov    %eax,-0x4(%ebp)
    list->first=remove_node->next;
   1570a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1570d:	8b 50 04             	mov    0x4(%eax),%edx
   15710:	8b 45 08             	mov    0x8(%ebp),%eax
   15713:	89 10                	mov    %edx,(%eax)
    if(list->first==(list_node_t*)0){
   15715:	8b 45 08             	mov    0x8(%ebp),%eax
   15718:	8b 00                	mov    (%eax),%eax
   1571a:	85 c0                	test   %eax,%eax
   1571c:	75 0c                	jne    1572a <list_remove_first+0x44>
        list->last=(list_node_t*)0;
   1571e:	8b 45 08             	mov    0x8(%ebp),%eax
   15721:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   15728:	eb 0b                	jmp    15735 <list_remove_first+0x4f>
    }
    else{
        list->first->pre=(list_node_t*)0;
   1572a:	8b 45 08             	mov    0x8(%ebp),%eax
   1572d:	8b 00                	mov    (%eax),%eax
   1572f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    remove_node->pre=remove_node->next=(list_node_t*)0;
   15735:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15738:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   1573f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15742:	8b 50 04             	mov    0x4(%eax),%edx
   15745:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15748:	89 10                	mov    %edx,(%eax)
    list->count--;
   1574a:	8b 45 08             	mov    0x8(%ebp),%eax
   1574d:	8b 40 08             	mov    0x8(%eax),%eax
   15750:	8d 50 ff             	lea    -0x1(%eax),%edx
   15753:	8b 45 08             	mov    0x8(%ebp),%eax
   15756:	89 50 08             	mov    %edx,0x8(%eax)
    return remove_node;
   15759:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   1575c:	c9                   	leave  
   1575d:	c3                   	ret    

0001575e <list_remove>:

list_node_t* list_remove(list_t* list,list_node_t*node){
   1575e:	55                   	push   %ebp
   1575f:	89 e5                	mov    %esp,%ebp
    if(node==list->first){
   15761:	8b 45 08             	mov    0x8(%ebp),%eax
   15764:	8b 00                	mov    (%eax),%eax
   15766:	39 45 0c             	cmp    %eax,0xc(%ebp)
   15769:	75 0b                	jne    15776 <list_remove+0x18>
        list->first=node->next;
   1576b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1576e:	8b 50 04             	mov    0x4(%eax),%edx
   15771:	8b 45 08             	mov    0x8(%ebp),%eax
   15774:	89 10                	mov    %edx,(%eax)
    }
    if(node==list->last){
   15776:	8b 45 08             	mov    0x8(%ebp),%eax
   15779:	8b 40 04             	mov    0x4(%eax),%eax
   1577c:	39 45 0c             	cmp    %eax,0xc(%ebp)
   1577f:	75 0b                	jne    1578c <list_remove+0x2e>
        list->last=node->pre;
   15781:	8b 45 0c             	mov    0xc(%ebp),%eax
   15784:	8b 10                	mov    (%eax),%edx
   15786:	8b 45 08             	mov    0x8(%ebp),%eax
   15789:	89 50 04             	mov    %edx,0x4(%eax)
    }
    if(node->pre){
   1578c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1578f:	8b 00                	mov    (%eax),%eax
   15791:	85 c0                	test   %eax,%eax
   15793:	74 0e                	je     157a3 <list_remove+0x45>
        node->pre->next=node->next;
   15795:	8b 45 0c             	mov    0xc(%ebp),%eax
   15798:	8b 00                	mov    (%eax),%eax
   1579a:	8b 55 0c             	mov    0xc(%ebp),%edx
   1579d:	8b 52 04             	mov    0x4(%edx),%edx
   157a0:	89 50 04             	mov    %edx,0x4(%eax)
    }
    if(node->next){
   157a3:	8b 45 0c             	mov    0xc(%ebp),%eax
   157a6:	8b 40 04             	mov    0x4(%eax),%eax
   157a9:	85 c0                	test   %eax,%eax
   157ab:	74 0d                	je     157ba <list_remove+0x5c>
        node->next->pre=node->pre;
   157ad:	8b 45 0c             	mov    0xc(%ebp),%eax
   157b0:	8b 40 04             	mov    0x4(%eax),%eax
   157b3:	8b 55 0c             	mov    0xc(%ebp),%edx
   157b6:	8b 12                	mov    (%edx),%edx
   157b8:	89 10                	mov    %edx,(%eax)
    }
    node->pre=node->next=(list_node_t*)0;
   157ba:	8b 45 0c             	mov    0xc(%ebp),%eax
   157bd:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   157c4:	8b 45 0c             	mov    0xc(%ebp),%eax
   157c7:	8b 50 04             	mov    0x4(%eax),%edx
   157ca:	8b 45 0c             	mov    0xc(%ebp),%eax
   157cd:	89 10                	mov    %edx,(%eax)
    list->count--;
   157cf:	8b 45 08             	mov    0x8(%ebp),%eax
   157d2:	8b 40 08             	mov    0x8(%eax),%eax
   157d5:	8d 50 ff             	lea    -0x1(%eax),%edx
   157d8:	8b 45 08             	mov    0x8(%ebp),%eax
   157db:	89 50 08             	mov    %edx,0x8(%eax)
    return node;
   157de:	8b 45 0c             	mov    0xc(%ebp),%eax
   157e1:	5d                   	pop    %ebp
   157e2:	c3                   	ret    

000157e3 <log_init>:
static mutex_t mutex;

// 用来记录打印设备的id
static int log_dev_id;

void log_init(void){
   157e3:	55                   	push   %ebp
   157e4:	89 e5                	mov    %esp,%ebp
   157e6:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&mutex);
   157e9:	83 ec 0c             	sub    $0xc,%esp
   157ec:	68 c4 a3 06 00       	push   $0x6a3c4
   157f1:	e8 01 f3 ff ff       	call   14af7 <mutex_init>
   157f6:	83 c4 10             	add    $0x10,%esp

    log_dev_id=dev_open(DEV_TTY,0,0);
   157f9:	83 ec 04             	sub    $0x4,%esp
   157fc:	6a 00                	push   $0x0
   157fe:	6a 00                	push   $0x0
   15800:	6a 01                	push   $0x1
   15802:	e8 e6 df ff ff       	call   137ed <dev_open>
   15807:	83 c4 10             	add    $0x10,%esp
   1580a:	a3 d8 a3 06 00       	mov    %eax,0x6a3d8
    outb(COM1_PORT+1,0x00);
    outb(COM1_PORT+3,0x03);
    outb(COM1_PORT+2,0xc7);
    outb(COM1_PORT+4,0x0F);
#endif
}
   1580f:	90                   	nop
   15810:	c9                   	leave  
   15811:	c3                   	ret    

00015812 <log_printf>:

void log_printf(const char* fmt,...){
   15812:	55                   	push   %ebp
   15813:	89 e5                	mov    %esp,%ebp
   15815:	81 ec 98 00 00 00    	sub    $0x98,%esp
    char str_buf[128];
    va_list args;
    kernel_memset(str_buf,'\0',128);
   1581b:	83 ec 04             	sub    $0x4,%esp
   1581e:	68 80 00 00 00       	push   $0x80
   15823:	6a 00                	push   $0x0
   15825:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   1582b:	50                   	push   %eax
   1582c:	e8 be f9 ff ff       	call   151ef <kernel_memset>
   15831:	83 c4 10             	add    $0x10,%esp
    va_start(args,fmt);
   15834:	8d 45 0c             	lea    0xc(%ebp),%eax
   15837:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
    kernel_vsprintf(str_buf,fmt,args);
   1583d:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
   15843:	83 ec 04             	sub    $0x4,%esp
   15846:	50                   	push   %eax
   15847:	ff 75 08             	pushl  0x8(%ebp)
   1584a:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   15850:	50                   	push   %eax
   15851:	e8 a1 fb ff ff       	call   153f7 <kernel_vsprintf>
   15856:	83 c4 10             	add    $0x10,%esp
    va_end(args);
    
    mutex_lock(&mutex);
   15859:	83 ec 0c             	sub    $0xc,%esp
   1585c:	68 c4 a3 06 00       	push   $0x6a3c4
   15861:	e8 bf f2 ff ff       	call   14b25 <mutex_lock>
   15866:	83 c4 10             	add    $0x10,%esp
    }
    outb(COM1_PORT,'\r');
    outb(COM1_PORT,'\n');
#else
    // console_write(0,str_buf,kernel_strlen(str_buf));
    dev_write(log_dev_id,0,str_buf,kernel_strlen(str_buf));
   15869:	83 ec 0c             	sub    $0xc,%esp
   1586c:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   15872:	50                   	push   %eax
   15873:	e8 ed f8 ff ff       	call   15165 <kernel_strlen>
   15878:	83 c4 10             	add    $0x10,%esp
   1587b:	89 c2                	mov    %eax,%edx
   1587d:	a1 d8 a3 06 00       	mov    0x6a3d8,%eax
   15882:	52                   	push   %edx
   15883:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
   15889:	52                   	push   %edx
   1588a:	6a 00                	push   $0x0
   1588c:	50                   	push   %eax
   1588d:	e8 f7 e0 ff ff       	call   13989 <dev_write>
   15892:	83 c4 10             	add    $0x10,%esp
    char c='\n';
   15895:	c6 85 73 ff ff ff 0a 	movb   $0xa,-0x8d(%ebp)
    // console_write(0,&c,1);
    dev_write(log_dev_id,0,&c,1);
   1589c:	a1 d8 a3 06 00       	mov    0x6a3d8,%eax
   158a1:	6a 01                	push   $0x1
   158a3:	8d 95 73 ff ff ff    	lea    -0x8d(%ebp),%edx
   158a9:	52                   	push   %edx
   158aa:	6a 00                	push   $0x0
   158ac:	50                   	push   %eax
   158ad:	e8 d7 e0 ff ff       	call   13989 <dev_write>
   158b2:	83 c4 10             	add    $0x10,%esp
#endif
    mutex_unlock(&mutex);
   158b5:	83 ec 0c             	sub    $0xc,%esp
   158b8:	68 c4 a3 06 00       	push   $0x6a3c4
   158bd:	e8 f2 f2 ff ff       	call   14bb4 <mutex_unlock>
   158c2:	83 c4 10             	add    $0x10,%esp
   158c5:	90                   	nop
   158c6:	c9                   	leave  
   158c7:	c3                   	ret    

Disassembly of section .first_task:

80000000 <first_task_entry>:
    .text
	.global first_task_entry
	.extern first_task_main
first_task_entry:
	mov %ss,%ax
80000000:	66 8c d0             	mov    %ss,%ax
	mov %ax, %ds
80000003:	8e d8                	mov    %eax,%ds
	mov %ax, %ss
80000005:	8e d0                	mov    %eax,%ss
	mov %ax, %es
80000007:	8e c0                	mov    %eax,%es
	mov %ax, %fs
80000009:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
8000000b:	8e e8                	mov    %eax,%gs
8000000d:	e9 00 00 00 00       	jmp    80000012 <first_task_main>

80000012 <first_task_main>:
#include "tools/log.h"
#include "core/task.h"
#include "applib/lib_syscall.h"
#include "dev/tty.h" 

int first_task_main(void){
80000012:	55                   	push   %ebp
80000013:	89 e5                	mov    %esp,%ebp
80000015:	83 ec 28             	sub    $0x28,%esp
        print_msg("child task id=%d",pid);
        print_msg("parent: %d",count);
    }
#endif

    for(int i=0;i<TTY_NR;i++){
80000018:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
8000001f:	eb 75                	jmp    80000096 <first_task_main+0x84>
        int pid=fork();
80000021:	e8 61 01 00 00       	call   80000187 <fork>
80000026:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(pid<0){
80000029:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
8000002d:	79 14                	jns    80000043 <first_task_main+0x31>
            print_msg("create shell failed.",0);
8000002f:	83 ec 08             	sub    $0x8,%esp
80000032:	6a 00                	push   $0x0
80000034:	68 ae 00 00 80       	push   $0x800000ae
80000039:	e8 21 01 00 00       	call   8000015f <print_msg>
8000003e:	83 c4 10             	add    $0x10,%esp
            break;
80000041:	eb 59                	jmp    8000009c <first_task_main+0x8a>
        }
        else if(pid==0){
80000043:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
80000047:	75 49                	jne    80000092 <first_task_main+0x80>
            char tty_num[5]="tty:?";
80000049:	c7 45 eb 74 74 79 3a 	movl   $0x3a797474,-0x15(%ebp)
80000050:	c6 45 ef 3f          	movb   $0x3f,-0x11(%ebp)
            tty_num[4]=i+'0';
80000054:	8b 45 f4             	mov    -0xc(%ebp),%eax
80000057:	83 c0 30             	add    $0x30,%eax
8000005a:	88 45 ef             	mov    %al,-0x11(%ebp)
            char* argv[]={tty_num,(char*)0};
8000005d:	8d 45 eb             	lea    -0x15(%ebp),%eax
80000060:	89 45 e0             	mov    %eax,-0x20(%ebp)
80000063:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
            execve("/shell.elf",argv,(char**)0);
8000006a:	83 ec 04             	sub    $0x4,%esp
8000006d:	6a 00                	push   $0x0
8000006f:	8d 45 e0             	lea    -0x20(%ebp),%eax
80000072:	50                   	push   %eax
80000073:	68 c3 00 00 80       	push   $0x800000c3
80000078:	e8 25 01 00 00       	call   800001a2 <execve>
8000007d:	83 c4 10             	add    $0x10,%esp
            
            while(1){
                msleep(1000);
80000080:	83 ec 0c             	sub    $0xc,%esp
80000083:	68 e8 03 00 00       	push   $0x3e8
80000088:	e8 8d 00 00 00       	call   8000011a <msleep>
8000008d:	83 c4 10             	add    $0x10,%esp
80000090:	eb ee                	jmp    80000080 <first_task_main+0x6e>
    for(int i=0;i<TTY_NR;i++){
80000092:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
80000096:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
8000009a:	7e 85                	jle    80000021 <first_task_main+0xf>
            }
        }
    }
    for(;;){
        // print_msg("task id=%d",getpid());
        msleep(1000);
8000009c:	83 ec 0c             	sub    $0xc,%esp
8000009f:	68 e8 03 00 00       	push   $0x3e8
800000a4:	e8 71 00 00 00       	call   8000011a <msleep>
800000a9:	83 c4 10             	add    $0x10,%esp
800000ac:	eb ee                	jmp    8000009c <first_task_main+0x8a>
800000ae:	63 72 65             	arpl   %si,0x65(%edx)
800000b1:	61                   	popa   
800000b2:	74 65                	je     80000119 <sys_call+0x4b>
800000b4:	20 73 68             	and    %dh,0x68(%ebx)
800000b7:	65 6c                	gs insb (%dx),%es:(%edi)
800000b9:	6c                   	insb   (%dx),%es:(%edi)
800000ba:	20 66 61             	and    %ah,0x61(%esi)
800000bd:	69 6c 65 64 2e 00 2f 	imul   $0x732f002e,0x64(%ebp,%eiz,2),%ebp
800000c4:	73 
800000c5:	68 65 6c 6c 2e       	push   $0x2e6c6c65
800000ca:	65 6c                	gs insb (%dx),%es:(%edi)
800000cc:	66                   	data16
	...

800000ce <sys_call>:
#include "lib_syscall.h"
#include "comm/types.h"
#include "core/syscall.h"
#include "os_cfg.h"

static inline int sys_call(syscall_args_t*args){
800000ce:	55                   	push   %ebp
800000cf:	89 e5                	mov    %esp,%ebp
800000d1:	57                   	push   %edi
800000d2:	56                   	push   %esi
800000d3:	53                   	push   %ebx
800000d4:	83 ec 10             	sub    $0x10,%esp
    uint32_t addr[]={0,SELECTOR_SYSCALL | 0};
800000d7:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
800000de:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%ebp)
        "push %[arg0]\n\t"
        "push %[id]\n\t"
        "lcall *(%[a])"
        :"=a"(ret)
        :[a]"r"(addr),
         [arg3]"r"(args->arg3),
800000e5:	8b 45 08             	mov    0x8(%ebp),%eax
800000e8:	8b 50 10             	mov    0x10(%eax),%edx
         [arg2]"r"(args->arg2),
800000eb:	8b 45 08             	mov    0x8(%ebp),%eax
800000ee:	8b 48 0c             	mov    0xc(%eax),%ecx
         [arg1]"r"(args->arg1),
800000f1:	8b 45 08             	mov    0x8(%ebp),%eax
800000f4:	8b 58 08             	mov    0x8(%eax),%ebx
         [arg0]"r"(args->arg0),
800000f7:	8b 45 08             	mov    0x8(%ebp),%eax
800000fa:	8b 70 04             	mov    0x4(%eax),%esi
         [id]"r"(args->id)
800000fd:	8b 45 08             	mov    0x8(%ebp),%eax
80000100:	8b 38                	mov    (%eax),%edi
    __asm__ __volatile__(
80000102:	8d 45 e8             	lea    -0x18(%ebp),%eax
80000105:	52                   	push   %edx
80000106:	51                   	push   %ecx
80000107:	53                   	push   %ebx
80000108:	56                   	push   %esi
80000109:	57                   	push   %edi
8000010a:	ff 18                	lcall  *(%eax)
8000010c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    );
    return ret;
8000010f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
80000112:	83 c4 10             	add    $0x10,%esp
80000115:	5b                   	pop    %ebx
80000116:	5e                   	pop    %esi
80000117:	5f                   	pop    %edi
80000118:	5d                   	pop    %ebp
80000119:	c3                   	ret    

8000011a <msleep>:

void msleep(int ms){
8000011a:	55                   	push   %ebp
8000011b:	89 e5                	mov    %esp,%ebp
8000011d:	83 ec 20             	sub    $0x20,%esp
    if(ms<=0){
80000120:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
80000124:	7e 1b                	jle    80000141 <msleep+0x27>
        return;
    }

    syscall_args_t args;
    args.id=SYS_SLEEP;
80000126:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    args.arg0=ms;
8000012d:	8b 45 08             	mov    0x8(%ebp),%eax
80000130:	89 45 f0             	mov    %eax,-0x10(%ebp)

    sys_call(&args);
80000133:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000136:	50                   	push   %eax
80000137:	e8 92 ff ff ff       	call   800000ce <sys_call>
8000013c:	83 c4 04             	add    $0x4,%esp
8000013f:	eb 01                	jmp    80000142 <msleep+0x28>
        return;
80000141:	90                   	nop
}
80000142:	c9                   	leave  
80000143:	c3                   	ret    

80000144 <getpid>:

int getpid(void){
80000144:	55                   	push   %ebp
80000145:	89 e5                	mov    %esp,%ebp
80000147:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_GETPID;
8000014a:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
    return sys_call(&args);
80000151:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000154:	50                   	push   %eax
80000155:	e8 74 ff ff ff       	call   800000ce <sys_call>
8000015a:	83 c4 04             	add    $0x4,%esp
}
8000015d:	c9                   	leave  
8000015e:	c3                   	ret    

8000015f <print_msg>:

void print_msg(const char* fmt,int arg){
8000015f:	55                   	push   %ebp
80000160:	89 e5                	mov    %esp,%ebp
80000162:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_PRINT_MSG;
80000165:	c7 45 ec 64 00 00 00 	movl   $0x64,-0x14(%ebp)
    args.arg0=(uint32_t)fmt;
8000016c:	8b 45 08             	mov    0x8(%ebp),%eax
8000016f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=arg;
80000172:	8b 45 0c             	mov    0xc(%ebp),%eax
80000175:	89 45 f4             	mov    %eax,-0xc(%ebp)
    sys_call(&args);
80000178:	8d 45 ec             	lea    -0x14(%ebp),%eax
8000017b:	50                   	push   %eax
8000017c:	e8 4d ff ff ff       	call   800000ce <sys_call>
80000181:	83 c4 04             	add    $0x4,%esp
}
80000184:	90                   	nop
80000185:	c9                   	leave  
80000186:	c3                   	ret    

80000187 <fork>:

int fork(void){
80000187:	55                   	push   %ebp
80000188:	89 e5                	mov    %esp,%ebp
8000018a:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_FORK;
8000018d:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
    return sys_call(&args);
80000194:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000197:	50                   	push   %eax
80000198:	e8 31 ff ff ff       	call   800000ce <sys_call>
8000019d:	83 c4 04             	add    $0x4,%esp
}
800001a0:	c9                   	leave  
800001a1:	c3                   	ret    

800001a2 <execve>:

int execve(const char* name,char* const* argv,char* const* env){
800001a2:	55                   	push   %ebp
800001a3:	89 e5                	mov    %esp,%ebp
800001a5:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_EXECVE;
800001a8:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%ebp)
    args.arg0=(int)name;
800001af:	8b 45 08             	mov    0x8(%ebp),%eax
800001b2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=(int)argv;
800001b5:	8b 45 0c             	mov    0xc(%ebp),%eax
800001b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2=(int)env;
800001bb:	8b 45 10             	mov    0x10(%ebp),%eax
800001be:	89 45 f8             	mov    %eax,-0x8(%ebp)

    sys_call(&args);
800001c1:	8d 45 ec             	lea    -0x14(%ebp),%eax
800001c4:	50                   	push   %eax
800001c5:	e8 04 ff ff ff       	call   800000ce <sys_call>
800001ca:	83 c4 04             	add    $0x4,%esp
}
800001cd:	90                   	nop
800001ce:	c9                   	leave  
800001cf:	c3                   	ret    

800001d0 <yield>:

int yield(void){
800001d0:	55                   	push   %ebp
800001d1:	89 e5                	mov    %esp,%ebp
800001d3:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_YIELD;
800001d6:	c7 45 ec 04 00 00 00 	movl   $0x4,-0x14(%ebp)

    return sys_call(&args);
800001dd:	8d 45 ec             	lea    -0x14(%ebp),%eax
800001e0:	50                   	push   %eax
800001e1:	e8 e8 fe ff ff       	call   800000ce <sys_call>
800001e6:	83 c4 04             	add    $0x4,%esp
}
800001e9:	c9                   	leave  
800001ea:	c3                   	ret    

800001eb <open>:

int open(const char*name,int flags, ...){
800001eb:	55                   	push   %ebp
800001ec:	89 e5                	mov    %esp,%ebp
800001ee:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_OPEN;
800001f1:	c7 45 ec 32 00 00 00 	movl   $0x32,-0x14(%ebp)
    args.arg0=(int)name;
800001f8:	8b 45 08             	mov    0x8(%ebp),%eax
800001fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=(int)flags;
800001fe:	8b 45 0c             	mov    0xc(%ebp),%eax
80000201:	89 45 f4             	mov    %eax,-0xc(%ebp)

    return sys_call(&args);
80000204:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000207:	50                   	push   %eax
80000208:	e8 c1 fe ff ff       	call   800000ce <sys_call>
8000020d:	83 c4 04             	add    $0x4,%esp
}
80000210:	c9                   	leave  
80000211:	c3                   	ret    

80000212 <read>:

int read(int file,char* ptr,int len){
80000212:	55                   	push   %ebp
80000213:	89 e5                	mov    %esp,%ebp
80000215:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_READ;
80000218:	c7 45 ec 33 00 00 00 	movl   $0x33,-0x14(%ebp)
    args.arg0=(int)file;
8000021f:	8b 45 08             	mov    0x8(%ebp),%eax
80000222:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=(int)ptr;
80000225:	8b 45 0c             	mov    0xc(%ebp),%eax
80000228:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2=(int)len;
8000022b:	8b 45 10             	mov    0x10(%ebp),%eax
8000022e:	89 45 f8             	mov    %eax,-0x8(%ebp)

    return sys_call(&args);
80000231:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000234:	50                   	push   %eax
80000235:	e8 94 fe ff ff       	call   800000ce <sys_call>
8000023a:	83 c4 04             	add    $0x4,%esp
}
8000023d:	c9                   	leave  
8000023e:	c3                   	ret    

8000023f <write>:

int write(int file,char*ptr,int len){
8000023f:	55                   	push   %ebp
80000240:	89 e5                	mov    %esp,%ebp
80000242:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_WRITE;
80000245:	c7 45 ec 34 00 00 00 	movl   $0x34,-0x14(%ebp)
    args.arg0=(int)file;
8000024c:	8b 45 08             	mov    0x8(%ebp),%eax
8000024f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=(int)ptr;
80000252:	8b 45 0c             	mov    0xc(%ebp),%eax
80000255:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2=(int)len;
80000258:	8b 45 10             	mov    0x10(%ebp),%eax
8000025b:	89 45 f8             	mov    %eax,-0x8(%ebp)

    return sys_call(&args);
8000025e:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000261:	50                   	push   %eax
80000262:	e8 67 fe ff ff       	call   800000ce <sys_call>
80000267:	83 c4 04             	add    $0x4,%esp
}
8000026a:	c9                   	leave  
8000026b:	c3                   	ret    

8000026c <close>:

int close(int file){
8000026c:	55                   	push   %ebp
8000026d:	89 e5                	mov    %esp,%ebp
8000026f:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_CLOSE;
80000272:	c7 45 ec 35 00 00 00 	movl   $0x35,-0x14(%ebp)
    args.arg0=(int)file;
80000279:	8b 45 08             	mov    0x8(%ebp),%eax
8000027c:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return sys_call(&args);
8000027f:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000282:	50                   	push   %eax
80000283:	e8 46 fe ff ff       	call   800000ce <sys_call>
80000288:	83 c4 04             	add    $0x4,%esp
}
8000028b:	c9                   	leave  
8000028c:	c3                   	ret    

8000028d <lseek>:

int lseek(int file,int ptr,int dir){
8000028d:	55                   	push   %ebp
8000028e:	89 e5                	mov    %esp,%ebp
80000290:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_LSEEK;
80000293:	c7 45 ec 36 00 00 00 	movl   $0x36,-0x14(%ebp)
    args.arg0=(int)file;
8000029a:	8b 45 08             	mov    0x8(%ebp),%eax
8000029d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=(int)ptr;
800002a0:	8b 45 0c             	mov    0xc(%ebp),%eax
800002a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2=(int)dir;
800002a6:	8b 45 10             	mov    0x10(%ebp),%eax
800002a9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return sys_call(&args);
800002ac:	8d 45 ec             	lea    -0x14(%ebp),%eax
800002af:	50                   	push   %eax
800002b0:	e8 19 fe ff ff       	call   800000ce <sys_call>
800002b5:	83 c4 04             	add    $0x4,%esp
}
800002b8:	c9                   	leave  
800002b9:	c3                   	ret    

800002ba <isatty>:

int isatty(int file){
800002ba:	55                   	push   %ebp
800002bb:	89 e5                	mov    %esp,%ebp
800002bd:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_ISATTY;
800002c0:	c7 45 ec 37 00 00 00 	movl   $0x37,-0x14(%ebp)
    args.arg0=(int)file;
800002c7:	8b 45 08             	mov    0x8(%ebp),%eax
800002ca:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return sys_call(&args);
800002cd:	8d 45 ec             	lea    -0x14(%ebp),%eax
800002d0:	50                   	push   %eax
800002d1:	e8 f8 fd ff ff       	call   800000ce <sys_call>
800002d6:	83 c4 04             	add    $0x4,%esp
}
800002d9:	c9                   	leave  
800002da:	c3                   	ret    

800002db <fstat>:

int fstat(int file,struct stat* st){
800002db:	55                   	push   %ebp
800002dc:	89 e5                	mov    %esp,%ebp
800002de:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_FSTAT;
800002e1:	c7 45 ec 39 00 00 00 	movl   $0x39,-0x14(%ebp)
    args.arg0=(int)file;
800002e8:	8b 45 08             	mov    0x8(%ebp),%eax
800002eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=(int)st;
800002ee:	8b 45 0c             	mov    0xc(%ebp),%eax
800002f1:	89 45 f4             	mov    %eax,-0xc(%ebp)

    return sys_call(&args);
800002f4:	8d 45 ec             	lea    -0x14(%ebp),%eax
800002f7:	50                   	push   %eax
800002f8:	e8 d1 fd ff ff       	call   800000ce <sys_call>
800002fd:	83 c4 04             	add    $0x4,%esp
}
80000300:	c9                   	leave  
80000301:	c3                   	ret    

80000302 <sbrk>:

void* sbrk(ptrdiff_t incr){
80000302:	55                   	push   %ebp
80000303:	89 e5                	mov    %esp,%ebp
80000305:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_SBRK;
80000308:	c7 45 ec 38 00 00 00 	movl   $0x38,-0x14(%ebp)
    args.arg0=(int)incr;
8000030f:	8b 45 08             	mov    0x8(%ebp),%eax
80000312:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return (void*)sys_call(&args);
80000315:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000318:	50                   	push   %eax
80000319:	e8 b0 fd ff ff       	call   800000ce <sys_call>
8000031e:	83 c4 04             	add    $0x4,%esp
}
80000321:	c9                   	leave  
80000322:	c3                   	ret    

80000323 <dup>:
/*
* @brief 复制文件描述符
* @param file 需要复制的文件描述符
* @return 复制后的文件描述符，失败返回-1
*/
int dup(int file){
80000323:	55                   	push   %ebp
80000324:	89 e5                	mov    %esp,%ebp
80000326:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_DUP;
80000329:	c7 45 ec 3a 00 00 00 	movl   $0x3a,-0x14(%ebp)
    args.arg0=(int)file;
80000330:	8b 45 08             	mov    0x8(%ebp),%eax
80000333:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return sys_call(&args);
80000336:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000339:	50                   	push   %eax
8000033a:	e8 8f fd ff ff       	call   800000ce <sys_call>
8000033f:	83 c4 04             	add    $0x4,%esp
80000342:	c9                   	leave  
80000343:	c3                   	ret    
